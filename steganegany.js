#!/home/shiro/.bun/bin/bun
// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, {
      get: all[name2],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name2] = () => newValue
    });
};

// node_modules/commander/lib/error.js
var require_error = __commonJS((exports) => {
  class CommanderError extends Error {
    constructor(exitCode, code, message) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.code = code;
      this.exitCode = exitCode;
      this.nestedError = undefined;
    }
  }

  class InvalidArgumentError extends CommanderError {
    constructor(message) {
      super(1, "commander.invalidArgument", message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
    }
  }
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS((exports) => {
  var humanReadableArgName = function(arg) {
    const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
    return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  };
  var { InvalidArgumentError } = require_error();

  class Argument {
    constructor(name2, description) {
      this.description = description || "";
      this.variadic = false;
      this.parseArg = undefined;
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.argChoices = undefined;
      switch (name2[0]) {
        case "<":
          this.required = true;
          this._name = name2.slice(1, -1);
          break;
        case "[":
          this.required = false;
          this._name = name2.slice(1, -1);
          break;
        default:
          this.required = true;
          this._name = name2;
          break;
      }
      if (this._name.length > 3 && this._name.slice(-3) === "...") {
        this.variadic = true;
        this._name = this._name.slice(0, -3);
      }
    }
    name() {
      return this._name;
    }
    _concatValue(value2, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value2];
      }
      return previous.concat(value2);
    }
    default(value2, description) {
      this.defaultValue = value2;
      this.defaultValueDescription = description;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    argRequired() {
      this.required = true;
      return this;
    }
    argOptional() {
      this.required = false;
      return this;
    }
  }
  exports.Argument = Argument;
  exports.humanReadableArgName = humanReadableArgName;
});

// node_modules/commander/lib/help.js
var require_help = __commonJS((exports) => {
  var { humanReadableArgName } = require_argument();

  class Help {
    constructor() {
      this.helpWidth = undefined;
      this.sortSubcommands = false;
      this.sortOptions = false;
      this.showGlobalOptions = false;
    }
    visibleCommands(cmd) {
      const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
      const helpCommand = cmd._getHelpCommand();
      if (helpCommand && !helpCommand._hidden) {
        visibleCommands.push(helpCommand);
      }
      if (this.sortSubcommands) {
        visibleCommands.sort((a, b) => {
          return a.name().localeCompare(b.name());
        });
      }
      return visibleCommands;
    }
    compareOptions(a, b) {
      const getSortKey = (option) => {
        return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
      };
      return getSortKey(a).localeCompare(getSortKey(b));
    }
    visibleOptions(cmd) {
      const visibleOptions = cmd.options.filter((option) => !option.hidden);
      const helpOption = cmd._getHelpOption();
      if (helpOption && !helpOption.hidden) {
        const removeShort = helpOption.short && cmd._findOption(helpOption.short);
        const removeLong = helpOption.long && cmd._findOption(helpOption.long);
        if (!removeShort && !removeLong) {
          visibleOptions.push(helpOption);
        } else if (helpOption.long && !removeLong) {
          visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
        } else if (helpOption.short && !removeShort) {
          visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
        }
      }
      if (this.sortOptions) {
        visibleOptions.sort(this.compareOptions);
      }
      return visibleOptions;
    }
    visibleGlobalOptions(cmd) {
      if (!this.showGlobalOptions)
        return [];
      const globalOptions = [];
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
        globalOptions.push(...visibleOptions);
      }
      if (this.sortOptions) {
        globalOptions.sort(this.compareOptions);
      }
      return globalOptions;
    }
    visibleArguments(cmd) {
      if (cmd._argsDescription) {
        cmd.registeredArguments.forEach((argument) => {
          argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
        });
      }
      if (cmd.registeredArguments.find((argument) => argument.description)) {
        return cmd.registeredArguments;
      }
      return [];
    }
    subcommandTerm(cmd) {
      const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
      return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
    }
    optionTerm(option) {
      return option.flags;
    }
    argumentTerm(argument) {
      return argument.name();
    }
    longestSubcommandTermLength(cmd, helper) {
      return helper.visibleCommands(cmd).reduce((max, command) => {
        return Math.max(max, helper.subcommandTerm(command).length);
      }, 0);
    }
    longestOptionTermLength(cmd, helper) {
      return helper.visibleOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestGlobalOptionTermLength(cmd, helper) {
      return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
        return Math.max(max, helper.optionTerm(option).length);
      }, 0);
    }
    longestArgumentTermLength(cmd, helper) {
      return helper.visibleArguments(cmd).reduce((max, argument) => {
        return Math.max(max, helper.argumentTerm(argument).length);
      }, 0);
    }
    commandUsage(cmd) {
      let cmdName = cmd._name;
      if (cmd._aliases[0]) {
        cmdName = cmdName + "|" + cmd._aliases[0];
      }
      let ancestorCmdNames = "";
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
      }
      return ancestorCmdNames + cmdName + " " + cmd.usage();
    }
    commandDescription(cmd) {
      return cmd.description();
    }
    subcommandDescription(cmd) {
      return cmd.summary() || cmd.description();
    }
    optionDescription(option) {
      const extraInfo = [];
      if (option.argChoices) {
        extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (option.defaultValue !== undefined) {
        const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
        if (showDefault) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
      }
      if (option.presetArg !== undefined && option.optional) {
        extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
      }
      if (option.envVar !== undefined) {
        extraInfo.push(`env: ${option.envVar}`);
      }
      if (extraInfo.length > 0) {
        return `${option.description} (${extraInfo.join(", ")})`;
      }
      return option.description;
    }
    argumentDescription(argument) {
      const extraInfo = [];
      if (argument.argChoices) {
        extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (argument.defaultValue !== undefined) {
        extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
      }
      if (extraInfo.length > 0) {
        const extraDescripton = `(${extraInfo.join(", ")})`;
        if (argument.description) {
          return `${argument.description} ${extraDescripton}`;
        }
        return extraDescripton;
      }
      return argument.description;
    }
    formatHelp(cmd, helper) {
      const termWidth = helper.padWidth(cmd, helper);
      const helpWidth = helper.helpWidth || 80;
      const itemIndentWidth = 2;
      const itemSeparatorWidth = 2;
      function formatItem(term, description) {
        if (description) {
          const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
          return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
        }
        return term;
      }
      function formatList(textArray) {
        return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
      }
      let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
      const commandDescription = helper.commandDescription(cmd);
      if (commandDescription.length > 0) {
        output = output.concat([helper.wrap(commandDescription, helpWidth, 0), ""]);
      }
      const argumentList = helper.visibleArguments(cmd).map((argument) => {
        return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
      });
      if (argumentList.length > 0) {
        output = output.concat(["Arguments:", formatList(argumentList), ""]);
      }
      const optionList = helper.visibleOptions(cmd).map((option) => {
        return formatItem(helper.optionTerm(option), helper.optionDescription(option));
      });
      if (optionList.length > 0) {
        output = output.concat(["Options:", formatList(optionList), ""]);
      }
      if (this.showGlobalOptions) {
        const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (globalOptionList.length > 0) {
          output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
        }
      }
      const commandList = helper.visibleCommands(cmd).map((cmd2) => {
        return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
      });
      if (commandList.length > 0) {
        output = output.concat(["Commands:", formatList(commandList), ""]);
      }
      return output.join("\n");
    }
    padWidth(cmd, helper) {
      return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
    }
    wrap(str, width, indent, minColumnWidth = 40) {
      const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
      const manualIndent = new RegExp(`[\\n][${indents}]+`);
      if (str.match(manualIndent))
        return str;
      const columnWidth = width - indent;
      if (columnWidth < minColumnWidth)
        return str;
      const leadingStr = str.slice(0, indent);
      const columnText = str.slice(indent).replace("\r\n", "\n");
      const indentString = " ".repeat(indent);
      const zeroWidthSpace = "\u200B";
      const breaks = `\\s${zeroWidthSpace}`;
      const regex = new RegExp(`\n|.{1,${columnWidth - 1}}([${breaks}]|\$)|[^${breaks}]+?([${breaks}]|\$)`, "g");
      const lines = columnText.match(regex) || [];
      return leadingStr + lines.map((line, i2) => {
        if (line === "\n")
          return "";
        return (i2 > 0 ? indentString : "") + line.trimEnd();
      }).join("\n");
    }
  }
  exports.Help = Help;
});

// node_modules/commander/lib/option.js
var require_option = __commonJS((exports) => {
  var camelcase = function(str) {
    return str.split("-").reduce((str2, word) => {
      return str2 + word[0].toUpperCase() + word.slice(1);
    });
  };
  var splitOptionFlags = function(flags) {
    let shortFlag;
    let longFlag;
    const flagParts = flags.split(/[ |,]+/);
    if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
      shortFlag = flagParts.shift();
    longFlag = flagParts.shift();
    if (!shortFlag && /^-[^-]$/.test(longFlag)) {
      shortFlag = longFlag;
      longFlag = undefined;
    }
    return { shortFlag, longFlag };
  };
  var { InvalidArgumentError } = require_error();

  class Option {
    constructor(flags, description) {
      this.flags = flags;
      this.description = description || "";
      this.required = flags.includes("<");
      this.optional = flags.includes("[");
      this.variadic = /\w\.\.\.[>\]]$/.test(flags);
      this.mandatory = false;
      const optionFlags = splitOptionFlags(flags);
      this.short = optionFlags.shortFlag;
      this.long = optionFlags.longFlag;
      this.negate = false;
      if (this.long) {
        this.negate = this.long.startsWith("--no-");
      }
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.presetArg = undefined;
      this.envVar = undefined;
      this.parseArg = undefined;
      this.hidden = false;
      this.argChoices = undefined;
      this.conflictsWith = [];
      this.implied = undefined;
    }
    default(value2, description) {
      this.defaultValue = value2;
      this.defaultValueDescription = description;
      return this;
    }
    preset(arg) {
      this.presetArg = arg;
      return this;
    }
    conflicts(names) {
      this.conflictsWith = this.conflictsWith.concat(names);
      return this;
    }
    implies(impliedOptionValues) {
      let newImplied = impliedOptionValues;
      if (typeof impliedOptionValues === "string") {
        newImplied = { [impliedOptionValues]: true };
      }
      this.implied = Object.assign(this.implied || {}, newImplied);
      return this;
    }
    env(name2) {
      this.envVar = name2;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    makeOptionMandatory(mandatory = true) {
      this.mandatory = !!mandatory;
      return this;
    }
    hideHelp(hide = true) {
      this.hidden = !!hide;
      return this;
    }
    _concatValue(value2, previous) {
      if (previous === this.defaultValue || !Array.isArray(previous)) {
        return [value2];
      }
      return previous.concat(value2);
    }
    choices(values) {
      this.argChoices = values.slice();
      this.parseArg = (arg, previous) => {
        if (!this.argChoices.includes(arg)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._concatValue(arg, previous);
        }
        return arg;
      };
      return this;
    }
    name() {
      if (this.long) {
        return this.long.replace(/^--/, "");
      }
      return this.short.replace(/^-/, "");
    }
    attributeName() {
      return camelcase(this.name().replace(/^no-/, ""));
    }
    is(arg) {
      return this.short === arg || this.long === arg;
    }
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }

  class DualOptions {
    constructor(options) {
      this.positiveOptions = new Map;
      this.negativeOptions = new Map;
      this.dualOptions = new Set;
      options.forEach((option) => {
        if (option.negate) {
          this.negativeOptions.set(option.attributeName(), option);
        } else {
          this.positiveOptions.set(option.attributeName(), option);
        }
      });
      this.negativeOptions.forEach((value2, key) => {
        if (this.positiveOptions.has(key)) {
          this.dualOptions.add(key);
        }
      });
    }
    valueFromOption(value2, option) {
      const optionKey = option.attributeName();
      if (!this.dualOptions.has(optionKey))
        return true;
      const preset = this.negativeOptions.get(optionKey).presetArg;
      const negativeValue = preset !== undefined ? preset : false;
      return option.negate === (negativeValue === value2);
    }
  }
  exports.Option = Option;
  exports.DualOptions = DualOptions;
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS((exports) => {
  var editDistance = function(a, b) {
    if (Math.abs(a.length - b.length) > maxDistance)
      return Math.max(a.length, b.length);
    const d = [];
    for (let i2 = 0;i2 <= a.length; i2++) {
      d[i2] = [i2];
    }
    for (let j = 0;j <= b.length; j++) {
      d[0][j] = j;
    }
    for (let j = 1;j <= b.length; j++) {
      for (let i2 = 1;i2 <= a.length; i2++) {
        let cost = 1;
        if (a[i2 - 1] === b[j - 1]) {
          cost = 0;
        } else {
          cost = 1;
        }
        d[i2][j] = Math.min(d[i2 - 1][j] + 1, d[i2][j - 1] + 1, d[i2 - 1][j - 1] + cost);
        if (i2 > 1 && j > 1 && a[i2 - 1] === b[j - 2] && a[i2 - 2] === b[j - 1]) {
          d[i2][j] = Math.min(d[i2][j], d[i2 - 2][j - 2] + 1);
        }
      }
    }
    return d[a.length][b.length];
  };
  var suggestSimilar = function(word, candidates) {
    if (!candidates || candidates.length === 0)
      return "";
    candidates = Array.from(new Set(candidates));
    const searchingOptions = word.startsWith("--");
    if (searchingOptions) {
      word = word.slice(2);
      candidates = candidates.map((candidate) => candidate.slice(2));
    }
    let similar = [];
    let bestDistance = maxDistance;
    const minSimilarity = 0.4;
    candidates.forEach((candidate) => {
      if (candidate.length <= 1)
        return;
      const distance2 = editDistance(word, candidate);
      const length = Math.max(word.length, candidate.length);
      const similarity = (length - distance2) / length;
      if (similarity > minSimilarity) {
        if (distance2 < bestDistance) {
          bestDistance = distance2;
          similar = [candidate];
        } else if (distance2 === bestDistance) {
          similar.push(candidate);
        }
      }
    });
    similar.sort((a, b) => a.localeCompare(b));
    if (searchingOptions) {
      similar = similar.map((candidate) => `--${candidate}`);
    }
    if (similar.length > 1) {
      return `\n(Did you mean one of ${similar.join(", ")}?)`;
    }
    if (similar.length === 1) {
      return `\n(Did you mean ${similar[0]}?)`;
    }
    return "";
  };
  var maxDistance = 3;
  exports.suggestSimilar = suggestSimilar;
});

// node_modules/commander/lib/command.js
var require_command = __commonJS((exports) => {
  var incrementNodeInspectorPort = function(args) {
    return args.map((arg) => {
      if (!arg.startsWith("--inspect")) {
        return arg;
      }
      let debugOption;
      let debugHost = "127.0.0.1";
      let debugPort = "9229";
      let match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          debugPort = match[3];
        } else {
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }
      if (debugOption && debugPort !== "0") {
        return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
      return arg;
    });
  };
  var EventEmitter = import.meta.require("events").EventEmitter;
  var childProcess = import.meta.require("child_process");
  var path2 = import.meta.require("path");
  var fs = import.meta.require("fs");
  var process2 = import.meta.require("process");
  var { Argument, humanReadableArgName } = require_argument();
  var { CommanderError } = require_error();
  var { Help } = require_help();
  var { Option, DualOptions } = require_option();
  var { suggestSimilar } = require_suggestSimilar();

  class Command extends EventEmitter {
    constructor(name2) {
      super();
      this.commands = [];
      this.options = [];
      this.parent = null;
      this._allowUnknownOption = false;
      this._allowExcessArguments = true;
      this.registeredArguments = [];
      this._args = this.registeredArguments;
      this.args = [];
      this.rawArgs = [];
      this.processedArgs = [];
      this._scriptPath = null;
      this._name = name2 || "";
      this._optionValues = {};
      this._optionValueSources = {};
      this._storeOptionsAsProperties = false;
      this._actionHandler = null;
      this._executableHandler = false;
      this._executableFile = null;
      this._executableDir = null;
      this._defaultCommandName = null;
      this._exitCallback = null;
      this._aliases = [];
      this._combineFlagAndOptionalValue = true;
      this._description = "";
      this._summary = "";
      this._argsDescription = undefined;
      this._enablePositionalOptions = false;
      this._passThroughOptions = false;
      this._lifeCycleHooks = {};
      this._showHelpAfterError = false;
      this._showSuggestionAfterError = true;
      this._outputConfiguration = {
        writeOut: (str) => process2.stdout.write(str),
        writeErr: (str) => process2.stderr.write(str),
        getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : undefined,
        getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : undefined,
        outputError: (str, write) => write(str)
      };
      this._hidden = false;
      this._helpOption = undefined;
      this._addImplicitHelpCommand = undefined;
      this._helpCommand = undefined;
      this._helpConfiguration = {};
    }
    copyInheritedSettings(sourceCommand) {
      this._outputConfiguration = sourceCommand._outputConfiguration;
      this._helpOption = sourceCommand._helpOption;
      this._helpCommand = sourceCommand._helpCommand;
      this._helpConfiguration = sourceCommand._helpConfiguration;
      this._exitCallback = sourceCommand._exitCallback;
      this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
      this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
      this._allowExcessArguments = sourceCommand._allowExcessArguments;
      this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
      this._showHelpAfterError = sourceCommand._showHelpAfterError;
      this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
      return this;
    }
    _getCommandAndAncestors() {
      const result = [];
      for (let command = this;command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      let desc = actionOptsOrExecDesc;
      let opts = execOpts;
      if (typeof desc === "object" && desc !== null) {
        opts = desc;
        desc = null;
      }
      opts = opts || {};
      const [, name2, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const cmd = this.createCommand(name2);
      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._executableFile = opts.executableFile || null;
      if (args)
        cmd.arguments(args);
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd.copyInheritedSettings(this);
      if (desc)
        return this;
      return cmd;
    }
    createCommand(name2) {
      return new Command(name2);
    }
    createHelp() {
      return Object.assign(new Help, this.configureHelp());
    }
    configureHelp(configuration) {
      if (configuration === undefined)
        return this._helpConfiguration;
      this._helpConfiguration = configuration;
      return this;
    }
    configureOutput(configuration) {
      if (configuration === undefined)
        return this._outputConfiguration;
      Object.assign(this._outputConfiguration, configuration);
      return this;
    }
    showHelpAfterError(displayHelp = true) {
      if (typeof displayHelp !== "string")
        displayHelp = !!displayHelp;
      this._showHelpAfterError = displayHelp;
      return this;
    }
    showSuggestionAfterError(displaySuggestion = true) {
      this._showSuggestionAfterError = !!displaySuggestion;
      return this;
    }
    addCommand(cmd, opts) {
      if (!cmd._name) {
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      }
      opts = opts || {};
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden)
        cmd._hidden = true;
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd._checkForBrokenPassThrough();
      return this;
    }
    createArgument(name2, description) {
      return new Argument(name2, description);
    }
    argument(name2, description, fn, defaultValue) {
      const argument = this.createArgument(name2, description);
      if (typeof fn === "function") {
        argument.default(defaultValue).argParser(fn);
      } else {
        argument.default(fn);
      }
      this.addArgument(argument);
      return this;
    }
    arguments(names) {
      names.trim().split(/ +/).forEach((detail) => {
        this.argument(detail);
      });
      return this;
    }
    addArgument(argument) {
      const previousArgument = this.registeredArguments.slice(-1)[0];
      if (previousArgument && previousArgument.variadic) {
        throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
      }
      if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
        throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
      }
      this.registeredArguments.push(argument);
      return this;
    }
    helpCommand(enableOrNameAndArgs, description) {
      if (typeof enableOrNameAndArgs === "boolean") {
        this._addImplicitHelpCommand = enableOrNameAndArgs;
        return this;
      }
      enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
      const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
      const helpDescription = description ?? "display help for command";
      const helpCommand = this.createCommand(helpName);
      helpCommand.helpOption(false);
      if (helpArgs)
        helpCommand.arguments(helpArgs);
      if (helpDescription)
        helpCommand.description(helpDescription);
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      return this;
    }
    addHelpCommand(helpCommand, deprecatedDescription) {
      if (typeof helpCommand !== "object") {
        this.helpCommand(helpCommand, deprecatedDescription);
        return this;
      }
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      return this;
    }
    _getHelpCommand() {
      const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
      if (hasImplicitHelpCommand) {
        if (this._helpCommand === undefined) {
          this.helpCommand(undefined, undefined);
        }
        return this._helpCommand;
      }
      return null;
    }
    hook(event, listener) {
      const allowedValues = ["preSubcommand", "preAction", "postAction"];
      if (!allowedValues.includes(event)) {
        throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      if (this._lifeCycleHooks[event]) {
        this._lifeCycleHooks[event].push(listener);
      } else {
        this._lifeCycleHooks[event] = [listener];
      }
      return this;
    }
    exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = (err) => {
          if (err.code !== "commander.executeSubCommandAsync") {
            throw err;
          } else {
          }
        };
      }
      return this;
    }
    _exit(exitCode, code, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode, code, message));
      }
      process2.exit(exitCode);
    }
    action(fn) {
      const listener = (args) => {
        const expectedArgsCount = this.registeredArguments.length;
        const actionArgs = args.slice(0, expectedArgsCount);
        if (this._storeOptionsAsProperties) {
          actionArgs[expectedArgsCount] = this;
        } else {
          actionArgs[expectedArgsCount] = this.opts();
        }
        actionArgs.push(this);
        return fn.apply(this, actionArgs);
      };
      this._actionHandler = listener;
      return this;
    }
    createOption(flags, description) {
      return new Option(flags, description);
    }
    _callParseArg(target, value2, previous, invalidArgumentMessage) {
      try {
        return target.parseArg(value2, previous);
      } catch (err) {
        if (err.code === "commander.invalidArgument") {
          const message = `${invalidArgumentMessage} ${err.message}`;
          this.error(message, { exitCode: err.exitCode, code: err.code });
        }
        throw err;
      }
    }
    _registerOption(option) {
      const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
      if (matchingOption) {
        const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
        throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
      }
      this.options.push(option);
    }
    _registerCommand(command) {
      const knownBy = (cmd) => {
        return [cmd.name()].concat(cmd.aliases());
      };
      const alreadyUsed = knownBy(command).find((name2) => this._findCommand(name2));
      if (alreadyUsed) {
        const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
        const newCmd = knownBy(command).join("|");
        throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
      }
      this.commands.push(command);
    }
    addOption(option) {
      this._registerOption(option);
      const oname = option.name();
      const name2 = option.attributeName();
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, "--");
        if (!this._findOption(positiveLongFlag)) {
          this.setOptionValueWithSource(name2, option.defaultValue === undefined ? true : option.defaultValue, "default");
        }
      } else if (option.defaultValue !== undefined) {
        this.setOptionValueWithSource(name2, option.defaultValue, "default");
      }
      const handleOptionValue = (val, invalidValueMessage, valueSource) => {
        if (val == null && option.presetArg !== undefined) {
          val = option.presetArg;
        }
        const oldValue = this.getOptionValue(name2);
        if (val !== null && option.parseArg) {
          val = this._callParseArg(option, val, oldValue, invalidValueMessage);
        } else if (val !== null && option.variadic) {
          val = option._concatValue(val, oldValue);
        }
        if (val == null) {
          if (option.negate) {
            val = false;
          } else if (option.isBoolean() || option.optional) {
            val = true;
          } else {
            val = "";
          }
        }
        this.setOptionValueWithSource(name2, val, valueSource);
      };
      this.on("option:" + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, "cli");
      });
      if (option.envVar) {
        this.on("optionEnv:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "env");
        });
      }
      return this;
    }
    _optionEx(config, flags, description, fn, defaultValue) {
      if (typeof flags === "object" && flags instanceof Option) {
        throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
      }
      const option = this.createOption(flags, description);
      option.makeOptionMandatory(!!config.mandatory);
      if (typeof fn === "function") {
        option.default(defaultValue).argParser(fn);
      } else if (fn instanceof RegExp) {
        const regex = fn;
        fn = (val, def) => {
          const m = regex.exec(val);
          return m ? m[0] : def;
        };
        option.default(defaultValue).argParser(fn);
      } else {
        option.default(fn);
      }
      return this.addOption(option);
    }
    option(flags, description, parseArg, defaultValue) {
      return this._optionEx({}, flags, description, parseArg, defaultValue);
    }
    requiredOption(flags, description, parseArg, defaultValue) {
      return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
    }
    combineFlagAndOptionalValue(combine = true) {
      this._combineFlagAndOptionalValue = !!combine;
      return this;
    }
    allowUnknownOption(allowUnknown = true) {
      this._allowUnknownOption = !!allowUnknown;
      return this;
    }
    allowExcessArguments(allowExcess = true) {
      this._allowExcessArguments = !!allowExcess;
      return this;
    }
    enablePositionalOptions(positional = true) {
      this._enablePositionalOptions = !!positional;
      return this;
    }
    passThroughOptions(passThrough = true) {
      this._passThroughOptions = !!passThrough;
      this._checkForBrokenPassThrough();
      return this;
    }
    _checkForBrokenPassThrough() {
      if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
        throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
      }
    }
    storeOptionsAsProperties(storeAsProperties = true) {
      if (this.options.length) {
        throw new Error("call .storeOptionsAsProperties() before adding options");
      }
      if (Object.keys(this._optionValues).length) {
        throw new Error("call .storeOptionsAsProperties() before setting option values");
      }
      this._storeOptionsAsProperties = !!storeAsProperties;
      return this;
    }
    getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }
      return this._optionValues[key];
    }
    setOptionValue(key, value2) {
      return this.setOptionValueWithSource(key, value2, undefined);
    }
    setOptionValueWithSource(key, value2, source) {
      if (this._storeOptionsAsProperties) {
        this[key] = value2;
      } else {
        this._optionValues[key] = value2;
      }
      this._optionValueSources[key] = source;
      return this;
    }
    getOptionValueSource(key) {
      return this._optionValueSources[key];
    }
    getOptionValueSourceWithGlobals(key) {
      let source;
      this._getCommandAndAncestors().forEach((cmd) => {
        if (cmd.getOptionValueSource(key) !== undefined) {
          source = cmd.getOptionValueSource(key);
        }
      });
      return source;
    }
    _prepareUserArgs(argv, parseOptions) {
      if (argv !== undefined && !Array.isArray(argv)) {
        throw new Error("first parameter to parse must be array or undefined");
      }
      parseOptions = parseOptions || {};
      if (argv === undefined) {
        argv = process2.argv;
        if (process2.versions && process2.versions.electron) {
          parseOptions.from = "electron";
        }
      }
      this.rawArgs = argv.slice();
      let userArgs;
      switch (parseOptions.from) {
        case undefined:
        case "node":
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
          break;
        case "electron":
          if (process2.defaultApp) {
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
          } else {
            userArgs = argv.slice(1);
          }
          break;
        case "user":
          userArgs = argv.slice(0);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
      }
      if (!this._name && this._scriptPath)
        this.nameFromFilename(this._scriptPath);
      this._name = this._name || "program";
      return userArgs;
    }
    parse(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      this._parseCommand([], userArgs);
      return this;
    }
    async parseAsync(argv, parseOptions) {
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      await this._parseCommand([], userArgs);
      return this;
    }
    _executeSubCommand(subcommand, args) {
      args = args.slice();
      let launchWithNode = false;
      const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function findFile(baseDir, baseName) {
        const localBin = path2.resolve(baseDir, baseName);
        if (fs.existsSync(localBin))
          return localBin;
        if (sourceExt.includes(path2.extname(baseName)))
          return;
        const foundExt = sourceExt.find((ext) => fs.existsSync(`${localBin}${ext}`));
        if (foundExt)
          return `${localBin}${foundExt}`;
        return;
      }
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
      let executableDir = this._executableDir || "";
      if (this._scriptPath) {
        let resolvedScriptPath;
        try {
          resolvedScriptPath = fs.realpathSync(this._scriptPath);
        } catch (err) {
          resolvedScriptPath = this._scriptPath;
        }
        executableDir = path2.resolve(path2.dirname(resolvedScriptPath), executableDir);
      }
      if (executableDir) {
        let localFile = findFile(executableDir, executableFile);
        if (!localFile && !subcommand._executableFile && this._scriptPath) {
          const legacyName = path2.basename(this._scriptPath, path2.extname(this._scriptPath));
          if (legacyName !== this._name) {
            localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
          }
        }
        executableFile = localFile || executableFile;
      }
      launchWithNode = sourceExt.includes(path2.extname(executableFile));
      let proc;
      if (process2.platform !== "win32") {
        if (launchWithNode) {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
        } else {
          proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
        }
      } else {
        args.unshift(executableFile);
        args = incrementNodeInspectorPort(process2.execArgv).concat(args);
        proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
      }
      if (!proc.killed) {
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process2.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
      }
      const exitCallback = this._exitCallback;
      proc.on("close", (code, _signal) => {
        code = code ?? 1;
        if (!exitCallback) {
          process2.exit(code);
        } else {
          exitCallback(new CommanderError(code, "commander.executeSubCommandAsync", "(close)"));
        }
      });
      proc.on("error", (err) => {
        if (err.code === "ENOENT") {
          const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
          const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
          throw new Error(executableMissing);
        } else if (err.code === "EACCES") {
          throw new Error(`'${executableFile}' not executable`);
        }
        if (!exitCallback) {
          process2.exit(1);
        } else {
          const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      });
      this.runningCommand = proc;
    }
    _dispatchSubcommand(commandName, operands, unknown) {
      const subCommand = this._findCommand(commandName);
      if (!subCommand)
        this.help({ error: true });
      let promiseChain;
      promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
      promiseChain = this._chainOrCall(promiseChain, () => {
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      });
      return promiseChain;
    }
    _dispatchHelpCommand(subcommandName) {
      if (!subcommandName) {
        this.help();
      }
      const subCommand = this._findCommand(subcommandName);
      if (subCommand && !subCommand._executableHandler) {
        subCommand.help();
      }
      return this._dispatchSubcommand(subcommandName, [], [
        this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"
      ]);
    }
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((arg, i2) => {
        if (arg.required && this.args[i2] == null) {
          this.missingArgument(arg.name());
        }
      });
      if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
        return;
      }
      if (this.args.length > this.registeredArguments.length) {
        this._excessArguments(this.args);
      }
    }
    _processArguments() {
      const myParseArg = (argument, value2, previous) => {
        let parsedValue = value2;
        if (value2 !== null && argument.parseArg) {
          const invalidValueMessage = `error: command-argument value '${value2}' is invalid for argument '${argument.name()}'.`;
          parsedValue = this._callParseArg(argument, value2, previous, invalidValueMessage);
        }
        return parsedValue;
      };
      this._checkNumberOfArguments();
      const processedArgs = [];
      this.registeredArguments.forEach((declaredArg, index) => {
        let value2 = declaredArg.defaultValue;
        if (declaredArg.variadic) {
          if (index < this.args.length) {
            value2 = this.args.slice(index);
            if (declaredArg.parseArg) {
              value2 = value2.reduce((processed, v) => {
                return myParseArg(declaredArg, v, processed);
              }, declaredArg.defaultValue);
            }
          } else if (value2 === undefined) {
            value2 = [];
          }
        } else if (index < this.args.length) {
          value2 = this.args[index];
          if (declaredArg.parseArg) {
            value2 = myParseArg(declaredArg, value2, declaredArg.defaultValue);
          }
        }
        processedArgs[index] = value2;
      });
      this.processedArgs = processedArgs;
    }
    _chainOrCall(promise, fn) {
      if (promise && promise.then && typeof promise.then === "function") {
        return promise.then(() => fn());
      }
      return fn();
    }
    _chainOrCallHooks(promise, event) {
      let result = promise;
      const hooks = [];
      this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
      if (event === "postAction") {
        hooks.reverse();
      }
      hooks.forEach((hookDetail) => {
        result = this._chainOrCall(result, () => {
          return hookDetail.callback(hookDetail.hookedCommand, this);
        });
      });
      return result;
    }
    _chainOrCallSubCommandHook(promise, subCommand, event) {
      let result = promise;
      if (this._lifeCycleHooks[event] !== undefined) {
        this._lifeCycleHooks[event].forEach((hook) => {
          result = this._chainOrCall(result, () => {
            return hook(this, subCommand);
          });
        });
      }
      return result;
    }
    _parseCommand(operands, unknown) {
      const parsed = this.parseOptions(unknown);
      this._parseOptionsEnv();
      this._parseOptionsImplied();
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);
      if (operands && this._findCommand(operands[0])) {
        return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      }
      if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
        return this._dispatchHelpCommand(operands[1]);
      }
      if (this._defaultCommandName) {
        this._outputHelpIfRequested(unknown);
        return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      }
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
        this.help({ error: true });
      }
      this._outputHelpIfRequested(parsed.unknown);
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      const checkForUnknownOptions = () => {
        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }
      };
      const commandEvent = `command:${this.name()}`;
      if (this._actionHandler) {
        checkForUnknownOptions();
        this._processArguments();
        let promiseChain;
        promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
        promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
        if (this.parent) {
          promiseChain = this._chainOrCall(promiseChain, () => {
            this.parent.emit(commandEvent, operands, unknown);
          });
        }
        promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
        return promiseChain;
      }
      if (this.parent && this.parent.listenerCount(commandEvent)) {
        checkForUnknownOptions();
        this._processArguments();
        this.parent.emit(commandEvent, operands, unknown);
      } else if (operands.length) {
        if (this._findCommand("*")) {
          return this._dispatchSubcommand("*", operands, unknown);
        }
        if (this.listenerCount("command:*")) {
          this.emit("command:*", operands, unknown);
        } else if (this.commands.length) {
          this.unknownCommand();
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      } else if (this.commands.length) {
        checkForUnknownOptions();
        this.help({ error: true });
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    }
    _findCommand(name2) {
      if (!name2)
        return;
      return this.commands.find((cmd) => cmd._name === name2 || cmd._aliases.includes(name2));
    }
    _findOption(arg) {
      return this.options.find((option) => option.is(arg));
    }
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd.options.forEach((anOption) => {
          if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      });
    }
    _checkForConflictingLocalOptions() {
      const definedNonDefaultOptions = this.options.filter((option) => {
        const optionKey = option.attributeName();
        if (this.getOptionValue(optionKey) === undefined) {
          return false;
        }
        return this.getOptionValueSource(optionKey) !== "default";
      });
      const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
      optionsWithConflicting.forEach((option) => {
        const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
        if (conflictingAndDefined) {
          this._conflictingOption(option, conflictingAndDefined);
        }
      });
    }
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd._checkForConflictingLocalOptions();
      });
    }
    parseOptions(argv) {
      const operands = [];
      const unknown = [];
      let dest = operands;
      const args = argv.slice();
      function maybeOption(arg) {
        return arg.length > 1 && arg[0] === "-";
      }
      let activeVariadicOption = null;
      while (args.length) {
        const arg = args.shift();
        if (arg === "--") {
          if (dest === unknown)
            dest.push(arg);
          dest.push(...args);
          break;
        }
        if (activeVariadicOption && !maybeOption(arg)) {
          this.emit(`option:${activeVariadicOption.name()}`, arg);
          continue;
        }
        activeVariadicOption = null;
        if (maybeOption(arg)) {
          const option = this._findOption(arg);
          if (option) {
            if (option.required) {
              const value2 = args.shift();
              if (value2 === undefined)
                this.optionMissingArgument(option);
              this.emit(`option:${option.name()}`, value2);
            } else if (option.optional) {
              let value2 = null;
              if (args.length > 0 && !maybeOption(args[0])) {
                value2 = args.shift();
              }
              this.emit(`option:${option.name()}`, value2);
            } else {
              this.emit(`option:${option.name()}`);
            }
            activeVariadicOption = option.variadic ? option : null;
            continue;
          }
        }
        if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
          const option = this._findOption(`-${arg[1]}`);
          if (option) {
            if (option.required || option.optional && this._combineFlagAndOptionalValue) {
              this.emit(`option:${option.name()}`, arg.slice(2));
            } else {
              this.emit(`option:${option.name()}`);
              args.unshift(`-${arg.slice(2)}`);
            }
            continue;
          }
        }
        if (/^--[^=]+=/.test(arg)) {
          const index = arg.indexOf("=");
          const option = this._findOption(arg.slice(0, index));
          if (option && (option.required || option.optional)) {
            this.emit(`option:${option.name()}`, arg.slice(index + 1));
            continue;
          }
        }
        if (maybeOption(arg)) {
          dest = unknown;
        }
        if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
          if (this._findCommand(arg)) {
            operands.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
            operands.push(arg);
            if (args.length > 0)
              operands.push(...args);
            break;
          } else if (this._defaultCommandName) {
            unknown.push(arg);
            if (args.length > 0)
              unknown.push(...args);
            break;
          }
        }
        if (this._passThroughOptions) {
          dest.push(arg);
          if (args.length > 0)
            dest.push(...args);
          break;
        }
        dest.push(arg);
      }
      return { operands, unknown };
    }
    opts() {
      if (this._storeOptionsAsProperties) {
        const result = {};
        const len = this.options.length;
        for (let i2 = 0;i2 < len; i2++) {
          const key = this.options[i2].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }
        return result;
      }
      return this._optionValues;
    }
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
    }
    error(message, errorOptions) {
      this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
      if (typeof this._showHelpAfterError === "string") {
        this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
      } else if (this._showHelpAfterError) {
        this._outputConfiguration.writeErr("\n");
        this.outputHelp({ error: true });
      }
      const config = errorOptions || {};
      const exitCode = config.exitCode || 1;
      const code = config.code || "commander.error";
      this._exit(exitCode, code, message);
    }
    _parseOptionsEnv() {
      this.options.forEach((option) => {
        if (option.envVar && option.envVar in process2.env) {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === undefined || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
            if (option.required || option.optional) {
              this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
            } else {
              this.emit(`optionEnv:${option.name()}`);
            }
          }
        }
      });
    }
    _parseOptionsImplied() {
      const dualHelper = new DualOptions(this.options);
      const hasCustomOptionValue = (optionKey) => {
        return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
      };
      this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
        Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
          this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
        });
      });
    }
    missingArgument(name2) {
      const message = `error: missing required argument '${name2}'`;
      this.error(message, { code: "commander.missingArgument" });
    }
    optionMissingArgument(option) {
      const message = `error: option '${option.flags}' argument missing`;
      this.error(message, { code: "commander.optionMissingArgument" });
    }
    missingMandatoryOptionValue(option) {
      const message = `error: required option '${option.flags}' not specified`;
      this.error(message, { code: "commander.missingMandatoryOptionValue" });
    }
    _conflictingOption(option, conflictingOption) {
      const findBestOptionFromValue = (option2) => {
        const optionKey = option2.attributeName();
        const optionValue = this.getOptionValue(optionKey);
        const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
        const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
        if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
          return negativeOption;
        }
        return positiveOption || option2;
      };
      const getErrorMessage = (option2) => {
        const bestOption = findBestOptionFromValue(option2);
        const optionKey = bestOption.attributeName();
        const source = this.getOptionValueSource(optionKey);
        if (source === "env") {
          return `environment variable '${bestOption.envVar}'`;
        }
        return `option '${bestOption.flags}'`;
      };
      const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
      this.error(message, { code: "commander.conflictingOption" });
    }
    unknownOption(flag) {
      if (this._allowUnknownOption)
        return;
      let suggestion = "";
      if (flag.startsWith("--") && this._showSuggestionAfterError) {
        let candidateFlags = [];
        let command = this;
        do {
          const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
          candidateFlags = candidateFlags.concat(moreFlags);
          command = command.parent;
        } while (command && !command._enablePositionalOptions);
        suggestion = suggestSimilar(flag, candidateFlags);
      }
      const message = `error: unknown option '${flag}'${suggestion}`;
      this.error(message, { code: "commander.unknownOption" });
    }
    _excessArguments(receivedArgs) {
      if (this._allowExcessArguments)
        return;
      const expected = this.registeredArguments.length;
      const s = expected === 1 ? "" : "s";
      const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
      const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
      this.error(message, { code: "commander.excessArguments" });
    }
    unknownCommand() {
      const unknownName = this.args[0];
      let suggestion = "";
      if (this._showSuggestionAfterError) {
        const candidateNames = [];
        this.createHelp().visibleCommands(this).forEach((command) => {
          candidateNames.push(command.name());
          if (command.alias())
            candidateNames.push(command.alias());
        });
        suggestion = suggestSimilar(unknownName, candidateNames);
      }
      const message = `error: unknown command '${unknownName}'${suggestion}`;
      this.error(message, { code: "commander.unknownCommand" });
    }
    version(str, flags, description) {
      if (str === undefined)
        return this._version;
      this._version = str;
      flags = flags || "-V, --version";
      description = description || "output the version number";
      const versionOption = this.createOption(flags, description);
      this._versionOptionName = versionOption.attributeName();
      this._registerOption(versionOption);
      this.on("option:" + versionOption.name(), () => {
        this._outputConfiguration.writeOut(`${str}\n`);
        this._exit(0, "commander.version", str);
      });
      return this;
    }
    description(str, argsDescription) {
      if (str === undefined && argsDescription === undefined)
        return this._description;
      this._description = str;
      if (argsDescription) {
        this._argsDescription = argsDescription;
      }
      return this;
    }
    summary(str) {
      if (str === undefined)
        return this._summary;
      this._summary = str;
      return this;
    }
    alias(alias) {
      if (alias === undefined)
        return this._aliases[0];
      let command = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        command = this.commands[this.commands.length - 1];
      }
      if (alias === command._name)
        throw new Error("Command alias can\'t be the same as its name");
      const matchingCommand = this.parent?._findCommand(alias);
      if (matchingCommand) {
        const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
        throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
      }
      command._aliases.push(alias);
      return this;
    }
    aliases(aliases) {
      if (aliases === undefined)
        return this._aliases;
      aliases.forEach((alias) => this.alias(alias));
      return this;
    }
    usage(str) {
      if (str === undefined) {
        if (this._usage)
          return this._usage;
        const args = this.registeredArguments.map((arg) => {
          return humanReadableArgName(arg);
        });
        return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
      }
      this._usage = str;
      return this;
    }
    name(str) {
      if (str === undefined)
        return this._name;
      this._name = str;
      return this;
    }
    nameFromFilename(filename) {
      this._name = path2.basename(filename, path2.extname(filename));
      return this;
    }
    executableDir(path3) {
      if (path3 === undefined)
        return this._executableDir;
      this._executableDir = path3;
      return this;
    }
    helpInformation(contextOptions) {
      const helper = this.createHelp();
      if (helper.helpWidth === undefined) {
        helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
      }
      return helper.formatHelp(this, helper);
    }
    _getHelpContext(contextOptions) {
      contextOptions = contextOptions || {};
      const context = { error: !!contextOptions.error };
      let write;
      if (context.error) {
        write = (arg) => this._outputConfiguration.writeErr(arg);
      } else {
        write = (arg) => this._outputConfiguration.writeOut(arg);
      }
      context.write = contextOptions.write || write;
      context.command = this;
      return context;
    }
    outputHelp(contextOptions) {
      let deprecatedCallback;
      if (typeof contextOptions === "function") {
        deprecatedCallback = contextOptions;
        contextOptions = undefined;
      }
      const context = this._getHelpContext(contextOptions);
      this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
      this.emit("beforeHelp", context);
      let helpInformation = this.helpInformation(context);
      if (deprecatedCallback) {
        helpInformation = deprecatedCallback(helpInformation);
        if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
      }
      context.write(helpInformation);
      if (this._getHelpOption()?.long) {
        this.emit(this._getHelpOption().long);
      }
      this.emit("afterHelp", context);
      this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", context));
    }
    helpOption(flags, description) {
      if (typeof flags === "boolean") {
        if (flags) {
          this._helpOption = this._helpOption ?? undefined;
        } else {
          this._helpOption = null;
        }
        return this;
      }
      flags = flags ?? "-h, --help";
      description = description ?? "display help for command";
      this._helpOption = this.createOption(flags, description);
      return this;
    }
    _getHelpOption() {
      if (this._helpOption === undefined) {
        this.helpOption(undefined, undefined);
      }
      return this._helpOption;
    }
    addHelpOption(option) {
      this._helpOption = option;
      return this;
    }
    help(contextOptions) {
      this.outputHelp(contextOptions);
      let exitCode = process2.exitCode || 0;
      if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
        exitCode = 1;
      }
      this._exit(exitCode, "commander.help", "(outputHelp)");
    }
    addHelpText(position, text) {
      const allowedValues = ["beforeAll", "before", "after", "afterAll"];
      if (!allowedValues.includes(position)) {
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      const helpEvent = `${position}Help`;
      this.on(helpEvent, (context) => {
        let helpStr;
        if (typeof text === "function") {
          helpStr = text({ error: context.error, command: context.command });
        } else {
          helpStr = text;
        }
        if (helpStr) {
          context.write(`${helpStr}\n`);
        }
      });
      return this;
    }
    _outputHelpIfRequested(args) {
      const helpOption = this._getHelpOption();
      const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
      if (helpRequested) {
        this.outputHelp();
        this._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
  }
  exports.Command = Command;
});

// node_modules/commander/index.js
var require_commander = __commonJS((exports) => {
  var { Argument } = require_argument();
  var { Command } = require_command();
  var { CommanderError, InvalidArgumentError } = require_error();
  var { Help } = require_help();
  var { Option } = require_option();
  exports.program = new Command;
  exports.createCommand = (name2) => new Command(name2);
  exports.createOption = (flags, description) => new Option(flags, description);
  exports.createArgument = (name2, description) => new Argument(name2, description);
  exports.Command = Command;
  exports.Option = Option;
  exports.Argument = Argument;
  exports.Help = Help;
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
  exports.InvalidOptionArgumentError = InvalidArgumentError;
});

// node_modules/async/internal/once.js
var require_once = __commonJS((exports, module) => {
  var once = function(fn) {
    function wrapper(...args) {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = once;
  module.exports = exports["default"];
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  var isArrayLike = function(value2) {
    return value2 && typeof value2.length === "number" && value2.length >= 0 && value2.length % 1 === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isArrayLike;
  module.exports = exports["default"];
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
  };
  module.exports = exports["default"];
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var createArrayIterator = function(coll) {
    var i2 = -1;
    var len = coll.length;
    return function next() {
      return ++i2 < len ? { value: coll[i2], key: i2 } : null;
    };
  };
  var createES2015Iterator = function(iterator) {
    var i2 = -1;
    return function next() {
      var item2 = iterator.next();
      if (item2.done)
        return null;
      i2++;
      return { value: item2.value, key: i2 };
    };
  };
  var createObjectIterator = function(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i2 = -1;
    var len = okeys.length;
    return function next() {
      var key = okeys[++i2];
      if (key === "__proto__") {
        return next();
      }
      return i2 < len ? { value: obj[key], key } : null;
    };
  };
  var createIterator = function(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIterator;
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _getIterator = require_getIterator();
  var _getIterator2 = _interopRequireDefault(_getIterator);
  module.exports = exports["default"];
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS((exports, module) => {
  var onlyOnce = function(fn) {
    return function(...args) {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = onlyOnce;
  module.exports = exports["default"];
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(fn) {
    return function(...args) {
      var callback = args.pop();
      return fn.call(this, args, callback);
    };
  };
  module.exports = exports["default"];
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  var fallback = function(fn) {
    setTimeout(fn, 0);
  };
  var wrap = function(defer) {
    return (fn, ...args) => defer(() => fn(...args));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fallback = fallback;
  exports.wrap = wrap;
  var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
  var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  var _defer;
  if (hasQueueMicrotask) {
    _defer = queueMicrotask;
  } else if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback;
  }
  exports.default = wrap(_defer);
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncify = function(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
      return function(...args) {
        const callback = args.pop();
        const promise = func.apply(this, args);
        return handlePromise(promise, callback);
      };
    }
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e) {
        return callback(e);
      }
      if (result && typeof result.then === "function") {
        return handlePromise(result, callback);
      } else {
        callback(null, result);
      }
    });
  };
  var handlePromise = function(promise, callback) {
    return promise.then((value2) => {
      invokeCallback(callback, null, value2);
    }, (err) => {
      invokeCallback(callback, err && err.message ? err : new Error(err));
    });
  };
  var invokeCallback = function(callback, error, value2) {
    try {
      callback(error, value2);
    } catch (err) {
      (0, _setImmediate2.default)((e) => {
        throw e;
      }, err);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncify;
  var _initialParams = require_initialParams();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  var _wrapAsync = require_wrapAsync();
  module.exports = exports["default"];
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAsync = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
  };
  var isAsyncGenerator = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncGenerator";
  };
  var isAsyncIterable = function(obj) {
    return typeof obj[Symbol.asyncIterator] === "function";
  };
  var wrapAsync = function(asyncFn) {
    if (typeof asyncFn !== "function")
      throw new Error("expected a function");
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;
  var _asyncify = require_asyncify();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  exports.default = wrapAsync;
  exports.isAsync = isAsync;
  exports.isAsyncGenerator = isAsyncGenerator;
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var breakLoop = {};
  exports.default = breakLoop;
  module.exports = exports["default"];
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncEachOfLimit = function(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;
    function replenish() {
      if (running >= limit || awaiting || done)
        return;
      awaiting = true;
      generator.next().then(({ value: value2, done: iterDone }) => {
        if (canceled || done)
          return;
        awaiting = false;
        if (iterDone) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running++;
        iteratee(value2, idx, iterateeCallback);
        idx++;
        replenish();
      }).catch(handleError);
    }
    function iterateeCallback(err, result) {
      running -= 1;
      if (canceled)
        return;
      if (err)
        return handleError(err);
      if (err === false) {
        done = true;
        canceled = true;
        return;
      }
      if (result === _breakLoop2.default || done && running <= 0) {
        done = true;
        return callback(null);
      }
      replenish();
    }
    function handleError(err) {
      if (canceled)
        return;
      awaiting = false;
      done = true;
      callback(err);
    }
    replenish();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncEachOfLimit;
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  module.exports = exports["default"];
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _iterator = require_iterator();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _asyncEachOfLimit = require_asyncEachOfLimit();
  var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  exports.default = (limit) => {
    return (obj, iteratee, callback) => {
      callback = (0, _once2.default)(callback);
      if (limit <= 0) {
        throw new RangeError("concurrency limit cannot be less than 1");
      }
      if (!obj) {
        return callback(null);
      }
      if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
      }
      if ((0, _wrapAsync.isAsyncIterable)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var canceled = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err, value2) {
        if (canceled)
          return;
        running -= 1;
        if (err) {
          done = true;
          callback(err);
        } else if (err === false) {
          done = true;
          canceled = true;
        } else if (value2 === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  module.exports = exports["default"];
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS((exports, module) => {
  var _withoutIndex = function(iteratee) {
    return (value2, index, callback) => iteratee(value2, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _withoutIndex;
  module.exports = exports["default"];
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS((exports, module) => {
  var awaitify = function(asyncFn, arity = asyncFn.length) {
    if (!arity)
      throw new Error("arity is undefined");
    function awaitable(...args) {
      if (typeof args[arity - 1] === "function") {
        return asyncFn.apply(this, args);
      }
      return new Promise((resolve2, reject2) => {
        args[arity - 1] = (err, ...cbArgs) => {
          if (err)
            return reject2(err);
          resolve2(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
        };
        asyncFn.apply(this, args);
      });
    }
    return awaitable;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = awaitify;
  module.exports = exports["default"];
});

// node_modules/async/eachLimit.js
var require_eachLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachLimit, 4);
  module.exports = exports["default"];
});

// node_modules/async/eachSeries.js
var require_eachSeries = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachSeries = function(coll, iteratee, callback) {
    return (0, _eachLimit2.default)(coll, 1, iteratee, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachLimit = require_eachLimit();
  var _eachLimit2 = _interopRequireDefault(_eachLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachSeries, 3);
  module.exports = exports["default"];
});

// node_modules/async/internal/filter.js
var require_filter = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var filterArray = function(eachfn, arr, iteratee, callback) {
    var truthValues = new Array(arr.length);
    eachfn(arr, (x, index, iterCb) => {
      iteratee(x, (err, v) => {
        truthValues[index] = !!v;
        iterCb(err);
      });
    }, (err) => {
      if (err)
        return callback(err);
      var results = [];
      for (var i2 = 0;i2 < arr.length; i2++) {
        if (truthValues[i2])
          results.push(arr[i2]);
      }
      callback(null, results);
    });
  };
  var filterGeneric = function(eachfn, coll, iteratee, callback) {
    var results = [];
    eachfn(coll, (x, index, iterCb) => {
      iteratee(x, (err, v) => {
        if (err)
          return iterCb(err);
        if (v) {
          results.push({ index, value: x });
        }
        iterCb(err);
      });
    }, (err) => {
      if (err)
        return callback(err);
      callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
    });
  };
  var _filter = function(eachfn, coll, iteratee, callback) {
    var filter = (0, _isArrayLike2.default)(coll) ? filterArray : filterGeneric;
    return filter(eachfn, coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _filter;
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  module.exports = exports["default"];
});

// node_modules/async/internal/reject.js
var require_reject = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var reject2 = function(eachfn, arr, _iteratee, callback) {
    const iteratee = (0, _wrapAsync2.default)(_iteratee);
    return (0, _filter2.default)(eachfn, arr, (value2, cb) => {
      iteratee(value2, (err, v) => {
        cb(err, !v);
      });
    }, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = reject2;
  var _filter = require_filter();
  var _filter2 = _interopRequireDefault(_filter);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  module.exports = exports["default"];
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit2 = require_eachOfLimit();
  var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
  module.exports = exports["default"];
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfSeries = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
  module.exports = exports["default"];
});

// node_modules/async/rejectSeries.js
var require_rejectSeries = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rejectSeries = function(coll, iteratee, callback) {
    return (0, _reject3.default)(_eachOfSeries2.default, coll, iteratee, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _reject2 = require_reject();
  var _reject3 = _interopRequireDefault(_reject2);
  var _eachOfSeries = require_eachOfSeries();
  var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(rejectSeries, 3);
  module.exports = exports["default"];
});

// node_modules/mute-stream/mute.js
var require_mute = __commonJS((exports, module) => {
  var MuteStream = function(opts) {
    Stream.apply(this);
    opts = opts || {};
    this.writable = this.readable = true;
    this.muted = false;
    this.on("pipe", this._onpipe);
    this.replace = opts.replace;
    this._prompt = opts.prompt || null;
    this._hadControl = false;
  };
  var onPipe = function(src) {
    this._src = src;
  };
  var getIsTTY = function() {
    return this._dest ? this._dest.isTTY : this._src ? this._src.isTTY : false;
  };
  var setIsTTY = function(isTTY) {
    Object.defineProperty(this, "isTTY", {
      value: isTTY,
      enumerable: true,
      writable: true,
      configurable: true
    });
  };
  var proxy = function(fn) {
    return function() {
      var d = this._dest;
      var s = this._src;
      if (d && d[fn])
        d[fn].apply(d, arguments);
      if (s && s[fn])
        s[fn].apply(s, arguments);
    };
  };
  var Stream = import.meta.require("stream");
  module.exports = MuteStream;
  MuteStream.prototype = Object.create(Stream.prototype);
  Object.defineProperty(MuteStream.prototype, "constructor", {
    value: MuteStream,
    enumerable: false
  });
  MuteStream.prototype.mute = function() {
    this.muted = true;
  };
  MuteStream.prototype.unmute = function() {
    this.muted = false;
  };
  Object.defineProperty(MuteStream.prototype, "_onpipe", {
    value: onPipe,
    enumerable: false,
    writable: true,
    configurable: true
  });
  Object.defineProperty(MuteStream.prototype, "isTTY", {
    get: getIsTTY,
    set: setIsTTY,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MuteStream.prototype, "rows", {
    get: function() {
      return this._dest ? this._dest.rows : this._src ? this._src.rows : undefined;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MuteStream.prototype, "columns", {
    get: function() {
      return this._dest ? this._dest.columns : this._src ? this._src.columns : undefined;
    },
    enumerable: true,
    configurable: true
  });
  MuteStream.prototype.pipe = function(dest, options) {
    this._dest = dest;
    return Stream.prototype.pipe.call(this, dest, options);
  };
  MuteStream.prototype.pause = function() {
    if (this._src)
      return this._src.pause();
  };
  MuteStream.prototype.resume = function() {
    if (this._src)
      return this._src.resume();
  };
  MuteStream.prototype.write = function(c) {
    if (this.muted) {
      if (!this.replace)
        return true;
      if (c.match(/^\u001b/)) {
        if (c.indexOf(this._prompt) === 0) {
          c = c.substr(this._prompt.length);
          c = c.replace(/./g, this.replace);
          c = this._prompt + c;
        }
        this._hadControl = true;
        return this.emit("data", c);
      } else {
        if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
          this._hadControl = false;
          this.emit("data", this._prompt);
          c = c.substr(this._prompt.length);
        }
        c = c.toString().replace(/./g, this.replace);
      }
    }
    this.emit("data", c);
  };
  MuteStream.prototype.end = function(c) {
    if (this.muted) {
      if (c && this.replace) {
        c = c.toString().replace(/./g, this.replace);
      } else {
        c = null;
      }
    }
    if (c)
      this.emit("data", c);
    this.emit("end");
  };
  MuteStream.prototype.destroy = proxy("destroy");
  MuteStream.prototype.destroySoon = proxy("destroySoon");
  MuteStream.prototype.close = proxy("close");
});

// node_modules/read/lib/read.js
var require_read = __commonJS((exports, module) => {
  var read = function(opts, cb) {
    if (opts.num) {
      throw new Error("read() no longer accepts a char number limit");
    }
    if (typeof opts.default !== "undefined" && typeof opts.default !== "string" && typeof opts.default !== "number") {
      throw new Error("default value must be string or number");
    }
    var input = opts.input || process.stdin;
    var output = opts.output || process.stdout;
    var prompt = (opts.prompt || "").trim() + " ";
    var silent = opts.silent;
    var editDef = false;
    var timeout = opts.timeout;
    var def = opts.default || "";
    if (def) {
      if (silent) {
        prompt += "(<default hidden>) ";
      } else if (opts.edit) {
        editDef = true;
      } else {
        prompt += "(" + def + ") ";
      }
    }
    var terminal = !!(opts.terminal || output.isTTY);
    var m = new Mute({ replace: opts.replace, prompt });
    m.pipe(output, { end: false });
    output = m;
    var rlOpts = { input, output, terminal };
    if (process.version.match(/^v0\.6/)) {
      var rl = readline.createInterface(rlOpts.input, rlOpts.output);
    } else {
      var rl = readline.createInterface(rlOpts);
    }
    output.unmute();
    rl.setPrompt(prompt);
    rl.prompt();
    if (silent) {
      output.mute();
    } else if (editDef) {
      rl.line = def;
      rl.cursor = def.length;
      rl._refreshLine();
    }
    var called = false;
    rl.on("line", onLine);
    rl.on("error", onError);
    rl.on("SIGINT", function() {
      rl.close();
      onError(new Error("canceled"));
    });
    var timer;
    if (timeout) {
      timer = setTimeout(function() {
        onError(new Error("timed out"));
      }, timeout);
    }
    function done() {
      called = true;
      rl.close();
      if (process.version.match(/^v0\.6/)) {
        rl.input.removeAllListeners("data");
        rl.input.removeAllListeners("keypress");
        rl.input.pause();
      }
      clearTimeout(timer);
      output.mute();
      output.end();
    }
    function onError(er) {
      if (called)
        return;
      done();
      return cb(er);
    }
    function onLine(line) {
      if (called)
        return;
      if (silent && terminal) {
        output.unmute();
        output.write("\r\n");
      }
      done();
      line = line.replace(/\r?\n$/, "");
      var isDefault = !!(editDef && line === def);
      if (def && !line) {
        isDefault = true;
        line = def;
      }
      cb(null, line, isDefault);
    }
  };
  module.exports = read;
  var readline = import.meta.require("readline");
  var Mute = require_mute();
});

// node_modules/revalidator/lib/revalidator.js
var require_revalidator = __commonJS((exports, module) => {
  (function(exports2) {
    exports2.validate = validate;
    exports2.mixin = mixin;
    function validate(object, schema, options) {
      options = mixin({}, options, validate.defaults);
      var errors = [];
      validateObject(object, schema, options, errors);
      return {
        valid: !errors.length,
        errors
      };
    }
    validate.defaults = {
      validateFormats: true,
      validateFormatsStrict: false,
      validateFormatExtensions: true
    };
    validate.messages = {
      required: "is required",
      allowEmpty: "must not be empty",
      minLength: "is too short (minimum is %{expected} characters)",
      maxLength: "is too long (maximum is %{expected} characters)",
      pattern: "invalid input",
      minimum: "must be greater than or equal to %{expected}",
      maximum: "must be less than or equal to %{expected}",
      exclusiveMinimum: "must be greater than %{expected}",
      exclusiveMaximum: "must be less than %{expected}",
      divisibleBy: "must be divisible by %{expected}",
      minItems: "must contain more than %{expected} items",
      maxItems: "must contain less than %{expected} items",
      uniqueItems: "must hold a unique set of values",
      format: "is not a valid %{expected}",
      conform: "must conform to given constraint",
      type: "must be of %{expected} type"
    };
    validate.messages["enum"] = "must be present in given enumerator";
    validate.formats = {
      email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
      "ip-address": /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/i,
      ipv6: /^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$/,
      "date-time": /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:.\d{1,3})?Z$/,
      date: /^\d{4}-\d{2}-\d{2}$/,
      time: /^\d{2}:\d{2}:\d{2}$/,
      color: /^#[a-z0-9]{6}|#[a-z0-9]{3}|(?:rgb\(\s*(?:[+-]?\d+%?)\s*,\s*(?:[+-]?\d+%?)\s*,\s*(?:[+-]?\d+%?)\s*\))aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow$/i,
      "host-name": /^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])/,
      "utc-millisec": {
        test: function(value2) {
          return typeof value2 === "number" && value2 >= 0;
        }
      },
      regex: {
        test: function(value2) {
          try {
            new RegExp(value2);
          } catch (e) {
            return false;
          }
          return true;
        }
      }
    };
    validate.formatExtensions = {
      url: /^(https?|ftp|git):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
    };
    function mixin(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError("mixin non-object");
        }
        for (var p in source) {
          if (source.hasOwnProperty(p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    }
    function validateObject(object, schema, options, errors) {
      var props, allProps = Object.keys(object), visitedProps = [];
      if (schema.properties) {
        props = schema.properties;
        for (var p in props) {
          if (props.hasOwnProperty(p)) {
            visitedProps.push(p);
            validateProperty(object, object[p], p, props[p], options, errors);
          }
        }
      }
      if (schema.patternProperties) {
        props = schema.patternProperties;
        for (var p in props) {
          if (props.hasOwnProperty(p)) {
            var re = new RegExp(p);
            for (var k in object) {
              if (object.hasOwnProperty(k)) {
                visitedProps.push(k);
                if (re.exec(k) !== null) {
                  validateProperty(object, object[k], p, props[p], options, errors);
                }
              }
            }
          }
        }
      }
      if (schema.additionalProperties !== undefined) {
        var i2, l;
        var unvisitedProps = allProps.filter(function(k2) {
          return visitedProps.indexOf(k2) === -1;
        });
        if (schema.additionalProperties === false && unvisitedProps.length > 0) {
          for (i2 = 0, l = unvisitedProps.length;i2 < l; i2++) {
            error("additionalProperties", unvisitedProps[i2], object[unvisitedProps[i2]], false, errors);
          }
        } else if (typeof schema.additionalProperties == "object" && unvisitedProps.length > 0) {
          for (i2 = 0, l = unvisitedProps.length;i2 < l; i2++) {
            validateProperty(object, object[unvisitedProps[i2]], unvisitedProps[i2], schema.unvisitedProperties, options, errors);
          }
        }
      }
    }
    function validateProperty(object, value2, property, schema, options, errors) {
      var format, valid, spec, type;
      function constrain(name2, value3, assert) {
        if (schema[name2] !== undefined && !assert(value3, schema[name2])) {
          error(name2, property, value3, schema, errors);
        }
      }
      if (value2 === undefined) {
        if (schema.required && schema.type !== "any") {
          return error("required", property, undefined, schema, errors);
        } else {
          return;
        }
      }
      if (options.cast) {
        if ((schema.type === "integer" || schema.type === "number") && value2 == +value2) {
          value2 = +value2;
          object[property] = value2;
        }
        if (schema.type === "boolean") {
          if (value2 === "true" || value2 === "1" || value2 === 1) {
            value2 = true;
            object[property] = value2;
          }
          if (value2 === "false" || value2 === "0" || value2 === 0) {
            value2 = false;
            object[property] = value2;
          }
        }
      }
      if (schema.format && options.validateFormats) {
        format = schema.format;
        if (options.validateFormatExtensions) {
          spec = validate.formatExtensions[format];
        }
        if (!spec) {
          spec = validate.formats[format];
        }
        if (!spec) {
          if (options.validateFormatsStrict) {
            return error("format", property, value2, schema, errors);
          }
        } else {
          if (!spec.test(value2)) {
            return error("format", property, value2, schema, errors);
          }
        }
      }
      if (schema["enum"] && schema["enum"].indexOf(value2) === -1) {
        error("enum", property, value2, schema, errors);
      }
      if (typeof schema.dependencies === "string" && object[schema.dependencies] === undefined) {
        error("dependencies", property, null, schema, errors);
      }
      if (isArray(schema.dependencies)) {
        for (var i2 = 0, l = schema.dependencies.length;i2 < l; i2++) {
          if (object[schema.dependencies[i2]] === undefined) {
            error("dependencies", property, null, schema, errors);
          }
        }
      }
      if (typeof schema.dependencies === "object") {
        validateObject(object, schema.dependencies, options, errors);
      }
      checkType(value2, schema.type, function(err, type2) {
        if (err)
          return error("type", property, typeof value2, schema, errors);
        constrain("conform", value2, function(a, e) {
          return e(a, object);
        });
        switch (type2 || (isArray(value2) ? "array" : typeof value2)) {
          case "string":
            constrain("allowEmpty", value2, function(a, e) {
              return e ? e : a !== "";
            });
            constrain("minLength", value2.length, function(a, e) {
              return a >= e;
            });
            constrain("maxLength", value2.length, function(a, e) {
              return a <= e;
            });
            constrain("pattern", value2, function(a, e) {
              e = typeof e === "string" ? e = new RegExp(e) : e;
              return e.test(a);
            });
            break;
          case "integer":
          case "number":
            constrain("minimum", value2, function(a, e) {
              return a >= e;
            });
            constrain("maximum", value2, function(a, e) {
              return a <= e;
            });
            constrain("exclusiveMinimum", value2, function(a, e) {
              return a > e;
            });
            constrain("exclusiveMaximum", value2, function(a, e) {
              return a < e;
            });
            constrain("divisibleBy", value2, function(a, e) {
              var multiplier = Math.max((a - Math.floor(a)).toString().length - 2, (e - Math.floor(e)).toString().length - 2);
              multiplier = multiplier > 0 ? Math.pow(10, multiplier) : 1;
              return a * multiplier % (e * multiplier) === 0;
            });
            break;
          case "array":
            constrain("items", value2, function(a, e) {
              for (var i3 = 0, l2 = a.length;i3 < l2; i3++) {
                validateProperty(object, a[i3], property, e, options, errors);
              }
              return true;
            });
            constrain("minItems", value2, function(a, e) {
              return a.length >= e;
            });
            constrain("maxItems", value2, function(a, e) {
              return a.length <= e;
            });
            constrain("uniqueItems", value2, function(a) {
              var h = {};
              for (var i3 = 0, l2 = a.length;i3 < l2; i3++) {
                var key = JSON.stringify(a[i3]);
                if (h[key])
                  return false;
                h[key] = true;
              }
              return true;
            });
            break;
          case "object":
            if (schema.properties || schema.patternProperties || schema.additionalProperties) {
              validateObject(value2, schema, options, errors);
            }
            break;
        }
      });
    }
    function checkType(val, type, callback) {
      var result = false, types = isArray(type) ? type : [type];
      if (type === undefined)
        return callback(null, type);
      for (var i2 = 0, l = types.length;i2 < l; i2++) {
        type = types[i2].toLowerCase().trim();
        if (type === "string" ? typeof val === "string" : type === "array" ? isArray(val) : type === "object" ? val && typeof val === "object" && !isArray(val) : type === "number" ? typeof val === "number" : type === "integer" ? typeof val === "number" && ~~val === val : type === "null" ? val === null : type === "boolean" ? typeof val === "boolean" : type === "date" ? isDate(val) : type === "any" ? typeof val !== "undefined" : false) {
          return callback(null, type);
        }
      }
      callback(true);
    }
    function error(attribute, property, actual, schema, errors) {
      var lookup = { expected: schema[attribute], actual, attribute, property };
      var message = schema.messages && schema.messages[attribute] || schema.message || validate.messages[attribute] || "no default message";
      message = message.replace(/%\{([a-z]+)\}/ig, function(_, match) {
        return lookup[match.toLowerCase()] || "";
      });
      errors.push({
        attribute,
        property,
        expected: schema[attribute],
        actual,
        message
      });
    }
    function isArray(value2) {
      var s = typeof value2;
      if (s === "object") {
        if (value2) {
          if (typeof value2.length === "number" && !value2.propertyIsEnumerable("length") && typeof value2.splice === "function") {
            return true;
          }
        }
      }
      return false;
    }
    function isDate(value2) {
      var s = typeof value2;
      if (s === "object") {
        if (value2) {
          if (typeof value2.getTime === "function") {
            return true;
          }
        }
      }
      return false;
    }
  })(typeof module === "object" && module && exports ? exports : window);
});

// node_modules/winston/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "winston",
    description: "A multi-transport async logging library for Node.js",
    version: "2.4.7",
    author: "Charlie Robbins <charlie.robbins@gmail.com>",
    maintainers: [
      "Jarrett Cruger <jcrugzz@gmail.com>",
      "Alberto Pose <albertopose@gmail.com>"
    ],
    repository: {
      type: "git",
      url: "https://github.com/winstonjs/winston.git"
    },
    keywords: [
      "winston",
      "logging",
      "sysadmin",
      "tools"
    ],
    dependencies: {
      async: "^2.6.4",
      colors: "1.0.x",
      cycle: "1.0.x",
      eyes: "0.1.x",
      isstream: "0.1.x",
      "stack-trace": "0.0.x"
    },
    devDependencies: {
      "cross-spawn-async": "^2.0.0",
      hock: "1.x.x",
      "std-mocks": "~1.0.0",
      vows: "0.7.x"
    },
    main: "./lib/winston",
    scripts: {
      test: "vows --dot-matrix --isolate"
    },
    types: "./index.d.ts",
    engines: {
      node: ">= 0.10.0"
    },
    license: "MIT"
  };
});

// node_modules/cycle/cycle.js
var require_cycle = __commonJS((exports, module) => {
  var cycle = exports;
  cycle.decycle = function decycle(object) {
    var objects = [], paths = [];
    return function derez(value2, path2) {
      var i2, name2, nu;
      if (typeof value2 === "object" && value2 !== null && !(value2 instanceof Boolean) && !(value2 instanceof Date) && !(value2 instanceof Number) && !(value2 instanceof RegExp) && !(value2 instanceof String)) {
        for (i2 = 0;i2 < objects.length; i2 += 1) {
          if (objects[i2] === value2) {
            return { $ref: paths[i2] };
          }
        }
        objects.push(value2);
        paths.push(path2);
        if (Object.prototype.toString.apply(value2) === "[object Array]") {
          nu = [];
          for (i2 = 0;i2 < value2.length; i2 += 1) {
            nu[i2] = derez(value2[i2], path2 + "[" + i2 + "]");
          }
        } else {
          nu = {};
          for (name2 in value2) {
            if (Object.prototype.hasOwnProperty.call(value2, name2)) {
              nu[name2] = derez(value2[name2], path2 + "[" + JSON.stringify(name2) + "]");
            }
          }
        }
        return nu;
      }
      return value2;
    }(object, "$");
  };
  cycle.retrocycle = function retrocycle($) {
    var px = /^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;
    (function rez(value) {
      var i, item, name, path;
      if (value && typeof value === "object") {
        if (Object.prototype.toString.apply(value) === "[object Array]") {
          for (i = 0;i < value.length; i += 1) {
            item = value[i];
            if (item && typeof item === "object") {
              path = item.$ref;
              if (typeof path === "string" && px.test(path)) {
                value[i] = eval(path);
              } else {
                rez(item);
              }
            }
          }
        } else {
          for (name in value) {
            if (typeof value[name] === "object") {
              item = value[name];
              if (item) {
                path = item.$ref;
                if (typeof path === "string" && px.test(path)) {
                  value[name] = eval(path);
                } else {
                  rez(item);
                }
              }
            }
          }
        }
      }
    })($);
    return $;
  };
});

// node_modules/colors/lib/styles.js
var require_styles = __commonJS((exports, module) => {
  var styles = {};
  module["exports"] = styles;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports, module) => {
  var argv = process.argv;
  module.exports = function() {
    if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
      return false;
    }
    if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
      return true;
    }
    if (process.stdout && !process.stdout.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return true;
    }
    if ("COLORTERM" in process.env) {
      return true;
    }
    if (false) {
    }
    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test("xterm-256color")) {
      return true;
    }
    return false;
  }();
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c) {
      c = c.toLowerCase();
      var chars = trap[c] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c] !== "undefined") {
        result += trap[c][rand];
      } else {
        result += c;
      }
    });
    return result;
  };
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    }, all = [].concat(soul.up, soul.down, soul.mid), zalgo = {};
    function randomNumber(range) {
      var r = Math.floor(Math.random() * range);
      return r;
    }
    function is_char(character) {
      var bool = false;
      all.filter(function(i2) {
        bool = i2 === character;
      });
      return bool;
    }
    function heComes(text2, options2) {
      var result = "", counts, l;
      options2 = options2 || {};
      options2["up"] = options2["up"] || true;
      options2["mid"] = options2["mid"] || true;
      options2["down"] = options2["down"] || true;
      options2["size"] = options2["size"] || "maxi";
      text2 = text2.split("");
      for (l in text2) {
        if (is_char(l)) {
          continue;
        }
        result = result + text2[l];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options2.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.min = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.min = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d in arr) {
          var index = arr[d];
          for (var i2 = 0;i2 <= counts[index]; i2++) {
            if (options2[index]) {
              result = result + soul[index][randomNumber(soul[index].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text);
  };
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = function() {
    return function(letter, i2, exploded) {
      if (letter === " ")
        return letter;
      switch (i2 % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  }();
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = function(letter, i2, exploded) {
    return i2 % 2 === 0 ? letter : colors.inverse(letter);
  };
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = function() {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i2, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i2++ % rainbowColors.length]](letter);
      }
    };
  }();
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = function() {
    var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
    return function(letter, i2, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
    };
  }();
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  var build = function(_styles) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto;
    return builder;
  };
  var applyStyle = function() {
    var args = arguments;
    var argsLen = args.length;
    var str = argsLen !== 0 && String(arguments[0]);
    if (argsLen > 1) {
      for (var a = 1;a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!colors.enabled || !str) {
      return str;
    }
    var nestedStyles = this._styles;
    var i2 = nestedStyles.length;
    while (i2--) {
      var code = ansiStyles[nestedStyles[i2]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
    }
    return str;
  };
  var applyTheme = function(theme) {
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  var init = function() {
    var ret = {};
    Object.keys(styles).forEach(function(name2) {
      ret[name2] = {
        get: function() {
          return build([name2]);
        }
      };
    });
    return ret;
  };
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var ansiStyles = colors.styles = require_styles();
  var defineProps = Object.defineProperties;
  colors.supportsColor = require_supports_colors();
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor;
  }
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    return ansiStyles[style].open + str + ansiStyles[style].close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  var styles = function() {
    var ret = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto = defineProps(function colors() {
  }, styles);
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      try {
        colors.themes[theme] = import.meta.require(theme);
        applyTheme(colors.themes[theme]);
        return colors.themes[theme];
      } catch (err) {
        console.log(err);
        return err;
      }
    } else {
      applyTheme(theme);
    }
  };
  var sequencer = function sequencer(map2, str) {
    var exploded = str.split(""), i2 = 0;
    exploded = exploded.map(map2);
    return exploded.join("");
  };
  colors.trap = require_trap();
  colors.zalgo = require_zalgo();
  colors.maps = {};
  colors.maps.america = require_america();
  colors.maps.zebra = require_zebra();
  colors.maps.rainbow = require_rainbow();
  colors.maps.random = require_random();
  for (map in colors.maps) {
    (function(map2) {
      colors[map2] = function(str) {
        return sequencer(colors.maps[map2], str);
      };
    })(map);
  }
  var map;
  defineProps(colors, init());
});

// node_modules/colors/safe.js
var require_safe = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = colors;
});

// node_modules/winston/lib/winston/config/cli-config.js
var require_cli_config = __commonJS((exports) => {
  var cliConfig = exports;
  cliConfig.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9
  };
  cliConfig.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta"
  };
});

// node_modules/winston/lib/winston/config/npm-config.js
var require_npm_config = __commonJS((exports) => {
  var npmConfig = exports;
  npmConfig.levels = {
    error: 0,
    warn: 1,
    info: 2,
    verbose: 3,
    debug: 4,
    silly: 5
  };
  npmConfig.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta"
  };
});

// node_modules/winston/lib/winston/config/syslog-config.js
var require_syslog_config = __commonJS((exports) => {
  var syslogConfig = exports;
  syslogConfig.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7
  };
  syslogConfig.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue"
  };
});

// node_modules/winston/lib/winston/config.js
var require_config = __commonJS((exports) => {
  var mixin = function(target) {
    var args = Array.prototype.slice.call(arguments, 1);
    args.forEach(function(a) {
      var keys = Object.keys(a);
      for (var i2 = 0;i2 < keys.length; i2++) {
        target[keys[i2]] = a[keys[i2]];
      }
    });
    return target;
  };
  var colors = require_safe();
  colors.enabled = true;
  var config = exports;
  var allColors = exports.allColors = {};
  config.addColors = function(colors2) {
    mixin(allColors, colors2);
  };
  config.colorize = function(level, message) {
    if (typeof message === "undefined")
      message = level;
    var colorized = message;
    if (allColors[level] instanceof Array) {
      for (var i2 = 0, l = allColors[level].length;i2 < l; ++i2) {
        colorized = colors[allColors[level][i2]](colorized);
      }
    } else if (allColors[level].match(/\s/)) {
      var colorArr = allColors[level].split(/\s+/);
      for (var i2 = 0;i2 < colorArr.length; ++i2) {
        colorized = colors[colorArr[i2]](colorized);
      }
      allColors[level] = colorArr;
    } else {
      colorized = colors[allColors[level]](colorized);
    }
    return colorized;
  };
  config.cli = require_cli_config();
  config.npm = require_npm_config();
  config.syslog = require_syslog_config();
  config.addColors(config.cli.colors);
  config.addColors(config.npm.colors);
  config.addColors(config.syslog.colors);
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS((exports) => {
  var clone = function(obj) {
    var copy = Array.isArray(obj) ? [] : {};
    for (var i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        if (Array.isArray(obj[i2])) {
          copy[i2] = obj[i2].slice(0);
        } else if (obj[i2] instanceof Buffer) {
          copy[i2] = obj[i2].slice(0);
        } else if (typeof obj[i2] != "function") {
          copy[i2] = obj[i2] instanceof Object ? exports.clone(obj[i2]) : obj[i2];
        } else if (typeof obj[i2] === "function") {
          copy[i2] = obj[i2];
        }
      }
    }
    return copy;
  };
  var nop = function() {
  };
  var util = import.meta.require("util");
  var crypto = import.meta.require("crypto");
  var cycle = require_cycle();
  var fs = import.meta.require("fs");
  var StringDecoder = import.meta.require("string_decoder").StringDecoder;
  var Stream = import.meta.require("stream").Stream;
  var config = require_config();
  exports.setLevels = function(target, past, current, isDefault) {
    var self2 = this;
    if (past) {
      Object.keys(past).forEach(function(level) {
        delete target[level];
      });
    }
    target.levels = current || config.npm.levels;
    if (target.padLevels) {
      target.levelLength = exports.longestElement(Object.keys(target.levels));
    }
    Object.keys(target.levels).forEach(function(level) {
      if (level === "log") {
        console.warn('Log level named "log" will clash with the method "log". Consider using a different name.');
        return;
      }
      target[level] = function(msg) {
        var args = [level].concat(Array.prototype.slice.call(arguments));
        target.log.apply(target, args);
      };
    });
    return target;
  };
  exports.longestElement = function(xs) {
    return Math.max.apply(null, xs.map(function(x) {
      return x.length;
    }));
  };
  exports.clone = function(obj) {
    if (obj instanceof Error) {
      var copy = { message: obj.message };
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        copy[key] = obj[key];
      });
      return cycle.decycle(copy);
    } else if (!(obj instanceof Object)) {
      return obj;
    } else if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    return clone(cycle.decycle(obj));
  };
  exports.log = function(options) {
    var timestampFn = typeof options.timestamp === "function" ? options.timestamp : exports.timestamp, timestamp = options.timestamp ? timestampFn() : null, showLevel = options.showLevel === undefined ? true : options.showLevel, meta = options.meta !== null && options.meta !== undefined ? exports.clone(options.meta) : options.meta || null, output;
    if (options.raw) {
      if (typeof meta !== "object" && meta != null) {
        meta = { meta };
      }
      output = exports.clone(meta) || {};
      output.level = options.level;
      output.message = options.message.stripColors ? options.message.stripColors : options.message;
      return JSON.stringify(output);
    }
    if (options.json || options.logstash === true) {
      if (typeof meta !== "object" && meta != null) {
        meta = { meta };
      }
      output = exports.clone(meta) || {};
      output.level = options.level;
      output.message = output.message || "";
      if (options.label) {
        output.label = options.label;
      }
      if (options.message) {
        output.message = options.message;
      }
      if (timestamp) {
        output.timestamp = timestamp;
      }
      if (options.logstash === true) {
        var logstashOutput = {};
        if (output.message !== undefined) {
          logstashOutput["@message"] = output.message;
          delete output.message;
        }
        if (output.timestamp !== undefined) {
          logstashOutput["@timestamp"] = output.timestamp;
          delete output.timestamp;
        }
        logstashOutput["@fields"] = exports.clone(output);
        output = logstashOutput;
      }
      if (typeof options.stringify === "function") {
        return options.stringify(output);
      }
      return JSON.stringify(output, function(key, value2) {
        return value2 instanceof Buffer ? value2.toString("base64") : value2;
      });
    }
    if (typeof options.formatter == "function") {
      options.meta = meta || options.meta;
      if (options.meta instanceof Error) {
        options.meta = exports.clone(options.meta);
      }
      return String(options.formatter(exports.clone(options)));
    }
    output = timestamp ? timestamp + " - " : "";
    if (showLevel) {
      output += options.colorize === "all" || options.colorize === "level" || options.colorize === true ? config.colorize(options.level) : options.level;
    }
    output += options.align ? "\t" : "";
    output += timestamp || showLevel ? ": " : "";
    output += options.label ? "[" + options.label + "] " : "";
    output += options.colorize === "all" || options.colorize === "message" ? config.colorize(options.level, options.message) : options.message;
    if (meta !== null && meta !== undefined) {
      if (typeof meta !== "object") {
        output += " " + meta;
      } else if (Object.keys(meta).length > 0) {
        if (typeof options.prettyPrint === "function") {
          output += " " + options.prettyPrint(meta);
        } else if (options.prettyPrint) {
          output += " \n" + util.inspect(meta, false, options.depth || null, options.colorize);
        } else if (options.humanReadableUnhandledException && Object.keys(meta).length >= 5 && meta.hasOwnProperty("date") && meta.hasOwnProperty("process") && meta.hasOwnProperty("os") && meta.hasOwnProperty("trace") && meta.hasOwnProperty("stack")) {
          var stack = meta.stack;
          delete meta.stack;
          delete meta.trace;
          output += " " + exports.serialize(meta);
          if (stack) {
            output += "\n" + stack.join("\n");
          }
        } else {
          output += " " + exports.serialize(meta);
        }
      }
    }
    return output;
  };
  exports.capitalize = function(str) {
    return str && str[0].toUpperCase() + str.slice(1);
  };
  exports.hash = function(str) {
    return crypto.createHash("sha1").update(str).digest("hex");
  };
  exports.pad = function(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  };
  exports.timestamp = function() {
    return new Date().toISOString();
  };
  exports.serialize = function(obj, key) {
    if (typeof key === "symbol") {
      key = key.toString();
    }
    if (typeof obj === "symbol") {
      obj = obj.toString();
    }
    if (obj === null) {
      obj = "null";
    } else if (obj === undefined) {
      obj = "undefined";
    } else if (obj === false) {
      obj = "false";
    }
    if (typeof obj !== "object") {
      return key ? key + "=" + obj : obj;
    }
    if (obj instanceof Buffer) {
      return key ? key + "=" + obj.toString("base64") : obj.toString("base64");
    }
    var msg = "", keys = Object.keys(obj), length = keys.length;
    for (var i2 = 0;i2 < length; i2++) {
      if (Array.isArray(obj[keys[i2]])) {
        msg += keys[i2] + "=[";
        for (var j = 0, l = obj[keys[i2]].length;j < l; j++) {
          msg += exports.serialize(obj[keys[i2]][j]);
          if (j < l - 1) {
            msg += ", ";
          }
        }
        msg += "]";
      } else if (obj[keys[i2]] instanceof Date) {
        msg += keys[i2] + "=" + obj[keys[i2]];
      } else {
        msg += exports.serialize(obj[keys[i2]], keys[i2]);
      }
      if (i2 < length - 1) {
        msg += ", ";
      }
    }
    return msg;
  };
  exports.tailFile = function(options, callback) {
    var buffer = Buffer.alloc(64 * 1024), decode = new StringDecoder("utf8"), stream2 = new Stream, buff = "", pos = 0, row = 0;
    if (options.start === -1) {
      delete options.start;
    }
    stream2.readable = true;
    stream2.destroy = function() {
      stream2.destroyed = true;
      stream2.emit("end");
      stream2.emit("close");
    };
    fs.open(options.file, "a+", "0644", function(err, fd) {
      if (err) {
        if (!callback) {
          stream2.emit("error", err);
        } else {
          callback(err);
        }
        stream2.destroy();
        return;
      }
      (function read() {
        if (stream2.destroyed) {
          fs.close(fd, nop);
          return;
        }
        return fs.read(fd, buffer, 0, buffer.length, pos, function(err2, bytes) {
          if (err2) {
            if (!callback) {
              stream2.emit("error", err2);
            } else {
              callback(err2);
            }
            stream2.destroy();
            return;
          }
          if (!bytes) {
            if (buff) {
              if (options.start == null || row > options.start) {
                if (!callback) {
                  stream2.emit("line", buff);
                } else {
                  callback(null, buff);
                }
              }
              row++;
              buff = "";
            }
            return setTimeout(read, 1000);
          }
          var data = decode.write(buffer.slice(0, bytes));
          if (!callback) {
            stream2.emit("data", data);
          }
          var data = (buff + data).split(/\n+/), l = data.length - 1, i2 = 0;
          for (;i2 < l; i2++) {
            if (options.start == null || row > options.start) {
              if (!callback) {
                stream2.emit("line", data[i2]);
              } else {
                callback(null, data[i2]);
              }
            }
            row++;
          }
          buff = data[l];
          pos += bytes;
          return read();
        });
      })();
    });
    if (!callback) {
      return stream2;
    }
    return stream2.destroy;
  };
  exports.stringArrayToSet = function(strArray, errMsg) {
    if (typeof errMsg === "undefined") {
      errMsg = "Cannot make set from Array with non-string elements";
    }
    return strArray.reduce(function(set, el) {
      if (!(typeof el === "string" || el instanceof String)) {
        throw new Error(errMsg);
      }
      set[el] = true;
      return set;
    }, Object.create(null));
  };
});

// node_modules/winston/lib/winston/transports/transport.js
var require_transport = __commonJS((exports) => {
  var events = import.meta.require("events");
  var util = import.meta.require("util");
  var Transport = exports.Transport = function(options) {
    events.EventEmitter.call(this);
    options = options || {};
    this.silent = options.silent || false;
    this.raw = options.raw || false;
    this.name = options.name || this.name;
    this.formatter = options.formatter;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions || false;
    this.exceptionsLevel = options.exceptionsLevel || "error";
    this.humanReadableUnhandledException = options.humanReadableUnhandledException || false;
  };
  util.inherits(Transport, events.EventEmitter);
  Transport.prototype.formatQuery = function(query) {
    return query;
  };
  Transport.prototype.normalizeQuery = function(options) {
    options = options || {};
    options.rows = options.rows || options.limit || 10;
    options.start = options.start || 0;
    options.until = options.until || new Date;
    if (typeof options.until !== "object") {
      options.until = new Date(options.until);
    }
    options.from = options.from || options.until - 24 * 60 * 60 * 1000;
    if (typeof options.from !== "object") {
      options.from = new Date(options.from);
    }
    options.order = options.order || "desc";
    options.fields = options.fields;
    return options;
  };
  Transport.prototype.formatResults = function(results, options) {
    return results;
  };
  Transport.prototype.logException = function(msg, meta, callback) {
    var self2 = this, called;
    if (this.silent) {
      return callback();
    }
    function onComplete() {
      if (!called) {
        called = true;
        self2.removeListener("logged", onComplete);
        self2.removeListener("error", onComplete);
        callback();
      }
    }
    this.once("logged", onComplete);
    this.once("error", onComplete);
    this.log(self2.exceptionsLevel, msg, meta, function() {
    });
  };
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS((exports) => {
  var events = import.meta.require("events");
  var os = import.meta.require("os");
  var util = import.meta.require("util");
  var common = require_common();
  var Transport = require_transport().Transport;
  var Console = exports.Console = function(options) {
    Transport.call(this, options);
    options = options || {};
    this.json = options.json || false;
    this.colorize = options.colorize || false;
    this.prettyPrint = options.prettyPrint || false;
    this.timestamp = typeof options.timestamp !== "undefined" ? options.timestamp : false;
    this.showLevel = options.showLevel === undefined ? true : options.showLevel;
    this.label = options.label || null;
    this.logstash = options.logstash || false;
    this.depth = options.depth || null;
    this.align = options.align || false;
    this.stderrLevels = setStderrLevels(options.stderrLevels, options.debugStdout);
    this.eol = options.eol || os.EOL;
    if (this.json) {
      this.stringify = options.stringify || function(obj) {
        return JSON.stringify(obj, null, 2);
      };
    }
    function setStderrLevels(levels, debugStdout) {
      var defaultMsg = "Cannot have non-string elements in stderrLevels Array";
      if (debugStdout) {
        if (levels) {
          throw new Error("Cannot set debugStdout and stderrLevels together");
        }
        return common.stringArrayToSet(["error"], defaultMsg);
      }
      if (!levels) {
        return common.stringArrayToSet(["error", "debug"], defaultMsg);
      } else if (!Array.isArray(levels)) {
        throw new Error("Cannot set stderrLevels to type other than Array");
      }
      return common.stringArrayToSet(levels, defaultMsg);
    }
  };
  util.inherits(Console, Transport);
  Console.prototype.name = "console";
  Console.prototype.log = function(level, msg, meta, callback) {
    if (this.silent) {
      return callback(null, true);
    }
    var self2 = this, output;
    output = common.log({
      colorize: this.colorize,
      json: this.json,
      level,
      message: msg,
      meta,
      stringify: this.stringify,
      timestamp: this.timestamp,
      showLevel: this.showLevel,
      prettyPrint: this.prettyPrint,
      raw: this.raw,
      label: this.label,
      logstash: this.logstash,
      depth: this.depth,
      formatter: this.formatter,
      align: this.align,
      humanReadableUnhandledException: this.humanReadableUnhandledException
    });
    if (this.stderrLevels[level]) {
      process.stderr.write(output + this.eol);
    } else {
      process.stdout.write(output + this.eol);
    }
    self2.emit("logged");
    callback(null, true);
  };
});

// node_modules/winston/node_modules/async/dist/async.js
var require_async = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = global2.async || {});
  })(exports, function(exports2) {
    function slice(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0;idx < newLen; idx++) {
        newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
    }
    var apply = function(fn) {
      var args = slice(arguments, 1);
      return function() {
        var callArgs = slice(arguments);
        return fn.apply(null, args.concat(callArgs));
      };
    };
    var initialParams = function(fn) {
      return function() {
        var args = slice(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
      };
    };
    function isObject(value2) {
      var type = typeof value2;
      return value2 != null && (type == "object" || type == "function");
    }
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return function(fn) {
        var args = slice(arguments, 1);
        defer(function() {
          fn.apply(null, args);
        });
      };
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    var setImmediate$1 = wrap(_defer);
    function asyncify(func) {
      return initialParams(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (isObject(result) && typeof result.then === "function") {
          result.then(function(value2) {
            invokeCallback(callback, null, value2);
          }, function(err) {
            invokeCallback(callback, err.message ? err : new Error(err));
          });
        } else {
          callback(null, result);
        }
      });
    }
    function invokeCallback(callback, error, value2) {
      try {
        callback(error, value2);
      } catch (e) {
        setImmediate$1(rethrow, e);
      }
    }
    function rethrow(error) {
      throw error;
    }
    var supportsSymbol = typeof Symbol === "function";
    function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function applyEach$1(eachfn) {
      return function(fns) {
        var args = slice(arguments, 1);
        var go = initialParams(function(args2, callback) {
          var that = this;
          return eachfn(fns, function(fn, cb) {
            wrapAsync(fn).apply(that, args2.concat(cb));
          }, callback);
        });
        if (args.length) {
          return go.apply(this, args);
        } else {
          return go;
        }
      };
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    function getRawTag(value2) {
      var isOwn = hasOwnProperty.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
      try {
        value2[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag$1] = tag;
        } else {
          delete value2[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$1 = Object.prototype;
    var nativeObjectToString$1 = objectProto$1.toString;
    function objectToString(value2) {
      return nativeObjectToString$1.call(value2);
    }
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === undefined ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value2) {
      if (!isObject(value2)) {
        return false;
      }
      var tag = baseGetTag(value2);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value2) {
      return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value2) {
      return value2 != null && isLength(value2.length) && !isFunction(value2);
    }
    var breakLoop = {};
    function noop() {
    }
    function once(fn) {
      return function() {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
    var getIterator = function(coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    };
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function isObjectLike(value2) {
      return value2 != null && typeof value2 == "object";
    }
    var argsTag = "[object Arguments]";
    function baseIsArguments(value2) {
      return isObjectLike(value2) && baseGetTag(value2) == argsTag;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value2) {
      return isObjectLike(value2) && hasOwnProperty$2.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
    };
    var isArray = Array.isArray;
    function stubFalse() {
      return false;
    }
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : undefined;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
    var isBuffer = nativeIsBuffer || stubFalse;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value2, length) {
      var type = typeof value2;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
    }
    var argsTag$1 = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag$1 = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value2) {
      return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
    }
    function baseUnary(func) {
      return function(value2) {
        return func(value2);
      };
    }
    var freeExports$1 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    function arrayLikeKeys(value2, inherited) {
      var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
      for (var key in value2) {
        if ((inherited || hasOwnProperty$1.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$5 = Object.prototype;
    function isPrototype(value2) {
      var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
      return value2 === proto;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$3.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function createArrayIterator(coll) {
      var i2 = -1;
      var len = coll.length;
      return function next() {
        return ++i2 < len ? { value: coll[i2], key: i2 } : null;
      };
    }
    function createES2015Iterator(iterator2) {
      var i2 = -1;
      return function next() {
        var item2 = iterator2.next();
        if (item2.done)
          return null;
        i2++;
        return { value: item2.value, key: i2 };
      };
    }
    function createObjectIterator(obj) {
      var okeys = keys(obj);
      var i2 = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i2];
        if (key === "__proto__") {
          return next();
        }
        return i2 < len ? { value: obj[key], key } : null;
      };
    }
    function iterator(coll) {
      if (isArrayLike(coll)) {
        return createArrayIterator(coll);
      }
      var iterator2 = getIterator(coll);
      return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function() {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    function _eachOfLimit(limit) {
      return function(obj, iteratee, callback) {
        callback = once(callback || noop);
        if (limit <= 0 || !obj) {
          return callback(null);
        }
        var nextElem = iterator(obj);
        var done = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value2) {
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (value2 === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
    }
    function doLimit(fn, limit) {
      return function(iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
      };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback || noop);
      var index2 = 0, completed = 0, length = coll.length;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value2) {
        if (err) {
          callback(err);
        } else if (++completed === length || value2 === breakLoop) {
          callback(null);
        }
      }
      for (;index2 < length; index2++) {
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
    }
    var eachOfGeneric = doLimit(eachOfLimit, Infinity);
    var eachOf = function(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      eachOfImplementation(coll, wrapAsync(iteratee), callback);
    };
    function doParallel(fn) {
      return function(obj, iteratee, callback) {
        return fn(eachOf, obj, wrapAsync(iteratee), callback);
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      callback = callback || noop;
      arr = arr || [];
      var results = [];
      var counter = 0;
      var _iteratee = wrapAsync(iteratee);
      eachfn(arr, function(value2, _, callback2) {
        var index2 = counter++;
        _iteratee(value2, function(err, v) {
          results[index2] = v;
          callback2(err);
        });
      }, function(err) {
        callback(err, results);
      });
    }
    var map = doParallel(_asyncMap);
    var applyEach = applyEach$1(map);
    function doParallelLimit(fn) {
      return function(obj, limit, iteratee, callback) {
        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
      };
    }
    var mapLimit = doParallelLimit(_asyncMap);
    var mapSeries = doLimit(mapLimit, 1);
    var applyEachSeries = applyEach$1(mapSeries);
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value2) {
      return value2 !== value2;
    }
    function strictIndexOf(array, value2, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value2) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value2, fromIndex) {
      return value2 === value2 ? strictIndexOf(array, value2, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var auto = function(tasks, concurrency, callback) {
      if (typeof concurrency === "function") {
        callback = concurrency;
        concurrency = null;
      }
      callback = once(callback || noop);
      var keys$$1 = keys(tasks);
      var numTasks = keys$$1.length;
      if (!numTasks) {
        return callback(null);
      }
      if (!concurrency) {
        concurrency = numTasks;
      }
      var results = {};
      var runningTasks = 0;
      var hasError = false;
      var listeners = Object.create(null);
      var readyTasks = [];
      var readyToCheck = [];
      var uncheckedDependencies = {};
      baseForOwn(tasks, function(task, key) {
        if (!isArray(task)) {
          enqueueTask(key, [task]);
          readyToCheck.push(key);
          return;
        }
        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
          readyToCheck.push(key);
          return;
        }
        uncheckedDependencies[key] = remainingDependencies;
        arrayEach(dependencies, function(dependencyName) {
          if (!tasks[dependencyName]) {
            throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
          }
          addListener(dependencyName, function() {
            remainingDependencies--;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
            }
          });
        });
      });
      checkForDeadlocks();
      processQueue();
      function enqueueTask(key, task) {
        readyTasks.push(function() {
          runTask(key, task);
        });
      }
      function processQueue() {
        if (readyTasks.length === 0 && runningTasks === 0) {
          return callback(null, results);
        }
        while (readyTasks.length && runningTasks < concurrency) {
          var run = readyTasks.shift();
          run();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
          taskListeners = listeners[taskName] = [];
        }
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function(fn) {
          fn();
        });
        processQueue();
      }
      function runTask(key, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce(function(err, result) {
          runningTasks--;
          if (arguments.length > 2) {
            result = slice(arguments, 1);
          }
          if (err) {
            var safeResults = {};
            baseForOwn(results, function(val, rkey) {
              safeResults[rkey] = val;
            });
            safeResults[key] = result;
            hasError = true;
            listeners = Object.create(null);
            callback(err, safeResults);
          } else {
            results[key] = result;
            taskComplete(key);
          }
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
          taskFn(results, taskCallback);
        } else {
          taskFn(taskCallback);
        }
      }
      function checkForDeadlocks() {
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
          currentTask = readyToCheck.pop();
          counter++;
          arrayEach(getDependents(currentTask), function(dependent) {
            if (--uncheckedDependencies[dependent] === 0) {
              readyToCheck.push(dependent);
            }
          });
        }
        if (counter !== numTasks) {
          throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
      }
      function getDependents(taskName) {
        var result = [];
        baseForOwn(tasks, function(task, key) {
          if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
            result.push(key);
          }
        });
        return result;
      }
    };
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
    }
    var INFINITY = 1 / 0;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
    var symbolToString = symbolProto ? symbolProto.toString : undefined;
    function baseToString(value2) {
      if (typeof value2 == "string") {
        return value2;
      }
      if (isArray(value2)) {
        return arrayMap(value2, baseToString) + "";
      }
      if (isSymbol(value2)) {
        return symbolToString ? symbolToString.call(value2) : "";
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
    }
    function baseSlice(array, start, end) {
      var index2 = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array[index2 + start];
      }
      return result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    var rsAstralRange$1 = "\\ud800-\\udfff";
    var rsComboMarksRange$1 = "\\u0300-\\u036f";
    var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
    var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
    var rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange$1 + "]";
    var rsCombo = "[" + rsComboRange$1 + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange$1 + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ$1 = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange$1 + "]?";
    var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function toString(value2) {
      return value2 == null ? "" : baseToString(value2);
    }
    var reTrim = /^\s+|\s+$/g;
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, "");
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
      return castSlice(strSymbols, start, end).join("");
    }
    var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    function parseParams(func) {
      func = func.toString().replace(STRIP_COMMENTS, "");
      func = func.match(FN_ARGS)[2].replace(" ", "");
      func = func ? func.split(FN_ARG_SPLIT) : [];
      func = func.map(function(arg) {
        return trim(arg.replace(FN_ARG, ""));
      });
      return func;
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      baseForOwn(tasks, function(taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (isArray(taskFn)) {
          params = taskFn.slice(0, -1);
          taskFn = taskFn[taskFn.length - 1];
          newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
          newTasks[key] = taskFn;
        } else {
          params = parseParams(taskFn);
          if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
            throw new Error("autoInject task functions require explicit parameters.");
          }
          if (!fnIsAsync)
            params.pop();
          newTasks[key] = params.concat(newTask);
        }
        function newTask(results, taskCb) {
          var newArgs = arrayMap(params, function(name2) {
            return results[name2];
          });
          newArgs.push(taskCb);
          wrapAsync(taskFn).apply(null, newArgs);
        }
      });
      auto(newTasks, callback);
    }
    function DLL() {
      this.head = this.tail = null;
      this.length = 0;
    }
    function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
    }
    DLL.prototype.removeLink = function(node) {
      if (node.prev)
        node.prev.next = node.next;
      else
        this.head = node.next;
      if (node.next)
        node.next.prev = node.prev;
      else
        this.tail = node.prev;
      node.prev = node.next = null;
      this.length -= 1;
      return node;
    };
    DLL.prototype.empty = function() {
      while (this.head)
        this.shift();
      return this;
    };
    DLL.prototype.insertAfter = function(node, newNode) {
      newNode.prev = node;
      newNode.next = node.next;
      if (node.next)
        node.next.prev = newNode;
      else
        this.tail = newNode;
      node.next = newNode;
      this.length += 1;
    };
    DLL.prototype.insertBefore = function(node, newNode) {
      newNode.prev = node.prev;
      newNode.next = node;
      if (node.prev)
        node.prev.next = newNode;
      else
        this.head = newNode;
      node.prev = newNode;
      this.length += 1;
    };
    DLL.prototype.unshift = function(node) {
      if (this.head)
        this.insertBefore(this.head, node);
      else
        setInitial(this, node);
    };
    DLL.prototype.push = function(node) {
      if (this.tail)
        this.insertAfter(this.tail, node);
      else
        setInitial(this, node);
    };
    DLL.prototype.shift = function() {
      return this.head && this.removeLink(this.head);
    };
    DLL.prototype.pop = function() {
      return this.tail && this.removeLink(this.tail);
    };
    DLL.prototype.toArray = function() {
      var arr = Array(this.length);
      var curr = this.head;
      for (var idx = 0;idx < this.length; idx++) {
        arr[idx] = curr.data;
        curr = curr.next;
      }
      return arr;
    };
    DLL.prototype.remove = function(testFn) {
      var curr = this.head;
      while (curr) {
        var next = curr.next;
        if (testFn(curr)) {
          this.removeLink(curr);
        }
        curr = next;
      }
      return this;
    };
    function queue(worker, concurrency, payload) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new Error("Concurrency must not be zero");
      }
      var _worker = wrapAsync(worker);
      var numRunning = 0;
      var workersList = [];
      var processingScheduled = false;
      function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        if (!isArray(data)) {
          data = [data];
        }
        if (data.length === 0 && q.idle()) {
          return setImmediate$1(function() {
            q.drain();
          });
        }
        for (var i2 = 0, l = data.length;i2 < l; i2++) {
          var item2 = {
            data: data[i2],
            callback: callback || noop
          };
          if (insertAtFront) {
            q._tasks.unshift(item2);
          } else {
            q._tasks.push(item2);
          }
        }
        if (!processingScheduled) {
          processingScheduled = true;
          setImmediate$1(function() {
            processingScheduled = false;
            q.process();
          });
        }
      }
      function _next(tasks) {
        return function(err) {
          numRunning -= 1;
          for (var i2 = 0, l = tasks.length;i2 < l; i2++) {
            var task = tasks[i2];
            var index2 = baseIndexOf(workersList, task, 0);
            if (index2 === 0) {
              workersList.shift();
            } else if (index2 > 0) {
              workersList.splice(index2, 1);
            }
            task.callback.apply(task, arguments);
            if (err != null) {
              q.error(err, task.data);
            }
          }
          if (numRunning <= q.concurrency - q.buffer) {
            q.unsaturated();
          }
          if (q.idle()) {
            q.drain();
          }
          q.process();
        };
      }
      var isProcessing = false;
      var q = {
        _tasks: new DLL,
        concurrency,
        payload,
        saturated: noop,
        unsaturated: noop,
        buffer: concurrency / 4,
        empty: noop,
        drain: noop,
        error: noop,
        started: false,
        paused: false,
        push: function(data, callback) {
          _insert(data, false, callback);
        },
        kill: function() {
          q.drain = noop;
          q._tasks.empty();
        },
        unshift: function(data, callback) {
          _insert(data, true, callback);
        },
        remove: function(testFn) {
          q._tasks.remove(testFn);
        },
        process: function() {
          if (isProcessing) {
            return;
          }
          isProcessing = true;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [];
            var l = q._tasks.length;
            if (q.payload)
              l = Math.min(l, q.payload);
            for (var i2 = 0;i2 < l; i2++) {
              var node = q._tasks.shift();
              tasks.push(node);
              workersList.push(node);
              data.push(node.data);
            }
            numRunning += 1;
            if (q._tasks.length === 0) {
              q.empty();
            }
            if (numRunning === q.concurrency) {
              q.saturated();
            }
            var cb = onlyOnce(_next(tasks));
            _worker(data, cb);
          }
          isProcessing = false;
        },
        length: function() {
          return q._tasks.length;
        },
        running: function() {
          return numRunning;
        },
        workersList: function() {
          return workersList;
        },
        idle: function() {
          return q._tasks.length + numRunning === 0;
        },
        pause: function() {
          q.paused = true;
        },
        resume: function() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          setImmediate$1(q.process);
        }
      };
      return q;
    }
    function cargo(worker, payload) {
      return queue(worker, 1, payload);
    }
    var eachOfSeries = doLimit(eachOfLimit, 1);
    function reduce(coll, memo, iteratee, callback) {
      callback = once(callback || noop);
      var _iteratee = wrapAsync(iteratee);
      eachOfSeries(coll, function(x, i2, callback2) {
        _iteratee(memo, x, function(err, v) {
          memo = v;
          callback2(err);
        });
      }, function(err) {
        callback(err, memo);
      });
    }
    function seq() {
      var _functions = arrayMap(arguments, wrapAsync);
      return function() {
        var args = slice(arguments);
        var that = this;
        var cb = args[args.length - 1];
        if (typeof cb == "function") {
          args.pop();
        } else {
          cb = noop;
        }
        reduce(_functions, args, function(newargs, fn, cb2) {
          fn.apply(that, newargs.concat(function(err) {
            var nextargs = slice(arguments, 1);
            cb2(err, nextargs);
          }));
        }, function(err, results) {
          cb.apply(that, [err].concat(results));
        });
      };
    }
    var compose = function() {
      return seq.apply(null, slice(arguments).reverse());
    };
    var _concat = Array.prototype.concat;
    var concatLimit = function(coll, limit, iteratee, callback) {
      callback = callback || noop;
      var _iteratee = wrapAsync(iteratee);
      mapLimit(coll, limit, function(val, callback2) {
        _iteratee(val, function(err) {
          if (err)
            return callback2(err);
          return callback2(null, slice(arguments, 1));
        });
      }, function(err, mapResults) {
        var result = [];
        for (var i2 = 0;i2 < mapResults.length; i2++) {
          if (mapResults[i2]) {
            result = _concat.apply(result, mapResults[i2]);
          }
        }
        return callback(err, result);
      });
    };
    var concat = doLimit(concatLimit, Infinity);
    var concatSeries = doLimit(concatLimit, 1);
    var constant = function() {
      var values = slice(arguments);
      var args = [null].concat(values);
      return function() {
        var callback = arguments[arguments.length - 1];
        return callback.apply(this, args);
      };
    };
    function identity(value2) {
      return value2;
    }
    function _createTester(check, getResult) {
      return function(eachfn, arr, iteratee, cb) {
        cb = cb || noop;
        var testPassed = false;
        var testResult;
        eachfn(arr, function(value2, _, callback) {
          iteratee(value2, function(err, result) {
            if (err) {
              callback(err);
            } else if (check(result) && !testResult) {
              testPassed = true;
              testResult = getResult(true, value2);
              callback(null, breakLoop);
            } else {
              callback();
            }
          });
        }, function(err) {
          if (err) {
            cb(err);
          } else {
            cb(null, testPassed ? testResult : getResult(false));
          }
        });
      };
    }
    function _findGetResult(v, x) {
      return x;
    }
    var detect = doParallel(_createTester(identity, _findGetResult));
    var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));
    var detectSeries = doLimit(detectLimit, 1);
    function consoleFunc(name2) {
      return function(fn) {
        var args = slice(arguments, 1);
        args.push(function(err) {
          var args2 = slice(arguments, 1);
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name2]) {
              arrayEach(args2, function(x) {
                console[name2](x);
              });
            }
          }
        });
        wrapAsync(fn).apply(null, args);
      };
    }
    var dir = consoleFunc("dir");
    function doDuring(fn, test, callback) {
      callback = onlyOnce(callback || noop);
      var _fn = wrapAsync(fn);
      var _test = wrapAsync(test);
      function next(err) {
        if (err)
          return callback(err);
        var args = slice(arguments, 1);
        args.push(check);
        _test.apply(this, args);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (!truth)
          return callback(null);
        _fn(next);
      }
      check(null, true);
    }
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback || noop);
      var _iteratee = wrapAsync(iteratee);
      var next = function(err) {
        if (err)
          return callback(err);
        var args = slice(arguments, 1);
        if (test.apply(this, args))
          return _iteratee(next);
        callback.apply(null, [null].concat(args));
      };
      _iteratee(next);
    }
    function doUntil(iteratee, test, callback) {
      doWhilst(iteratee, function() {
        return !test.apply(this, arguments);
      }, callback);
    }
    function during(test, fn, callback) {
      callback = onlyOnce(callback || noop);
      var _fn = wrapAsync(fn);
      var _test = wrapAsync(test);
      function next(err) {
        if (err)
          return callback(err);
        _test(check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (!truth)
          return callback(null);
        _fn(next);
      }
      _test(check);
    }
    function _withoutIndex(iteratee) {
      return function(value2, index2, callback) {
        return iteratee(value2, callback);
      };
    }
    function eachLimit(coll, iteratee, callback) {
      eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    function eachLimit$1(coll, limit, iteratee, callback) {
      _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachSeries = doLimit(eachLimit$1, 1);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return initialParams(function(args, callback) {
        var sync = true;
        args.push(function() {
          var innerArgs = arguments;
          if (sync) {
            setImmediate$1(function() {
              callback.apply(null, innerArgs);
            });
          } else {
            callback.apply(null, innerArgs);
          }
        });
        fn.apply(this, args);
        sync = false;
      });
    }
    function notId(v) {
      return !v;
    }
    var every = doParallel(_createTester(notId, notId));
    var everyLimit = doParallelLimit(_createTester(notId, notId));
    var everySeries = doLimit(everyLimit, 1);
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, function(x, index2, callback2) {
        iteratee(x, function(err, v) {
          truthValues[index2] = !!v;
          callback2(err);
        });
      }, function(err) {
        if (err)
          return callback(err);
        var results = [];
        for (var i2 = 0;i2 < arr.length; i2++) {
          if (truthValues[i2])
            results.push(arr[i2]);
        }
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, function(x, index2, callback2) {
        iteratee(x, function(err, v) {
          if (err) {
            callback2(err);
          } else {
            if (v) {
              results.push({ index: index2, value: x });
            }
            callback2();
          }
        });
      }, function(err) {
        if (err) {
          callback(err);
        } else {
          callback(null, arrayMap(results.sort(function(a, b) {
            return a.index - b.index;
          }), baseProperty("value")));
        }
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
      filter2(eachfn, coll, wrapAsync(iteratee), callback || noop);
    }
    var filter = doParallel(_filter);
    var filterLimit = doParallelLimit(_filter);
    var filterSeries = doLimit(filterLimit, 1);
    function forever(fn, errback) {
      var done = onlyOnce(errback || noop);
      var task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        task(next);
      }
      next();
    }
    var groupByLimit = function(coll, limit, iteratee, callback) {
      callback = callback || noop;
      var _iteratee = wrapAsync(iteratee);
      mapLimit(coll, limit, function(val, callback2) {
        _iteratee(val, function(err, key) {
          if (err)
            return callback2(err);
          return callback2(null, { key, val });
        });
      }, function(err, mapResults) {
        var result = {};
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        for (var i2 = 0;i2 < mapResults.length; i2++) {
          if (mapResults[i2]) {
            var key = mapResults[i2].key;
            var val = mapResults[i2].val;
            if (hasOwnProperty2.call(result, key)) {
              result[key].push(val);
            } else {
              result[key] = [val];
            }
          }
        }
        return callback(err, result);
      });
    };
    var groupBy = doLimit(groupByLimit, Infinity);
    var groupBySeries = doLimit(groupByLimit, 1);
    var log = consoleFunc("log");
    function mapValuesLimit(obj, limit, iteratee, callback) {
      callback = once(callback || noop);
      var newObj = {};
      var _iteratee = wrapAsync(iteratee);
      eachOfLimit(obj, limit, function(val, key, next) {
        _iteratee(val, key, function(err, result) {
          if (err)
            return next(err);
          newObj[key] = result;
          next();
        });
      }, function(err) {
        callback(err, newObj);
      });
    }
    var mapValues = doLimit(mapValuesLimit, Infinity);
    var mapValuesSeries = doLimit(mapValuesLimit, 1);
    function has(obj, key) {
      return key in obj;
    }
    function memoize(fn, hasher) {
      var memo = Object.create(null);
      var queues = Object.create(null);
      hasher = hasher || identity;
      var _fn = wrapAsync(fn);
      var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
          setImmediate$1(function() {
            callback.apply(null, memo[key]);
          });
        } else if (has(queues, key)) {
          queues[key].push(callback);
        } else {
          queues[key] = [callback];
          _fn.apply(null, args.concat(function() {
            var args2 = slice(arguments);
            memo[key] = args2;
            var q = queues[key];
            delete queues[key];
            for (var i2 = 0, l = q.length;i2 < l; i2++) {
              q[i2].apply(null, args2);
            }
          }));
        }
      });
      memoized.memo = memo;
      memoized.unmemoized = fn;
      return memoized;
    }
    var _defer$1;
    if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else {
      _defer$1 = fallback;
    }
    var nextTick = wrap(_defer$1);
    function _parallel(eachfn, tasks, callback) {
      callback = callback || noop;
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, function(task, key, callback2) {
        wrapAsync(task)(function(err, result) {
          if (arguments.length > 2) {
            result = slice(arguments, 1);
          }
          results[key] = result;
          callback2(err);
        });
      }, function(err) {
        callback(err, results);
      });
    }
    function parallelLimit(tasks, callback) {
      _parallel(eachOf, tasks, callback);
    }
    function parallelLimit$1(tasks, limit, callback) {
      _parallel(_eachOfLimit(limit), tasks, callback);
    }
    var queue$1 = function(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue(function(items, cb) {
        _worker(items[0], cb);
      }, concurrency, 1);
    };
    var priorityQueue = function(worker, concurrency) {
      var q = queue$1(worker, concurrency);
      q.push = function(data, priority, callback) {
        if (callback == null)
          callback = noop;
        if (typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        if (!isArray(data)) {
          data = [data];
        }
        if (data.length === 0) {
          return setImmediate$1(function() {
            q.drain();
          });
        }
        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode && priority >= nextNode.priority) {
          nextNode = nextNode.next;
        }
        for (var i2 = 0, l = data.length;i2 < l; i2++) {
          var item2 = {
            data: data[i2],
            priority,
            callback
          };
          if (nextNode) {
            q._tasks.insertBefore(nextNode, item2);
          } else {
            q._tasks.push(item2);
          }
        }
        setImmediate$1(q.process);
      };
      delete q.unshift;
      return q;
    };
    function race(tasks, callback) {
      callback = once(callback || noop);
      if (!isArray(tasks))
        return callback(new TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i2 = 0, l = tasks.length;i2 < l; i2++) {
        wrapAsync(tasks[i2])(callback);
      }
    }
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = slice(array).reverse();
      reduce(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function reflectOn(args, reflectCallback) {
        args.push(function callback(error, cbArg) {
          if (error) {
            reflectCallback(null, { error });
          } else {
            var value2;
            if (arguments.length <= 2) {
              value2 = cbArg;
            } else {
              value2 = slice(arguments, 1);
            }
            reflectCallback(null, { value: value2 });
          }
        });
        return _fn.apply(this, args);
      });
    }
    function reflectAll(tasks) {
      var results;
      if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
      } else {
        results = {};
        baseForOwn(tasks, function(task, key) {
          results[key] = reflect.call(this, task);
        });
      }
      return results;
    }
    function reject$1(eachfn, arr, iteratee, callback) {
      _filter(eachfn, arr, function(value2, cb) {
        iteratee(value2, function(err, v) {
          cb(err, !v);
        });
      }, callback);
    }
    var reject2 = doParallel(reject$1);
    var rejectLimit = doParallelLimit(reject$1);
    var rejectSeries = doLimit(rejectLimit, 1);
    function constant$1(value2) {
      return function() {
        return value2;
      };
    }
    function retry(opts, task, callback) {
      var DEFAULT_TIMES = 5;
      var DEFAULT_INTERVAL = 0;
      var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
      };
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      if (arguments.length < 3 && typeof opts === "function") {
        callback = task || noop;
        task = opts;
      } else {
        parseTimes(options, opts);
        callback = callback || noop;
      }
      if (typeof task !== "function") {
        throw new Error("Invalid arguments for async.retry");
      }
      var _task = wrapAsync(task);
      var attempt = 1;
      function retryAttempt() {
        _task(function(err) {
          if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
            setTimeout(retryAttempt, options.intervalFunc(attempt));
          } else {
            callback.apply(null, arguments);
          }
        });
      }
      retryAttempt();
    }
    var retryable = function(opts, task) {
      if (!task) {
        task = opts;
        opts = null;
      }
      var _task = wrapAsync(task);
      return initialParams(function(args, callback) {
        function taskFn(cb) {
          _task.apply(null, args.concat(cb));
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
      });
    };
    function series(tasks, callback) {
      _parallel(eachOfSeries, tasks, callback);
    }
    var some = doParallel(_createTester(Boolean, identity));
    var someLimit = doParallelLimit(_createTester(Boolean, identity));
    var someSeries = doLimit(someLimit, 1);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      map(coll, function(x, callback2) {
        _iteratee(x, function(err, criteria) {
          if (err)
            return callback2(err);
          callback2(null, { value: x, criteria });
        });
      }, function(err, results) {
        if (err)
          return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams(function(args, callback) {
        var timedOut = false;
        var timer;
        function timeoutCallback() {
          var name2 = asyncFn.name || "anonymous";
          var error = new Error('Callback function "' + name2 + '" timed out.');
          error.code = "ETIMEDOUT";
          if (info) {
            error.info = info;
          }
          timedOut = true;
          callback(error);
        }
        args.push(function() {
          if (!timedOut) {
            callback.apply(null, arguments);
            clearTimeout(timer);
          }
        });
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
      });
    }
    var nativeCeil = Math.ceil;
    var nativeMax = Math.max;
    function baseRange(start, end, step, fromRight) {
      var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
      while (length--) {
        result[fromRight ? length : ++index2] = start;
        start += step;
      }
      return result;
    }
    function timeLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
    }
    var times = doLimit(timeLimit, Infinity);
    var timesSeries = doLimit(timeLimit, 1);
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
      }
      callback = once(callback || noop);
      var _iteratee = wrapAsync(iteratee);
      eachOf(coll, function(v, k, cb) {
        _iteratee(accumulator, v, k, cb);
      }, function(err) {
        callback(err, accumulator);
      });
    }
    function tryEach(tasks, callback) {
      var error = null;
      var result;
      callback = callback || noop;
      eachSeries(tasks, function(task, callback2) {
        wrapAsync(task)(function(err, res) {
          if (arguments.length > 2) {
            result = slice(arguments, 1);
          } else {
            result = res;
          }
          error = err;
          callback2(!err);
        });
      }, function() {
        callback(error, result);
      });
    }
    function unmemoize(fn) {
      return function() {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback || noop);
      var _iteratee = wrapAsync(iteratee);
      if (!test())
        return callback(null);
      var next = function(err) {
        if (err)
          return callback(err);
        if (test())
          return _iteratee(next);
        var args = slice(arguments, 1);
        callback.apply(null, [null].concat(args));
      };
      _iteratee(next);
    }
    function until(test, iteratee, callback) {
      whilst(function() {
        return !test.apply(this, arguments);
      }, iteratee, callback);
    }
    var waterfall = function(tasks, callback) {
      callback = once(callback || noop);
      if (!isArray(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        args.push(onlyOnce(next));
        task.apply(null, args);
      }
      function next(err) {
        if (err || taskIndex === tasks.length) {
          return callback.apply(null, arguments);
        }
        nextTask(slice(arguments, 1));
      }
      nextTask([]);
    };
    var index = {
      apply,
      applyEach,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo,
      compose,
      concat,
      concatLimit,
      concatSeries,
      constant,
      detect,
      detectLimit,
      detectSeries,
      dir,
      doDuring,
      doUntil,
      doWhilst,
      during,
      each: eachLimit,
      eachLimit: eachLimit$1,
      eachOf,
      eachOfLimit,
      eachOfSeries,
      eachSeries,
      ensureAsync,
      every,
      everyLimit,
      everySeries,
      filter,
      filterLimit,
      filterSeries,
      forever,
      groupBy,
      groupByLimit,
      groupBySeries,
      log,
      map,
      mapLimit,
      mapSeries,
      mapValues,
      mapValuesLimit,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel: parallelLimit,
      parallelLimit: parallelLimit$1,
      priorityQueue,
      queue: queue$1,
      race,
      reduce,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject2,
      rejectLimit,
      rejectSeries,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some,
      someLimit,
      someSeries,
      sortBy,
      timeout,
      times,
      timesLimit: timeLimit,
      timesSeries,
      transform,
      tryEach,
      unmemoize,
      until,
      waterfall,
      whilst,
      all: every,
      allLimit: everyLimit,
      allSeries: everySeries,
      any: some,
      anyLimit: someLimit,
      anySeries: someSeries,
      find: detect,
      findLimit: detectLimit,
      findSeries: detectSeries,
      forEach: eachLimit,
      forEachSeries: eachSeries,
      forEachLimit: eachLimit$1,
      forEachOf: eachOf,
      forEachOfSeries: eachOfSeries,
      forEachOfLimit: eachOfLimit,
      inject: reduce,
      foldl: reduce,
      foldr: reduceRight,
      select: filter,
      selectLimit: filterLimit,
      selectSeries: filterSeries,
      wrapSync: asyncify
    };
    exports2["default"] = index;
    exports2.apply = apply;
    exports2.applyEach = applyEach;
    exports2.applyEachSeries = applyEachSeries;
    exports2.asyncify = asyncify;
    exports2.auto = auto;
    exports2.autoInject = autoInject;
    exports2.cargo = cargo;
    exports2.compose = compose;
    exports2.concat = concat;
    exports2.concatLimit = concatLimit;
    exports2.concatSeries = concatSeries;
    exports2.constant = constant;
    exports2.detect = detect;
    exports2.detectLimit = detectLimit;
    exports2.detectSeries = detectSeries;
    exports2.dir = dir;
    exports2.doDuring = doDuring;
    exports2.doUntil = doUntil;
    exports2.doWhilst = doWhilst;
    exports2.during = during;
    exports2.each = eachLimit;
    exports2.eachLimit = eachLimit$1;
    exports2.eachOf = eachOf;
    exports2.eachOfLimit = eachOfLimit;
    exports2.eachOfSeries = eachOfSeries;
    exports2.eachSeries = eachSeries;
    exports2.ensureAsync = ensureAsync;
    exports2.every = every;
    exports2.everyLimit = everyLimit;
    exports2.everySeries = everySeries;
    exports2.filter = filter;
    exports2.filterLimit = filterLimit;
    exports2.filterSeries = filterSeries;
    exports2.forever = forever;
    exports2.groupBy = groupBy;
    exports2.groupByLimit = groupByLimit;
    exports2.groupBySeries = groupBySeries;
    exports2.log = log;
    exports2.map = map;
    exports2.mapLimit = mapLimit;
    exports2.mapSeries = mapSeries;
    exports2.mapValues = mapValues;
    exports2.mapValuesLimit = mapValuesLimit;
    exports2.mapValuesSeries = mapValuesSeries;
    exports2.memoize = memoize;
    exports2.nextTick = nextTick;
    exports2.parallel = parallelLimit;
    exports2.parallelLimit = parallelLimit$1;
    exports2.priorityQueue = priorityQueue;
    exports2.queue = queue$1;
    exports2.race = race;
    exports2.reduce = reduce;
    exports2.reduceRight = reduceRight;
    exports2.reflect = reflect;
    exports2.reflectAll = reflectAll;
    exports2.reject = reject2;
    exports2.rejectLimit = rejectLimit;
    exports2.rejectSeries = rejectSeries;
    exports2.retry = retry;
    exports2.retryable = retryable;
    exports2.seq = seq;
    exports2.series = series;
    exports2.setImmediate = setImmediate$1;
    exports2.some = some;
    exports2.someLimit = someLimit;
    exports2.someSeries = someSeries;
    exports2.sortBy = sortBy;
    exports2.timeout = timeout;
    exports2.times = times;
    exports2.timesLimit = timeLimit;
    exports2.timesSeries = timesSeries;
    exports2.transform = transform;
    exports2.tryEach = tryEach;
    exports2.unmemoize = unmemoize;
    exports2.until = until;
    exports2.waterfall = waterfall;
    exports2.whilst = whilst;
    exports2.all = every;
    exports2.allLimit = everyLimit;
    exports2.allSeries = everySeries;
    exports2.any = some;
    exports2.anyLimit = someLimit;
    exports2.anySeries = someSeries;
    exports2.find = detect;
    exports2.findLimit = detectLimit;
    exports2.findSeries = detectSeries;
    exports2.forEach = eachLimit;
    exports2.forEachSeries = eachSeries;
    exports2.forEachLimit = eachLimit$1;
    exports2.forEachOf = eachOf;
    exports2.forEachOfSeries = eachOfSeries;
    exports2.forEachOfLimit = eachOfLimit;
    exports2.inject = reduce;
    exports2.foldl = reduce;
    exports2.foldr = reduceRight;
    exports2.select = filter;
    exports2.selectLimit = filterLimit;
    exports2.selectSeries = filterSeries;
    exports2.wrapSync = asyncify;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/isstream/isstream.js
var require_isstream = __commonJS((exports, module) => {
  var isStream = function(obj) {
    return obj instanceof stream2.Stream;
  };
  var isReadable = function(obj) {
    return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
  };
  var isWritable = function(obj) {
    return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
  };
  var isDuplex = function(obj) {
    return isReadable(obj) && isWritable(obj);
  };
  var stream2 = import.meta.require("stream");
  module.exports = isStream;
  module.exports.isReadable = isReadable;
  module.exports.isWritable = isWritable;
  module.exports.isDuplex = isDuplex;
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS((exports) => {
  var events = import.meta.require("events");
  var fs = import.meta.require("fs");
  var path2 = import.meta.require("path");
  var util = import.meta.require("util");
  var async = require_async();
  var zlib = import.meta.require("zlib");
  var common = require_common();
  var Transport = require_transport().Transport;
  var isWritable = require_isstream().isWritable;
  var Stream = import.meta.require("stream").Stream;
  var os = import.meta.require("os");
  var File = exports.File = function(options) {
    var self2 = this;
    Transport.call(this, options);
    function throwIf(target) {
      Array.prototype.slice.call(arguments, 1).forEach(function(name2) {
        if (options[name2]) {
          throw new Error("Cannot set " + name2 + " and " + target + "together");
        }
      });
    }
    if (options.filename || options.dirname) {
      throwIf("filename or dirname", "stream");
      this._basename = this.filename = options.filename ? path2.basename(options.filename) : "winston.log";
      this.dirname = options.dirname || path2.dirname(options.filename);
      this.options = options.options || { flags: "a" };
      this.options.highWaterMark = this.options.highWaterMark || 24;
    } else if (options.stream) {
      throwIf("stream", "filename", "maxsize");
      this._stream = options.stream;
      this._isStreams2 = isWritable(this._stream);
      this._stream.on("error", function(error) {
        self2.emit("error", error);
      });
      this._stream.setMaxListeners(Infinity);
    } else {
      throw new Error("Cannot log to file without filename or stream.");
    }
    this.json = options.json !== false;
    this.logstash = options.logstash || false;
    this.colorize = options.colorize || false;
    this.maxsize = options.maxsize || null;
    this.rotationFormat = options.rotationFormat || false;
    this.zippedArchive = options.zippedArchive || false;
    this.maxFiles = options.maxFiles || null;
    this.prettyPrint = options.prettyPrint || false;
    this.label = options.label || null;
    this.timestamp = options.timestamp != null ? options.timestamp : true;
    this.eol = options.eol || os.EOL;
    this.tailable = options.tailable || false;
    this.depth = options.depth || null;
    this.showLevel = options.showLevel === undefined ? true : options.showLevel;
    this.maxRetries = options.maxRetries || 2;
    if (this.json) {
      this.stringify = options.stringify;
    }
    this._size = 0;
    this._created = 0;
    this._buffer = [];
    this._draining = false;
    this._opening = false;
    this._failures = 0;
    this._archive = null;
  };
  util.inherits(File, Transport);
  File.prototype.name = "file";
  File.prototype.log = function(level, msg, meta, callback) {
    if (this.silent) {
      return callback(null, true);
    }
    if (this._failures >= this.maxRetries) {
      return callback(new Error("Transport is in a failed state."));
    }
    var self2 = this;
    if (typeof msg !== "string") {
      msg = "" + msg;
    }
    var output = common.log({
      level,
      message: msg,
      meta,
      json: this.json,
      logstash: this.logstash,
      colorize: this.colorize,
      prettyPrint: this.prettyPrint,
      timestamp: this.timestamp,
      showLevel: this.showLevel,
      stringify: this.stringify,
      label: this.label,
      depth: this.depth,
      formatter: this.formatter,
      humanReadableUnhandledException: this.humanReadableUnhandledException
    });
    if (typeof output === "string") {
      output += this.eol;
    }
    if (!this.filename) {
      this._write(output, callback);
      this._size += output.length;
      this._lazyDrain();
    } else {
      this.open(function(err) {
        if (err) {
          return self2._buffer.push([output, callback]);
        }
        self2._write(output, callback);
        self2._size += output.length;
        self2._lazyDrain();
      });
    }
  };
  File.prototype._write = function(data, callback) {
    if (this._isStreams2) {
      this._stream.write(data);
      return callback && process.nextTick(function() {
        callback(null, true);
      });
    }
    var ret = this._stream.write(data);
    if (!callback)
      return;
    if (ret === false) {
      return this._stream.once("drain", function() {
        callback(null, true);
      });
    }
    process.nextTick(function() {
      callback(null, true);
    });
  };
  File.prototype.query = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var file = path2.join(this.dirname, this.filename), options = this.normalizeQuery(options), buff = "", results = [], row = 0;
    var stream2 = fs.createReadStream(file, {
      encoding: "utf8"
    });
    stream2.on("error", function(err) {
      if (stream2.readable) {
        stream2.destroy();
      }
      if (!callback)
        return;
      return err.code !== "ENOENT" ? callback(err) : callback(null, results);
    });
    stream2.on("data", function(data) {
      var data = (buff + data).split(/\n+/), l = data.length - 1, i2 = 0;
      for (;i2 < l; i2++) {
        if (!options.start || row >= options.start) {
          add(data[i2]);
        }
        row++;
      }
      buff = data[l];
    });
    stream2.on("close", function() {
      if (buff)
        add(buff, true);
      if (options.order === "desc") {
        results = results.reverse();
      }
      if (callback)
        callback(null, results);
    });
    function add(buff2, attempt) {
      try {
        var log = JSON.parse(buff2);
        if (check(log))
          push(log);
      } catch (e) {
        if (!attempt) {
          stream2.emit("error", e);
        }
      }
    }
    function push(log) {
      if (options.rows && results.length >= options.rows && options.order != "desc") {
        if (stream2.readable) {
          stream2.destroy();
        }
        return;
      }
      if (options.fields) {
        var obj = {};
        options.fields.forEach(function(key) {
          obj[key] = log[key];
        });
        log = obj;
      }
      if (options.order === "desc") {
        if (results.length >= options.rows) {
          results.shift();
        }
      }
      results.push(log);
    }
    function check(log) {
      if (!log)
        return;
      if (typeof log !== "object")
        return;
      var time = new Date(log.timestamp);
      if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
        return;
      }
      return true;
    }
  };
  File.prototype.stream = function(options) {
    var file = path2.join(this.dirname, this.filename), options = options || {}, stream2 = new Stream;
    var tail = {
      file,
      start: options.start
    };
    stream2.destroy = common.tailFile(tail, function(err, line) {
      if (err) {
        return stream2.emit("error", err);
      }
      try {
        stream2.emit("data", line);
        line = JSON.parse(line);
        stream2.emit("log", line);
      } catch (e) {
        stream2.emit("error", e);
      }
    });
    return stream2;
  };
  File.prototype.open = function(callback) {
    if (this.opening) {
      return callback(true);
    } else if (!this._stream || this.maxsize && this._size >= this.maxsize) {
      callback(true);
      return this._createStream();
    }
    this._archive = this.zippedArchive ? this._stream.path : null;
    callback();
  };
  File.prototype.close = function() {
    var self2 = this;
    if (this._stream) {
      this._stream.end();
      this._stream.destroySoon();
      this._stream.once("finish", function() {
        self2.emit("flush");
        self2.emit("closed");
      });
    }
  };
  File.prototype.flush = function() {
    var self2 = this;
    if (!this._buffer.length) {
      return self2.emit("flush");
    }
    this._buffer.forEach(function(item2) {
      var str = item2[0], callback = item2[1];
      process.nextTick(function() {
        self2._write(str, callback);
        self2._size += str.length;
      });
    });
    self2._buffer.length = 0;
    self2._stream.once("drain", function() {
      self2.emit("flush");
      self2.emit("logged");
    });
  };
  File.prototype._createStream = function() {
    var self2 = this;
    this.opening = true;
    (function checkFile(target) {
      var fullname = path2.join(self2.dirname, target);
      function createAndFlush(size) {
        if (self2._stream) {
          self2._stream.end();
          self2._stream.destroySoon();
        }
        self2._size = size;
        self2.filename = target;
        self2._stream = fs.createWriteStream(fullname, self2.options);
        self2._isStreams2 = isWritable(self2._stream);
        self2._stream.on("error", function(error) {
          if (self2._failures < self2.maxRetries) {
            self2._createStream();
            self2._failures++;
          } else {
            self2.emit("error", error);
          }
        });
        self2._stream.setMaxListeners(Infinity);
        self2.once("flush", function() {
          self2.flush();
          self2.opening = false;
          self2.emit("open", fullname);
        });
        self2.flush();
        compressFile();
      }
      function compressFile() {
        if (self2._archive) {
          var gzip = zlib.createGzip();
          var inp = fs.createReadStream(String(self2._archive));
          var out = fs.createWriteStream(self2._archive + ".gz");
          inp.pipe(gzip).pipe(out);
          fs.unlink(String(self2._archive), function() {
          });
          self2._archive = "";
        }
      }
      fs.stat(fullname, function(err, stats) {
        if (err) {
          if (err.code !== "ENOENT") {
            return self2.emit("error", err);
          }
          return createAndFlush(0);
        }
        if (!stats || self2.maxsize && stats.size >= self2.maxsize) {
          return self2._incFile(function() {
            checkFile(self2._getFile());
          });
        }
        createAndFlush(stats.size);
      });
    })(this._getFile());
  };
  File.prototype._incFile = function(callback) {
    var ext = path2.extname(this._basename), basename = path2.basename(this._basename, ext), oldest, target;
    if (!this.tailable) {
      this._created += 1;
      this._checkMaxFilesIncrementing(ext, basename, callback);
    } else {
      this._checkMaxFilesTailable(ext, basename, callback);
    }
  };
  File.prototype._getFile = function() {
    var ext = path2.extname(this._basename), basename = path2.basename(this._basename, ext);
    return !this.tailable && this._created ? basename + (this.rotationFormat ? this.rotationFormat() : this._created) + ext : basename + ext;
  };
  File.prototype._checkMaxFilesIncrementing = function(ext, basename, callback) {
    var oldest, target, self2 = this;
    if (self2.zippedArchive) {
      self2._archive = path2.join(self2.dirname, basename + (self2._created === 1 ? "" : self2._created - 1) + ext);
    }
    if (!self2.maxFiles || self2._created < self2.maxFiles) {
      return callback();
    }
    oldest = self2._created - self2.maxFiles;
    target = path2.join(self2.dirname, basename + (oldest !== 0 ? oldest : "") + ext + (self2.zippedArchive ? ".gz" : ""));
    fs.unlink(target, callback);
  };
  File.prototype._checkMaxFilesTailable = function(ext, basename, callback) {
    var tasks = [], self2 = this;
    if (!this.maxFiles)
      return;
    for (var x = this.maxFiles - 1;x > 0; x--) {
      tasks.push(function(i2) {
        return function(cb) {
          var tmppath = path2.join(self2.dirname, basename + (i2 - 1) + ext + (self2.zippedArchive ? ".gz" : ""));
          fs.exists(tmppath, function(exists) {
            if (!exists) {
              return cb(null);
            }
            fs.rename(tmppath, path2.join(self2.dirname, basename + i2 + ext + (self2.zippedArchive ? ".gz" : "")), cb);
          });
        };
      }(x));
    }
    if (self2.zippedArchive) {
      self2._archive = path2.join(self2.dirname, basename + 1 + ext);
    }
    async.series(tasks, function(err) {
      fs.rename(path2.join(self2.dirname, basename + ext), path2.join(self2.dirname, basename + 1 + ext), callback);
    });
  };
  File.prototype._lazyDrain = function() {
    var self2 = this;
    if (!this._draining && this._stream) {
      this._draining = true;
      this._stream.once("drain", function() {
        self2._draining = false;
        self2.emit("logged");
      });
    }
  };
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS((exports) => {
  var util = import.meta.require("util");
  var winston = require_winston();
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var Stream = import.meta.require("stream").Stream;
  var Transport = require_transport().Transport;
  var Http = exports.Http = function(options) {
    Transport.call(this, options);
    options = options || {};
    this.name = "http";
    this.ssl = !!options.ssl;
    this.host = options.host || "localhost";
    this.port = options.port;
    this.auth = options.auth;
    this.path = options.path || "";
    this.agent = options.agent;
    this.headers = options.headers || {};
    this.headers["content-type"] = "application/json";
    if (!this.port) {
      this.port = this.ssl ? 443 : 80;
    }
  };
  util.inherits(Http, winston.Transport);
  Http.prototype.name = "http";
  Http.prototype._request = function(options, callback) {
    options = options || {};
    var auth = options.auth || this.auth, path2 = options.path || this.path || "", req;
    delete options.auth;
    delete options.path;
    req = (this.ssl ? https : http).request({
      host: this.host,
      port: this.port,
      path: "/" + path2.replace(/^\//, ""),
      method: "POST",
      headers: this.headers,
      agent: this.agent,
      auth: auth ? auth.username + ":" + auth.password : ""
    });
    req.on("error", callback);
    req.on("response", function(res) {
      var body = "";
      res.on("data", function(chunk) {
        body += chunk;
      });
      res.on("end", function() {
        callback(null, res, body);
      });
      res.resume();
    });
    req.end(new Buffer.from(JSON.stringify(options), "utf8"));
  };
  Http.prototype.log = function(level, msg, meta, callback) {
    var self2 = this;
    if (typeof meta === "function") {
      callback = meta;
      meta = {};
    }
    var options = {
      method: "collect",
      params: {
        level,
        message: msg,
        meta
      }
    };
    if (meta) {
      if (meta.path) {
        options.path = meta.path;
        delete meta.path;
      }
      if (meta.auth) {
        options.auth = meta.auth;
        delete meta.auth;
      }
    }
    this._request(options, function(err, res) {
      if (res && res.statusCode !== 200) {
        err = new Error("HTTP Status Code: " + res.statusCode);
      }
      if (err)
        return callback(err);
      self2.emit("logged");
      if (callback)
        callback(null, true);
    });
  };
  Http.prototype.query = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var self2 = this, options = this.normalizeQuery(options);
    options = {
      method: "query",
      params: options
    };
    if (options.params.path) {
      options.path = options.params.path;
      delete options.params.path;
    }
    if (options.params.auth) {
      options.auth = options.params.auth;
      delete options.params.auth;
    }
    this._request(options, function(err, res, body) {
      if (res && res.statusCode !== 200) {
        err = new Error("HTTP Status Code: " + res.statusCode);
      }
      if (err)
        return callback(err);
      if (typeof body === "string") {
        try {
          body = JSON.parse(body);
        } catch (e) {
          return callback(e);
        }
      }
      callback(null, body);
    });
  };
  Http.prototype.stream = function(options) {
    options = options || {};
    var self2 = this, stream2 = new Stream, req, buff;
    stream2.destroy = function() {
      req.destroy();
    };
    options = {
      method: "stream",
      params: options
    };
    if (options.params.path) {
      options.path = options.params.path;
      delete options.params.path;
    }
    if (options.params.auth) {
      options.auth = options.params.auth;
      delete options.params.auth;
    }
    req = this._request(options);
    buff = "";
    req.on("data", function(data) {
      var data = (buff + data).split(/\n+/), l = data.length - 1, i2 = 0;
      for (;i2 < l; i2++) {
        try {
          stream2.emit("log", JSON.parse(data[i2]));
        } catch (e) {
          stream2.emit("error", e);
        }
      }
      buff = data[l];
    });
    req.on("error", function(err) {
      stream2.emit("error", err);
    });
    return stream2;
  };
});

// node_modules/winston/lib/winston/transports/memory.js
var require_memory = __commonJS((exports) => {
  var events = import.meta.require("events");
  var util = import.meta.require("util");
  var common = require_common();
  var Transport = require_transport().Transport;
  var Memory = exports.Memory = function(options) {
    Transport.call(this, options);
    options = options || {};
    this.errorOutput = [];
    this.writeOutput = [];
    this.json = options.json || false;
    this.colorize = options.colorize || false;
    this.prettyPrint = options.prettyPrint || false;
    this.timestamp = typeof options.timestamp !== "undefined" ? options.timestamp : false;
    this.showLevel = options.showLevel === undefined ? true : options.showLevel;
    this.label = options.label || null;
    this.depth = options.depth || null;
    if (this.json) {
      this.stringify = options.stringify || function(obj) {
        return JSON.stringify(obj, null, 2);
      };
    }
  };
  util.inherits(Memory, Transport);
  Memory.prototype.name = "memory";
  Memory.prototype.log = function(level, msg, meta, callback) {
    if (this.silent) {
      return callback(null, true);
    }
    var self2 = this, output;
    output = common.log({
      colorize: this.colorize,
      json: this.json,
      level,
      message: msg,
      meta,
      stringify: this.stringify,
      timestamp: this.timestamp,
      prettyPrint: this.prettyPrint,
      raw: this.raw,
      label: this.label,
      depth: this.depth,
      formatter: this.formatter,
      humanReadableUnhandledException: this.humanReadableUnhandledException
    });
    if (level === "error" || level === "debug") {
      this.errorOutput.push(output);
    } else {
      this.writeOutput.push(output);
    }
    self2.emit("logged");
    callback(null, true);
  };
  Memory.prototype.clearLogs = function() {
    this.errorOutput = [];
    this.writeOutput = [];
  };
});

// node_modules/winston/lib/winston/transports.js
var require_transports = __commonJS((exports) => {
  Object.defineProperty(exports, "Console", {
    configurable: true,
    enumerable: true,
    get: function() {
      return require_console().Console;
    }
  });
  Object.defineProperty(exports, "File", {
    configurable: true,
    enumerable: true,
    get: function() {
      return require_file().File;
    }
  });
  Object.defineProperty(exports, "Http", {
    configurable: true,
    enumerable: true,
    get: function() {
      return require_http().Http;
    }
  });
  Object.defineProperty(exports, "Memory", {
    configurable: true,
    enumerable: true,
    get: function() {
      return require_memory().Memory;
    }
  });
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS((exports) => {
  var CallSite = function(properties) {
    for (var property in properties) {
      this[property] = properties[property];
    }
  };
  exports.get = function(belowFn) {
    var oldLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Infinity;
    var dummyObject = {};
    var v8Handler = Error.prepareStackTrace;
    Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
      return v8StackTrace2;
    };
    Error.captureStackTrace(dummyObject, belowFn || exports.get);
    var v8StackTrace = dummyObject.stack;
    Error.prepareStackTrace = v8Handler;
    Error.stackTraceLimit = oldLimit;
    return v8StackTrace;
  };
  exports.parse = function(err) {
    if (!err.stack) {
      return [];
    }
    var self2 = this;
    var lines = err.stack.split("\n").slice(1);
    return lines.map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return self2._createParsedCallSite({
          fileName: line,
          lineNumber: null,
          functionName: null,
          typeName: null,
          methodName: null,
          columnNumber: null,
          native: null
        });
      }
      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return;
      }
      var object = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = lineMatch[5] === "native";
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] == ".")
          methodStart--;
        if (methodStart > 0) {
          object = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object = object.substr(0, objectEnd);
          }
        }
        typeName = null;
      }
      if (method) {
        typeName = object;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = null;
        functionName = null;
      }
      var properties = {
        fileName: lineMatch[2] || null,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        functionName,
        typeName,
        methodName,
        columnNumber: parseInt(lineMatch[4], 10) || null,
        native: isNative
      };
      return self2._createParsedCallSite(properties);
    }).filter(function(callSite) {
      return !!callSite;
    });
  };
  var strProperties = [
    "this",
    "typeName",
    "functionName",
    "methodName",
    "fileName",
    "lineNumber",
    "columnNumber",
    "function",
    "evalOrigin"
  ];
  var boolProperties = [
    "topLevel",
    "eval",
    "native",
    "constructor"
  ];
  strProperties.forEach(function(property) {
    CallSite.prototype[property] = null;
    CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  boolProperties.forEach(function(property) {
    CallSite.prototype[property] = false;
    CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  exports._createParsedCallSite = function(properties) {
    return new CallSite(properties);
  };
});

// node_modules/winston/lib/winston/exception.js
var require_exception = __commonJS((exports) => {
  var os = import.meta.require("os");
  var stackTrace = require_stack_trace();
  var exception = exports;
  exception.getAllInfo = function(err) {
    return {
      date: new Date().toString(),
      process: exception.getProcessInfo(),
      os: exception.getOsInfo(),
      trace: exception.getTrace(err),
      stack: err.stack && err.stack.split("\n")
    };
  };
  exception.getProcessInfo = function() {
    return {
      pid: process.pid,
      uid: process.getuid ? process.getuid() : null,
      gid: process.getgid ? process.getgid() : null,
      cwd: process.cwd(),
      execPath: process.execPath,
      version: process.version,
      argv: process.argv,
      memoryUsage: process.memoryUsage()
    };
  };
  exception.getOsInfo = function() {
    return {
      loadavg: os.loadavg(),
      uptime: os.uptime()
    };
  };
  exception.getTrace = function(err) {
    var trace = err ? stackTrace.parse(err) : stackTrace.get();
    return trace.map(function(site) {
      return {
        column: site.getColumnNumber(),
        file: site.getFileName(),
        function: site.getFunctionName(),
        line: site.getLineNumber(),
        method: site.getMethodName(),
        native: site.isNative()
      };
    });
  };
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS((exports) => {
  var common = require_common();
  var winston = require_winston();
  var extend = import.meta.require("util")._extend;
  var Container = exports.Container = function(options) {
    this.loggers = {};
    this.options = options || {};
    this.default = {
      transports: [
        new winston.transports.Console({
          level: "silly",
          colorize: false
        })
      ]
    };
  };
  Container.prototype.get = Container.prototype.add = function(id, options) {
    var self2 = this, existing;
    if (!this.loggers[id]) {
      options = extend({}, options || this.options || this.default);
      existing = options.transports || this.options.transports;
      options.transports = existing ? existing.slice() : [];
      if (options.transports.length === 0 && (!options || !options["console"])) {
        options.transports.push(this.default.transports[0]);
      }
      Object.keys(options).forEach(function(key) {
        if (key === "transports" || key === "filters" || key === "rewriters") {
          return;
        }
        var name2 = common.capitalize(key);
        if (!winston.transports[name2]) {
          throw new Error("Cannot add unknown transport: " + name2);
        }
        var namedOptions = options[key];
        namedOptions.id = id;
        options.transports.push(new winston.transports[name2](namedOptions));
      });
      options.id = id;
      this.loggers[id] = new winston.Logger(options);
      this.loggers[id].on("close", function() {
        self2._delete(id);
      });
    }
    return this.loggers[id];
  };
  Container.prototype.has = function(id) {
    return !!this.loggers[id];
  };
  Container.prototype.close = function(id) {
    var self2 = this;
    function _close(id2) {
      if (!self2.loggers[id2]) {
        return;
      }
      self2.loggers[id2].close();
      self2._delete(id2);
    }
    return id ? _close(id) : Object.keys(this.loggers).forEach(function(id2) {
      _close(id2);
    });
  };
  Container.prototype._delete = function(id) {
    delete this.loggers[id];
  };
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS((exports) => {
  var ProfileHandler = function(logger) {
    this.logger = logger;
    this.start = Date.now();
  };
  var events = import.meta.require("events");
  var util = import.meta.require("util");
  var async = require_async();
  var config = require_config();
  var common = require_common();
  var exception = require_exception();
  var Stream = import.meta.require("stream").Stream;
  var formatRegExp = /%[sdj%]/g;
  var Logger = exports.Logger = function(options) {
    events.EventEmitter.call(this);
    this.configure(options);
  };
  util.inherits(Logger, events.EventEmitter);
  Logger.prototype.configure = function(options) {
    var self2 = this;
    if (Array.isArray(this._names) && this._names.length) {
      this.clear();
    }
    options = options || {};
    this.transports = {};
    this._names = [];
    if (options.transports) {
      options.transports.forEach(function(transport) {
        self2.add(transport, null, true);
      });
    }
    this.padLevels = options.padLevels || false;
    this.setLevels(options.levels);
    if (options.colors) {
      config.addColors(options.colors);
    }
    this.id = options.id || null;
    this.level = options.level || "info";
    this.emitErrs = options.emitErrs || false;
    this.stripColors = options.stripColors || false;
    this.exitOnError = typeof options.exitOnError !== "undefined" ? options.exitOnError : true;
    this.exceptionHandlers = {};
    this.profilers = {};
    ["rewriters", "filters"].forEach(function(kind) {
      self2[kind] = Array.isArray(options[kind]) ? options[kind] : [];
    });
    if (options.exceptionHandlers) {
      this.handleExceptions(options.exceptionHandlers);
    }
  };
  Logger.prototype.log = function(level) {
    var args = Array.prototype.slice.call(arguments, 1), self2 = this, transports;
    while (args[args.length - 1] === null) {
      args.pop();
    }
    var callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
    function onError(err) {
      if (callback) {
        callback(err);
      } else if (self2.emitErrs) {
        self2.emit("error", err);
      }
    }
    if (this._names.length === 0) {
      return onError(new Error("Cannot log with no transports."));
    } else if (typeof self2.levels[level] === "undefined") {
      return onError(new Error("Unknown log level: " + level));
    }
    var targets = this._names.filter(function(name2) {
      var transport = self2.transports[name2];
      return transport.level && self2.levels[transport.level] >= self2.levels[level] || !transport.level && self2.levels[self2.level] >= self2.levels[level];
    });
    if (!targets.length) {
      if (callback) {
        callback();
      }
      return;
    }
    var msg, meta = {}, validMeta = false;
    var hasFormat = args && args[0] && args[0].match && args[0].match(formatRegExp) !== null;
    var tokens = hasFormat ? args[0].match(formatRegExp) : [];
    var ptokens = tokens.filter(function(t) {
      return t === "%%";
    });
    if (args.length - 1 - (tokens.length - ptokens.length) > 0 || args.length === 1) {
      meta = args[args.length - 1] || args;
      var metaType = Object.prototype.toString.call(meta);
      validMeta = metaType === "[object Object]" || metaType === "[object Error]" || metaType === "[object Array]";
      meta = validMeta ? args.pop() : {};
    }
    msg = util.format.apply(null, args);
    function finish(err) {
      if (callback) {
        if (err)
          return callback(err);
        callback(null, level, msg, meta);
      }
      callback = null;
      if (!err) {
        self2.emit("logged", level, msg, meta);
      }
    }
    if (this.padLevels) {
      msg = new Array(this.levelLength - level.length + 1).join(" ") + msg;
    }
    this.rewriters.forEach(function(rewriter) {
      meta = rewriter(level, msg, meta, self2);
    });
    this.filters.forEach(function(filter) {
      var filtered = filter(level, msg, meta, self2);
      if (typeof filtered === "string")
        msg = filtered;
      else {
        msg = filtered.msg;
        meta = filtered.meta;
      }
    });
    if (this.stripColors) {
      var code = /\u001b\[(\d+(;\d+)*)?m/g;
      msg = ("" + msg).replace(code, "");
    }
    function transportLog(name2, next) {
      var transport = self2.transports[name2];
      transport.log(level, msg, meta, function(err) {
        if (err) {
          err.transport = transport;
          finish(err);
          return next();
        }
        self2.emit("logging", transport, level, msg, meta);
        next();
      });
    }
    async.forEach(targets, transportLog, finish);
    return this;
  };
  Logger.prototype.query = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var self2 = this, options = options || {}, results = {}, query = common.clone(options.query) || {}, transports;
    function queryTransport(transport, next) {
      if (options.query) {
        options.query = transport.formatQuery(query);
      }
      transport.query(options, function(err, results2) {
        if (err) {
          return next(err);
        }
        next(null, transport.formatResults(results2, options.format));
      });
    }
    function addResults(transport, next) {
      queryTransport(transport, function(err, result) {
        if (next) {
          result = err || result;
          if (result) {
            results[transport.name] = result;
          }
          next();
        }
        next = null;
      });
    }
    if (options.transport) {
      options.transport = options.transport.toLowerCase();
      return queryTransport(this.transports[options.transport], callback);
    }
    transports = this._names.map(function(name2) {
      return self2.transports[name2];
    }).filter(function(transport) {
      return !!transport.query;
    });
    async.forEach(transports, addResults, function() {
      callback(null, results);
    });
  };
  Logger.prototype.stream = function(options) {
    var self2 = this, options = options || {}, out = new Stream, streams = [], transports;
    if (options.transport) {
      var transport = this.transports[options.transport];
      delete options.transport;
      if (transport && transport.stream) {
        return transport.stream(options);
      }
    }
    out._streams = streams;
    out.destroy = function() {
      var i2 = streams.length;
      while (i2--)
        streams[i2].destroy();
    };
    transports = this._names.map(function(name2) {
      return self2.transports[name2];
    }).filter(function(transport2) {
      return !!transport2.stream;
    });
    transports.forEach(function(transport2) {
      var stream2 = transport2.stream(options);
      if (!stream2)
        return;
      streams.push(stream2);
      stream2.on("log", function(log) {
        log.transport = log.transport || [];
        log.transport.push(transport2.name);
        out.emit("log", log);
      });
      stream2.on("error", function(err) {
        err.transport = err.transport || [];
        err.transport.push(transport2.name);
        out.emit("error", err);
      });
    });
    return out;
  };
  Logger.prototype.close = function() {
    var self2 = this;
    this._names.forEach(function(name2) {
      var transport = self2.transports[name2];
      if (transport && transport.close) {
        transport.close();
      }
    });
    this.emit("close");
  };
  Logger.prototype.handleExceptions = function() {
    var args = Array.prototype.slice.call(arguments), handlers = [], self2 = this;
    args.forEach(function(a) {
      if (Array.isArray(a)) {
        handlers = handlers.concat(a);
      } else {
        handlers.push(a);
      }
    });
    this.exceptionHandlers = this.exceptionHandlers || {};
    handlers.forEach(function(handler) {
      self2.exceptionHandlers[handler.name] = handler;
    });
    this._hnames = Object.keys(self2.exceptionHandlers);
    if (!this.catchExceptions) {
      this.catchExceptions = this._uncaughtException.bind(this);
      process.on("uncaughtException", this.catchExceptions);
    }
  };
  Logger.prototype.unhandleExceptions = function() {
    var self2 = this;
    if (this.catchExceptions) {
      Object.keys(this.exceptionHandlers).forEach(function(name2) {
        var handler = self2.exceptionHandlers[name2];
        if (handler.close) {
          handler.close();
        }
      });
      this.exceptionHandlers = {};
      Object.keys(this.transports).forEach(function(name2) {
        var transport = self2.transports[name2];
        if (transport.handleExceptions) {
          transport.handleExceptions = false;
        }
      });
      process.removeListener("uncaughtException", this.catchExceptions);
      this.catchExceptions = false;
    }
  };
  Logger.prototype.add = function(transport, options, created) {
    var instance = created ? transport : new transport(options);
    if (!instance.name && !instance.log) {
      throw new Error("Unknown transport with no log() method");
    } else if (this.transports[instance.name]) {
      throw new Error("Transport already attached: " + instance.name + ", assign a different name");
    }
    this.transports[instance.name] = instance;
    this._names = Object.keys(this.transports);
    instance._onError = this._onError.bind(this, instance);
    if (!created) {
      instance.on("error", instance._onError);
    }
    if (instance.handleExceptions && !this.catchExceptions) {
      this.handleExceptions();
    }
    return this;
  };
  Logger.prototype.clear = function() {
    Object.keys(this.transports).forEach(function(name2) {
      this.remove({ name: name2 });
    }, this);
  };
  Logger.prototype.remove = function(transport) {
    var name2 = typeof transport !== "string" ? transport.name || transport.prototype.name : transport;
    if (!this.transports[name2]) {
      throw new Error("Transport " + name2 + " not attached to this instance");
    }
    var instance = this.transports[name2];
    delete this.transports[name2];
    this._names = Object.keys(this.transports);
    if (instance.close) {
      instance.close();
    }
    if (instance._onError) {
      instance.removeListener("error", instance._onError);
    }
    return this;
  };
  Logger.prototype.startTimer = function() {
    return new ProfileHandler(this);
  };
  Logger.prototype.profile = function(id) {
    var now = Date.now(), then, args, msg, meta, callback;
    if (this.profilers[id]) {
      then = this.profilers[id];
      delete this.profilers[id];
      args = Array.prototype.slice.call(arguments);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
      meta = typeof args[args.length - 1] === "object" ? args.pop() : {};
      msg = args.length === 2 ? args[1] : id;
      meta.durationMs = now - then;
      return this.info(msg, meta, callback);
    } else {
      this.profilers[id] = now;
    }
    return this;
  };
  Logger.prototype.setLevels = function(target) {
    return common.setLevels(this, this.levels, target);
  };
  Logger.prototype.cli = function() {
    this.padLevels = true;
    this.setLevels(config.cli.levels);
    config.addColors(config.cli.colors);
    if (this.transports.console) {
      this.transports.console.colorize = this.transports.console.colorize || true;
      this.transports.console.timestamp = this.transports.console.timestamp || false;
    }
    return this;
  };
  Logger.prototype._uncaughtException = function(err) {
    var self2 = this, responded = false, info = exception.getAllInfo(err), handlers = this._getExceptionHandlers(), timeout, doExit;
    doExit = typeof this.exitOnError === "function" ? this.exitOnError(err) : this.exitOnError;
    function logAndWait(transport, next) {
      transport.logException("uncaughtException: " + (err.message || err), info, next, err);
    }
    function gracefulExit() {
      if (doExit && !responded) {
        clearTimeout(timeout);
        responded = true;
        process.exit(1);
      }
    }
    if (!handlers || handlers.length === 0) {
      return gracefulExit();
    }
    async.forEach(handlers, logAndWait, gracefulExit);
    if (doExit) {
      timeout = setTimeout(gracefulExit, 3000);
    }
  };
  Logger.prototype._getExceptionHandlers = function() {
    var self2 = this;
    return this._hnames.map(function(name2) {
      return self2.exceptionHandlers[name2];
    }).concat(this._names.map(function(name2) {
      return self2.transports[name2].handleExceptions && self2.transports[name2];
    })).filter(Boolean);
  };
  Logger.prototype._onError = function(transport, err) {
    if (this.emitErrs) {
      this.emit("error", err, transport);
    }
  };
  ProfileHandler.prototype.done = function(msg) {
    var args = Array.prototype.slice.call(arguments), callback = typeof args[args.length - 1] === "function" ? args.pop() : null, meta = typeof args[args.length - 1] === "object" ? args.pop() : {};
    meta.duration = Date.now() - this.start + "ms";
    return this.logger.info(msg, meta, callback);
  };
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS((exports) => {
  var winston = exports;
  winston.version = require_package().version;
  winston.transports = require_transports();
  var common = require_common();
  winston.hash = common.hash;
  winston.clone = common.clone;
  winston.longestElement = common.longestElement;
  winston.exception = require_exception();
  winston.config = require_config();
  winston.addColors = winston.config.addColors;
  winston.Container = require_container().Container;
  winston.Logger = require_logger().Logger;
  winston.Transport = require_transport().Transport;
  winston.loggers = new winston.Container;
  var defaultLogger = new winston.Logger({
    transports: [new winston.transports.Console]
  });
  var methods = [
    "log",
    "query",
    "stream",
    "add",
    "remove",
    "clear",
    "profile",
    "startTimer",
    "extend",
    "cli",
    "handleExceptions",
    "unhandleExceptions",
    "configure"
  ];
  winston.padLevels = false;
  common.setLevels(winston, null, defaultLogger.levels);
  methods.forEach(function(method) {
    winston[method] = function() {
      return defaultLogger[method].apply(defaultLogger, arguments);
    };
  });
  winston.cli = function() {
    winston.padLevels = true;
    common.setLevels(winston, defaultLogger.levels, winston.config.cli.levels);
    defaultLogger.setLevels(winston.config.cli.levels);
    winston.config.addColors(winston.config.cli.colors);
    if (defaultLogger.transports.console) {
      defaultLogger.transports.console.colorize = true;
      defaultLogger.transports.console.timestamp = false;
    }
    return winston;
  };
  winston.setLevels = function(target) {
    common.setLevels(winston, defaultLogger.levels, target);
    defaultLogger.setLevels(target);
  };
  Object.defineProperty(winston, "level", {
    get: function() {
      return defaultLogger.level;
    },
    set: function(val) {
      defaultLogger.level = val;
      Object.keys(defaultLogger.transports).forEach(function(key) {
        defaultLogger.transports[key].level = val;
      });
    }
  });
  ["emitErrs", "exitOnError", "padLevels", "levelLength", "stripColors"].forEach(function(prop) {
    Object.defineProperty(winston, prop, {
      get: function() {
        return defaultLogger[prop];
      },
      set: function(val) {
        defaultLogger[prop] = val;
      }
    });
  });
  Object.defineProperty(winston, "default", {
    get: function() {
      return {
        transports: defaultLogger.transports,
        exceptionHandlers: defaultLogger.exceptionHandlers
      };
    }
  });
});

// node_modules/@colors/colors/lib/styles.js
var require_styles2 = __commonJS((exports, module) => {
  var styles = {};
  module["exports"] = styles;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = function(flag, argv) {
    argv = argv || process.argv;
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors2 = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(stream2) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream2 && !stream2.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env;
      }) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env) {
      var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  };
  var getSupportLevel = function(stream2) {
    var level = supportsColor(stream2);
    return translateLevel(level);
  };
  var os = import.meta.require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor = undefined;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap2 = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c) {
      c = c.toLowerCase();
      var chars = trap[c] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c] !== "undefined") {
        result += trap[c][rand];
      } else {
        result += c;
      }
    });
    return result;
  };
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo2 = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
      var r = Math.floor(Math.random() * range);
      return r;
    }
    function isChar(character) {
      var bool = false;
      all.filter(function(i2) {
        bool = i2 === character;
      });
      return bool;
    }
    function heComes(text2, options2) {
      var result = "";
      var counts;
      var l;
      options2 = options2 || {};
      options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
      options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
      options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
      options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
      text2 = text2.split("");
      for (l in text2) {
        if (isChar(l)) {
          continue;
        }
        result = result + text2[l];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options2.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d in arr) {
          var index = arr[d];
          for (var i2 = 0;i2 <= counts[index]; i2++) {
            if (options2[index]) {
              result = result + soul[index][randomNumber(soul[index].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options);
  };
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america2 = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i2, exploded) {
      if (letter === " ")
        return letter;
      switch (i2 % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra2 = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i2, exploded) {
      return i2 % 2 === 0 ? letter : colors.inverse(letter);
    };
  };
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow2 = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i2, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i2++ % rainbowColors.length]](letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random2 = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i2, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// node_modules/@colors/colors/lib/colors.js
var require_colors2 = __commonJS((exports, module) => {
  var build = function(_styles) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto;
    return builder;
  };
  var applyStyle = function() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
      if (arg != null && arg.constructor === String) {
        return arg;
      } else {
        return util.inspect(arg);
      }
    }).join(" ");
    if (!colors.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i2 = nestedStyles.length;
    while (i2--) {
      var code = ansiStyles[nestedStyles[i2]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  };
  var init = function() {
    var ret = {};
    Object.keys(styles).forEach(function(name2) {
      ret[name2] = {
        get: function() {
          return build([name2]);
        }
      };
    });
    return ret;
  };
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var util = import.meta.require("util");
  var ansiStyles = colors.styles = require_styles2();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors.supportsColor = require_supports_colors2().supportsColor;
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
  }
  colors.enable = function() {
    colors.enabled = true;
  };
  colors.disable = function() {
    colors.enabled = false;
  };
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles[style];
    if (!styleMap && style in colors) {
      return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  var styles = function() {
    var ret = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto = defineProps(function colors() {
  }, styles);
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller\'s) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + \'/../themes/generic-logging.js\'); The new syntax looks like colors.setTheme(require(__dirname + \'/../themes/generic-logging.js\'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i2 in theme[style2]) {
              out = colors[theme[style2][i2]](out);
            }
            return out;
          }
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  var sequencer = function sequencer(map2, str) {
    var exploded = str.split("");
    exploded = exploded.map(map2);
    return exploded.join("");
  };
  colors.trap = require_trap2();
  colors.zalgo = require_zalgo2();
  colors.maps = {};
  colors.maps.america = require_america2()(colors);
  colors.maps.zebra = require_zebra2()(colors);
  colors.maps.rainbow = require_rainbow2()(colors);
  colors.maps.random = require_random2()(colors);
  for (map in colors.maps) {
    (function(map2) {
      colors[map2] = function(str) {
        return sequencer(colors.maps[map2], str);
      };
    })(map);
  }
  var map;
  defineProps(colors, init());
});

// node_modules/@colors/colors/safe.js
var require_safe2 = __commonJS((exports, module) => {
  var colors = require_colors2();
  module["exports"] = colors;
});

// node_modules/prompt/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "prompt",
    version: "1.3.0",
    description: "A beautiful command-line prompt for node.js",
    author: "Nodejitsu Inc. <info@nodejitsu.com>",
    maintainers: [
      "indexzero <charlie@nodejitsu.com>",
      "jesusabdullah <josh@nodejitsu.com>"
    ],
    repository: {
      type: "git",
      url: "http://github.com/flatiron/prompt.git"
    },
    keywords: [
      "prompt",
      "command-line",
      "customize",
      "validation"
    ],
    dependencies: {
      "@colors/colors": "1.5.0",
      async: "3.2.3",
      read: "1.0.x",
      revalidator: "0.1.x",
      winston: "2.x"
    },
    devDependencies: {
      eslint: "^7.32.0",
      vows: "^0.7.0"
    },
    main: "./lib/prompt",
    scripts: {
      test: "vows test/prompt-test.js --spec",
      "test-all": "vows --spec"
    },
    license: "MIT",
    engines: {
      node: ">= 6.0.0"
    }
  };
});

// node_modules/prompt/lib/prompt.js
var require_prompt = __commonJS((exports, module) => {
  var convert = function(schema) {
    var newProps = Object.keys(validate.messages), newSchema = false, key;
    newProps = newProps.concat(["description", "dependencies"]);
    for (key in schema) {
      if (newProps.indexOf(key) > 0) {
        newSchema = true;
        break;
      }
    }
    if (!newSchema || schema.validator || schema.warning || typeof schema.empty !== "undefined") {
      if (typeof schema.message !== "undefined") {
        schema.description = schema.message;
      }
      if (typeof schema.warning !== "undefined") {
        schema.message = schema.warning;
      }
      if (typeof schema.validator === "function") {
        schema.conform = schema.validator;
      } else {
        schema.pattern = schema.validator;
      }
      if (typeof schema.empty !== "undefined") {
        schema.required = !schema.empty;
      }
      delete schema.warning;
      delete schema.validator;
      delete schema.empty;
    }
    return schema;
  };
  var events = import.meta.require("events");
  var readline = import.meta.require("readline");
  var eachSeries = require_eachSeries();
  var rejectSeries = require_rejectSeries();
  var read = require_read();
  var validate = require_revalidator().validate;
  var winston = require_winston();
  var colors = require_safe2();
  readline.Interface.prototype.setPrompt = function(prompt2, length) {
    this._prompt = prompt2;
    if (length) {
      this._promptLength = length;
    } else {
      var lines = prompt2.split(/[\r\n]/);
      var lastLine = lines[lines.length - 1];
      this._promptLength = lastLine.replace(/\u001b\[(\d+(;\d+)*)?m/g, "").length;
    }
  };
  exports.version = require_package2().version;
  var stdin;
  var stdout;
  var history = [];
  var prompt = module.exports = Object.create(events.EventEmitter.prototype);
  var logger = prompt.logger = new winston.Logger({
    transports: [new winston.transports.Console]
  });
  prompt.started = false;
  prompt.paused = false;
  prompt.stopped = true;
  prompt.allowEmpty = false;
  prompt.message = "prompt";
  prompt.delimiter = ": ";
  prompt.colors = true;
  prompt.properties = {};
  logger.cli();
  prompt.start = function(options) {
    if (prompt.started) {
      return;
    }
    options = options || {};
    stdin = options.stdin || process.stdin;
    stdout = options.stdout || process.stdout;
    prompt.memory = options.memory || 10;
    prompt.allowEmpty = options.allowEmpty || false;
    prompt.message = options.message || prompt.message;
    prompt.delimiter = options.delimiter || prompt.delimiter;
    prompt.colors = options.colors || prompt.colors;
    if (!options.noHandleSIGINT) {
      if (process.platform !== "win32") {
        process.on("SIGINT", function() {
          stdout.write("\n");
          process.exit(1);
        });
      } else {
        stdin.on("keypress", function(char, key) {
          if (key && key.ctrl && key.name == "c") {
            stdout.write("\n");
            process.emit("SIGINT");
            process.exit(1);
          }
        });
      }
    }
    prompt.emit("start");
    prompt.started = true;
    prompt.stopped = false;
    return prompt;
  };
  prompt.pause = function() {
    if (!prompt.started || prompt.stopped || prompt.paused) {
      return;
    }
    stdin.pause();
    prompt.emit("pause");
    prompt.paused = true;
    return prompt;
  };
  prompt.stop = function() {
    if (prompt.stopped || !prompt.started) {
      return;
    }
    stdin.destroy();
    prompt.emit("stop");
    prompt.stopped = true;
    prompt.started = false;
    prompt.paused = false;
    return prompt;
  };
  prompt.resume = function() {
    if (!prompt.started || !prompt.paused) {
      return;
    }
    stdin.resume();
    prompt.emit("resume");
    prompt.paused = false;
    return prompt;
  };
  prompt.history = function(search) {
    if (typeof search === "number") {
      return history[search] || {};
    }
    var names = history.map(function(pair) {
      return typeof pair.property === "string" ? pair.property : pair.property.name;
    });
    if (!~names.indexOf(search)) {
      return null;
    }
    return history.filter(function(pair) {
      return typeof pair.property === "string" ? pair.property === search : pair.property.name === search;
    })[0];
  };
  prompt.get = function(schema, callback) {
    if (typeof callback === "function")
      return prompt._get(schema, callback);
    return new Promise(function(resolve2, reject2) {
      prompt._get(schema, function(err, result) {
        return err ? reject2(err) : resolve2(result);
      });
    });
  };
  prompt._get = function(schema, callback) {
    function untangle(schema2, path2) {
      var results = [];
      path2 = path2 || [];
      if (schema2.properties) {
        Object.keys(schema2.properties).forEach(function(key) {
          var obj = {};
          obj[key] = schema2.properties[key];
          results = results.concat(untangle(obj[key], path2.concat(key)));
        });
        return results;
      }
      return {
        path: path2,
        schema: schema2
      };
    }
    function iterate(schema2, get, done) {
      var iterator = [], result = {};
      if (typeof schema2 === "string") {
        iterator.push({
          path: [schema2],
          schema: prompt.properties[schema2.toLowerCase()] || {}
        });
      } else if (Array.isArray(schema2)) {
        iterator = schema2.map(function(element) {
          if (typeof element === "string") {
            return {
              path: [element],
              schema: prompt.properties[element.toLowerCase()] || {}
            };
          } else if (element.properties) {
            return {
              path: [Object.keys(element.properties)[0]],
              schema: element.properties[Object.keys(element.properties)[0]]
            };
          } else if (element.path && element.schema) {
            return element;
          } else {
            return {
              path: [element.name || "question"],
              schema: element
            };
          }
        });
      } else if (schema2.properties) {
        iterator = untangle(schema2);
      } else {
        iterator = [{
          schema: schema2.schema ? schema2.schema : schema2,
          path: schema2.path || [schema2.name || "question"]
        }];
      }
      eachSeries(iterator, function(branch, next) {
        get(branch, function assembler(err, line) {
          if (err) {
            return next(err);
          }
          function build(path2, line2) {
            var obj = {};
            if (path2.length) {
              obj[path2[0]] = build(path2.slice(1), line2);
              return obj;
            }
            return line2;
          }
          function attach(obj, attr) {
            var keys;
            if (typeof attr !== "object" || attr instanceof Array) {
              return attr;
            }
            keys = Object.keys(attr);
            if (keys.length) {
              if (!obj[keys[0]]) {
                obj[keys[0]] = {};
              }
              obj[keys[0]] = attach(obj[keys[0]], attr[keys[0]]);
            }
            return obj;
          }
          result = attach(result, build(branch.path, line));
          next();
        });
      }, function(err) {
        return err ? done(err) : done(null, result);
      });
    }
    iterate(schema, function get(target, next) {
      prompt.getInput(target, function(err, line) {
        return err ? next(err) : next(null, line);
      });
    }, callback);
    return prompt;
  };
  prompt.confirm = function() {
    var args = Array.prototype.slice.call(arguments), msg = args.shift(), callback = args.pop(), opts = args.shift(), vars = !Array.isArray(msg) ? [msg] : msg, RX_Y = /^[yt]{1}/i, RX_YN = /^[yntf]{1}/i;
    function confirm(target, next) {
      var yes = target.yes || RX_Y, options = {
        description: typeof target === "string" ? target : target.description || "yes/no",
        pattern: target.pattern || RX_YN,
        name: "confirm",
        message: target.message || "yes/no"
      };
      for (var k in opts || {}) {
        if (opts.hasOwnProperty(k)) {
          options[k] = opts[k];
        }
      }
      prompt.get([options], function(err, result) {
        next(null, err ? false : yes.test(result[options.name]));
      });
    }
    rejectSeries(vars, confirm, function(err, result) {
      callback(null, result.length === 0);
    });
  };
  var tmp = [];
  prompt.getInput = function(prop, callback) {
    var schema = prop.schema || prop, propName = prop.path && prop.path.join(":") || prop, storedSchema = prompt.properties[propName.toLowerCase()], delim = prompt.delimiter, defaultLine, against, hidden, length, valid, name2, raw, msg;
    if (schema instanceof Object && !Object.keys(schema).length && typeof storedSchema !== "undefined") {
      schema = storedSchema;
    }
    if (typeof prop === "string" && !storedSchema) {
      schema = {};
    }
    schema = convert(schema);
    defaultLine = schema.default;
    name2 = prop.description || schema.description || propName;
    raw = prompt.colors ? [colors.grey(name2), colors.grey(delim)] : [name2, delim];
    if (prompt.message)
      raw.unshift(prompt.message, delim);
    prop = {
      schema,
      path: propName.split(":")
    };
    if (!schema.properties) {
      schema = function() {
        var obj = { properties: {} };
        obj.properties[propName] = schema;
        return obj;
      }();
    }
    if (prompt.override && prompt.override.hasOwnProperty(propName)) {
      if (prompt._performValidation(name2, prop, prompt.override, schema, -1, callback)) {
        return callback(null, prompt.override[propName]);
      }
      delete prompt.override[propName];
    }
    if (typeof prop.schema.ask === "function" && !prop.schema.ask()) {
      return callback(null, prop.schema.default || "");
    }
    var type = (schema.properties && schema.properties[propName] && schema.properties[propName].type || "").toLowerCase().trim(), wait = type === "array";
    if (type === "array") {
      length = prop.schema.maxItems;
      if (length) {
        msg = (tmp.length + 1).toString() + "/" + length.toString();
      } else {
        msg = (tmp.length + 1).toString();
      }
      msg += delim;
      raw.push(prompt.colors ? colors.grey(msg) : msg);
    }
    length = raw.join("").length;
    msg = raw.join("");
    if (schema.help) {
      schema.help.forEach(function(line) {
        logger.help(line);
      });
    }
    prompt.emit("prompt", prop);
    if (typeof defaultLine === "function") {
      defaultLine = defaultLine();
    }
    if (typeof defaultLine === "undefined") {
      defaultLine = "";
    }
    defaultLine = defaultLine.toString();
    read({
      prompt: msg,
      silent: prop.schema && prop.schema.hidden,
      replace: prop.schema && prop.schema.replace,
      default: defaultLine,
      input: stdin,
      output: stdout
    }, function(err, line) {
      if (err && wait === false) {
        return callback(err);
      }
      var against2 = {}, numericInput, isValid;
      if (line !== "") {
        if (schema.properties[propName]) {
          var type2 = (schema.properties[propName].type || "").toLowerCase().trim() || undefined;
          if (type2 === "number" || type2 === "integer") {
            line = Number(line);
          }
          if (type2 == "boolean") {
            if (line.toLowerCase() === "true" || line.toLowerCase() === "t") {
              line = true;
            } else if (line.toLowerCase() === "false" || line.toLowerCase() === "f") {
              line = false;
            }
          }
          if (type2 == "array") {
            var length2 = prop.schema.maxItems;
            if (err) {
              if (err.message == "canceled") {
                wait = false;
                stdout.write("\n");
              }
            } else {
              if (length2) {
                if (tmp.length + 1 < length2) {
                  isValid = false;
                  wait = true;
                } else {
                  isValid = true;
                  wait = false;
                }
              } else {
                isValid = false;
                wait = true;
              }
              tmp.push(line);
            }
            line = tmp;
          }
        }
        against2[propName] = line;
      }
      if (prop && prop.schema.before) {
        line = prop.schema.before(line);
      }
      if (isValid === undefined)
        isValid = prompt._performValidation(name2, prop, against2, schema, line, callback);
      if (!isValid) {
        return prompt.getInput(prop, callback);
      }
      logger.input(line.yellow);
      prompt._remember(propName, line);
      callback(null, line);
      tmp = [];
    });
  };
  prompt._performValidation = function(name2, prop, against, schema, line, callback) {
    var numericInput, valid, msg;
    try {
      valid = validate(against, schema);
    } catch (err) {
      return line !== -1 ? callback(err) : false;
    }
    if (!valid.valid) {
      if (prop.schema.message) {
        logger.error(prop.schema.message);
      } else {
        msg = line !== -1 ? "Invalid input for " : "Invalid command-line input for ";
        if (prompt.colors) {
          logger.error(msg + colors.grey(name2));
        } else {
          logger.error(msg + name2);
        }
      }
      prompt.emit("invalid", prop, line);
    }
    return valid.valid;
  };
  prompt.addProperties = function(obj, properties, callback) {
    properties = properties.filter(function(prop) {
      return typeof obj[prop] === "undefined";
    });
    if (properties.length === 0) {
      return callback(null, obj);
    }
    prompt.get(properties, function(err, results) {
      if (err) {
        return callback(err);
      } else if (!results) {
        return callback(null, obj);
      }
      function putNested(obj2, path2, value2) {
        var last = obj2, key;
        while (path2.length > 1) {
          key = path2.shift();
          if (!last[key]) {
            last[key] = {};
          }
          last = last[key];
        }
        last[path2.shift()] = value2;
      }
      Object.keys(results).forEach(function(key) {
        putNested(obj, key.split("."), results[key]);
      });
      callback(null, obj);
    });
    return prompt;
  };
  prompt._remember = function(property, value2) {
    history.unshift({
      property,
      value: value2
    });
    if (history.length > prompt.memory) {
      history.splice(prompt.memory, history.length - prompt.memory);
    }
  };
});

// node_modules/any-base/src/converter.js
var require_converter = __commonJS((exports, module) => {
  var Converter = function(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
      throw new Error("Bad alphabet");
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
  };
  Converter.prototype.convert = function(number) {
    var i2, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = typeof number === "string" ? "" : [];
    if (!this.isValid(number)) {
      throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
    }
    if (this.srcAlphabet === this.dstAlphabet) {
      return number;
    }
    for (i2 = 0;i2 < length; i2++) {
      numberMap[i2] = this.srcAlphabet.indexOf(number[i2]);
    }
    do {
      divide = 0;
      newlen = 0;
      for (i2 = 0;i2 < length; i2++) {
        divide = divide * fromBase + numberMap[i2];
        if (divide >= toBase) {
          numberMap[newlen++] = parseInt(divide / toBase, 10);
          divide = divide % toBase;
        } else if (newlen > 0) {
          numberMap[newlen++] = 0;
        }
      }
      length = newlen;
      result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);
    return result;
  };
  Converter.prototype.isValid = function(number) {
    var i2 = 0;
    for (;i2 < number.length; ++i2) {
      if (this.srcAlphabet.indexOf(number[i2]) === -1) {
        return false;
      }
    }
    return true;
  };
  module.exports = Converter;
});

// node_modules/any-base/index.js
var require_any_base = __commonJS((exports, module) => {
  var anyBase = function(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    return function(number) {
      return converter.convert(number);
    };
  };
  var Converter = require_converter();
  anyBase.BIN = "01";
  anyBase.OCT = "01234567";
  anyBase.DEC = "0123456789";
  anyBase.HEX = "0123456789abcdef";
  module.exports = anyBase;
});

// node_modules/pixelmatch/index.js
var require_pixelmatch = __commonJS((exports, module) => {
  var pixelmatch = function(img1, img2, output, width, height, options) {
    if (!options)
      options = {};
    var threshold = options.threshold === undefined ? 0.1 : options.threshold;
    var maxDelta = 35215 * threshold * threshold, diff = 0;
    for (var y = 0;y < height; y++) {
      for (var x = 0;x < width; x++) {
        var pos = (y * width + x) * 4;
        var delta = colorDelta(img1, img2, pos, pos);
        if (delta > maxDelta) {
          if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
            if (output)
              drawPixel(output, pos, 255, 255, 0);
          } else {
            if (output)
              drawPixel(output, pos, 255, 0, 0);
            diff++;
          }
        } else if (output) {
          var val = blend(grayPixel(img1, pos), 0.1);
          drawPixel(output, pos, val, val, val);
        }
      }
    }
    return diff;
  };
  var antialiased = function(img, x1, y1, width, height, img2) {
    var x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = (y1 * width + x1) * 4, zeroes = 0, positives = 0, negatives = 0, min = 0, max = 0, minX, minY, maxX, maxY;
    for (var x = x0;x <= x2; x++) {
      for (var y = y0;y <= y2; y++) {
        if (x === x1 && y === y1)
          continue;
        var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
        if (delta === 0)
          zeroes++;
        else if (delta < 0)
          negatives++;
        else if (delta > 0)
          positives++;
        if (zeroes > 2)
          return false;
        if (!img2)
          continue;
        if (delta < min) {
          min = delta;
          minX = x;
          minY = y;
        }
        if (delta > max) {
          max = delta;
          maxX = x;
          maxY = y;
        }
      }
    }
    if (!img2)
      return true;
    if (negatives === 0 || positives === 0)
      return false;
    return !antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height);
  };
  var colorDelta = function(img1, img2, k, m, yOnly) {
    var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);
    if (yOnly)
      return y;
    var i2 = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
    return 0.5053 * y * y + 0.299 * i2 * i2 + 0.1957 * q * q;
  };
  var rgb2y = function(r, g, b) {
    return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
  };
  var rgb2i = function(r, g, b) {
    return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
  };
  var rgb2q = function(r, g, b) {
    return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
  };
  var blend = function(c, a) {
    return 255 + (c - 255) * a;
  };
  var drawPixel = function(output, pos, r, g, b) {
    output[pos + 0] = r;
    output[pos + 1] = g;
    output[pos + 2] = b;
    output[pos + 3] = 255;
  };
  var grayPixel = function(img, i2) {
    var a = img[i2 + 3] / 255, r = blend(img[i2 + 0], a), g = blend(img[i2 + 1], a), b = blend(img[i2 + 2], a);
    return rgb2y(r, g, b);
  };
  module.exports = pixelmatch;
});

// node_modules/strtok3/lib/FsPromise.js
var require_FsPromise = __commonJS((exports) => {
  async function stat(path2) {
    return new Promise((resolve2, reject2) => {
      fs.stat(path2, (err, stats) => {
        if (err)
          reject2(err);
        else
          resolve2(stats);
      });
    });
  }
  async function close(fd) {
    return new Promise((resolve2, reject2) => {
      fs.close(fd, (err) => {
        if (err)
          reject2(err);
        else
          resolve2();
      });
    });
  }
  async function open(path2, mode) {
    return new Promise((resolve2, reject2) => {
      fs.open(path2, mode, (err, fd) => {
        if (err)
          reject2(err);
        else
          resolve2(fd);
      });
    });
  }
  async function read(fd, buffer, offset, length, position) {
    return new Promise((resolve2, reject2) => {
      fs.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
        if (err)
          reject2(err);
        else
          resolve2({ bytesRead, buffer: _buffer });
      });
    });
  }
  async function writeFile(path2, data2) {
    return new Promise((resolve2, reject2) => {
      fs.writeFile(path2, data2, (err) => {
        if (err)
          reject2(err);
        else
          resolve2();
      });
    });
  }
  var writeFileSync2 = function(path2, data2) {
    fs.writeFileSync(path2, data2);
  };
  async function readFile(path2) {
    return new Promise((resolve2, reject2) => {
      fs.readFile(path2, (err, buffer) => {
        if (err)
          reject2(err);
        else
          resolve2(buffer);
      });
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readFile = exports.writeFileSync = exports.writeFile = exports.read = exports.open = exports.close = exports.stat = exports.createReadStream = exports.pathExists = undefined;
  var fs = import.meta.require("fs");
  exports.pathExists = fs.existsSync;
  exports.createReadStream = fs.createReadStream;
  exports.stat = stat;
  exports.close = close;
  exports.open = open;
  exports.read = read;
  exports.writeFile = writeFile;
  exports.writeFileSync = writeFileSync2;
  exports.readFile = readFile;
});

// node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndOfStreamError = exports.defaultMessages = undefined;
  exports.defaultMessages = "End-Of-Stream";

  class EndOfStreamError extends Error {
    constructor() {
      super(exports.defaultMessages);
    }
  }
  exports.EndOfStreamError = EndOfStreamError;
});

// node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = undefined;

  class Deferred {
    constructor() {
      this.resolve = () => null;
      this.reject = () => null;
      this.promise = new Promise((resolve2, reject2) => {
        this.reject = reject2;
        this.resolve = resolve2;
      });
    }
  }
  exports.Deferred = Deferred;
});

// node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = undefined;
  var EndOfFileStream_1 = require_EndOfFileStream();
  var Deferred_1 = require_Deferred();
  var EndOfFileStream_2 = require_EndOfFileStream();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_2.EndOfStreamError;
  } });
  var maxStreamReadSize = 1 * 1024 * 1024;

  class StreamReader {
    constructor(s) {
      this.s = s;
      this.deferred = null;
      this.endOfStream = false;
      this.peekQueue = [];
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError));
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    async peek(uint8Array, offset, length) {
      const bytesRead = await this.read(uint8Array, offset, length);
      this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
      return bytesRead;
    }
    async read(buffer, offset, length) {
      if (length === 0) {
        return 0;
      }
      if (this.peekQueue.length === 0 && this.endOfStream) {
        throw new EndOfFileStream_1.EndOfStreamError;
      }
      let remaining = length;
      let bytesRead = 0;
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop();
        if (!peekData)
          throw new Error("peekData should be defined");
        const lenCopy = Math.min(peekData.length, remaining);
        buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      while (remaining > 0 && !this.endOfStream) {
        const reqLen = Math.min(remaining, maxStreamReadSize);
        const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
        bytesRead += chunkLen;
        if (chunkLen < reqLen)
          break;
        remaining -= chunkLen;
      }
      return bytesRead;
    }
    async readFromStream(buffer, offset, length) {
      const readBuffer = this.s.read(length);
      if (readBuffer) {
        buffer.set(readBuffer, offset);
        return readBuffer.length;
      } else {
        const request = {
          buffer,
          offset,
          length,
          deferred: new Deferred_1.Deferred
        };
        this.deferred = request.deferred;
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
        return request.deferred.promise;
      }
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
  }
  exports.StreamReader = StreamReader;
});

// node_modules/peek-readable/lib/index.js
var require_lib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = undefined;
  var EndOfFileStream_1 = require_EndOfFileStream();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_1.EndOfStreamError;
  } });
  var StreamReader_1 = require_StreamReader();
  Object.defineProperty(exports, "StreamReader", { enumerable: true, get: function() {
    return StreamReader_1.StreamReader;
  } });
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractTokenizer = undefined;
  var peek_readable_1 = require_lib();

  class AbstractTokenizer {
    constructor(fileInfo) {
      this.position = 0;
      this.numBuffer = new Uint8Array(8);
      this.fileInfo = fileInfo ? fileInfo : {};
    }
    async readToken(token, position = this.position) {
      const uint8Array = Buffer.alloc(token.len);
      const len = await this.readBuffer(uint8Array, { position });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(uint8Array, 0);
    }
    async peekToken(token, position = this.position) {
      const uint8Array = Buffer.alloc(token.len);
      const len = await this.peekBuffer(uint8Array, { position });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(uint8Array, 0);
    }
    async readNumber(token) {
      const len = await this.readBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(this.numBuffer, 0);
    }
    async peekNumber(token) {
      const len = await this.peekBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(this.numBuffer, 0);
    }
    async ignore(length) {
      if (this.fileInfo.size !== undefined) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length > bytesLeft) {
          this.position += bytesLeft;
          return bytesLeft;
        }
      }
      this.position += length;
      return length;
    }
    async close() {
    }
    normalizeOptions(uint8Array, options) {
      if (options && options.position !== undefined && options.position < this.position) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (options) {
        return {
          mayBeLess: options.mayBeLess === true,
          offset: options.offset ? options.offset : 0,
          length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
          position: options.position ? options.position : this.position
        };
      }
      return {
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      };
    }
  }
  exports.AbstractTokenizer = AbstractTokenizer;
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadStreamTokenizer = undefined;
  var AbstractTokenizer_1 = require_AbstractTokenizer();
  var peek_readable_1 = require_lib();
  var maxBufferSize = 256000;

  class ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(stream2, fileInfo) {
      super(fileInfo);
      this.streamReader = new peek_readable_1.StreamReader(stream2);
    }
    async getFileInfo() {
      return this.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      } else if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
          return bytesRead - skipBytes;
        } else if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
        } catch (err) {
          if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
  }
  exports.ReadStreamTokenizer = ReadStreamTokenizer;
});

// node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferTokenizer = undefined;
  var peek_readable_1 = require_lib();
  var AbstractTokenizer_1 = require_AbstractTokenizer();

  class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(uint8Array, fileInfo) {
      super(fileInfo);
      this.uint8Array = uint8Array;
      this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
    }
    async readBuffer(uint8Array, options) {
      if (options && options.position) {
        if (options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      } else {
        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
        return bytes2read;
      }
    }
    async close() {
    }
  }
  exports.BufferTokenizer = BufferTokenizer;
});

// node_modules/strtok3/lib/core.js
var require_core = __commonJS((exports) => {
  var fromStream = function(stream2, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
  };
  var fromBuffer = function(uint8Array, fileInfo) {
    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = undefined;
  var ReadStreamTokenizer_1 = require_ReadStreamTokenizer();
  var BufferTokenizer_1 = require_BufferTokenizer();
  var peek_readable_1 = require_lib();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return peek_readable_1.EndOfStreamError;
  } });
  exports.fromStream = fromStream;
  exports.fromBuffer = fromBuffer;
});

// node_modules/strtok3/lib/FileTokenizer.js
var require_FileTokenizer = __commonJS((exports) => {
  async function fromFile(sourceFilePath) {
    const stat = await fs.stat(sourceFilePath);
    if (!stat.isFile) {
      throw new Error(`File not a file: ${sourceFilePath}`);
    }
    const fd = await fs.open(sourceFilePath, "r");
    return new FileTokenizer(fd, { path: sourceFilePath, size: stat.size });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromFile = exports.FileTokenizer = undefined;
  var AbstractTokenizer_1 = require_AbstractTokenizer();
  var peek_readable_1 = require_lib();
  var fs = require_FsPromise();

  class FileTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(fd, fileInfo) {
      super(fileInfo);
      this.fd = fd;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new peek_readable_1.EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      return fs.close(this.fd);
    }
  }
  exports.FileTokenizer = FileTokenizer;
  exports.fromFile = fromFile;
});

// node_modules/strtok3/lib/index.js
var require_lib2 = __commonJS((exports) => {
  async function fromStream(stream2, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    if (stream2.path) {
      const stat = await fs.stat(stream2.path);
      fileInfo.path = stream2.path;
      fileInfo.size = stat.size;
    }
    return core.fromStream(stream2, fileInfo);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromStream = exports.fromBuffer = exports.EndOfStreamError = exports.fromFile = undefined;
  var fs = require_FsPromise();
  var core = require_core();
  var FileTokenizer_1 = require_FileTokenizer();
  Object.defineProperty(exports, "fromFile", { enumerable: true, get: function() {
    return FileTokenizer_1.fromFile;
  } });
  var core_1 = require_core();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return core_1.EndOfStreamError;
  } });
  Object.defineProperty(exports, "fromBuffer", { enumerable: true, get: function() {
    return core_1.fromBuffer;
  } });
  exports.fromStream = fromStream;
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports) => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value2, offset, isLE, mLen, nBytes) {
    var e, m, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
    value2 = Math.abs(value2);
    if (isNaN(value2) || value2 === Infinity) {
      m = isNaN(value2) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value2) / Math.LN2);
      if (value2 * (c2 = Math.pow(2, -e)) < 1) {
        e--;
        c2 *= 2;
      }
      if (e + eBias >= 1) {
        value2 += rt / c2;
      } else {
        value2 += rt * Math.pow(2, 1 - eBias);
      }
      if (value2 * c2 >= 2) {
        e++;
        c2 /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value2 * c2 - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (;mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (;eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d] |= s * 128;
  };
});

// node_modules/token-types/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var dv = function(array) {
    return new DataView(array.buffer, array.byteOffset);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = undefined;
  var ieee754 = require_ieee754();
  exports.UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value2) {
      dv(array).setUint8(offset, value2);
      return offset + 1;
    }
  };
  exports.UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setUint16(offset, value2, true);
      return offset + 2;
    }
  };
  exports.UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value2) {
      dv(array).setUint16(offset, value2);
      return offset + 2;
    }
  };
  exports.UINT24_LE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put(array, offset, value2) {
      const dataView = dv(array);
      dataView.setUint8(offset, value2 & 255);
      dataView.setUint16(offset + 1, value2 >> 8, true);
      return offset + 3;
    }
  };
  exports.UINT24_BE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put(array, offset, value2) {
      const dataView = dv(array);
      dataView.setUint16(offset, value2 >> 8);
      dataView.setUint8(offset + 2, value2 & 255);
      return offset + 3;
    }
  };
  exports.UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setUint32(offset, value2, true);
      return offset + 4;
    }
  };
  exports.UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value2) {
      dv(array).setUint32(offset, value2);
      return offset + 4;
    }
  };
  exports.INT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getInt8(offset);
    },
    put(array, offset, value2) {
      dv(array).setInt8(offset, value2);
      return offset + 1;
    }
  };
  exports.INT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset);
    },
    put(array, offset, value2) {
      dv(array).setInt16(offset, value2);
      return offset + 2;
    }
  };
  exports.INT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setInt16(offset, value2, true);
      return offset + 2;
    }
  };
  exports.INT24_LE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_LE.get(array, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array, offset, value2) {
      const dataView = dv(array);
      dataView.setUint8(offset, value2 & 255);
      dataView.setUint16(offset + 1, value2 >> 8, true);
      return offset + 3;
    }
  };
  exports.INT24_BE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_BE.get(array, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array, offset, value2) {
      const dataView = dv(array);
      dataView.setUint16(offset, value2 >> 8);
      dataView.setUint8(offset + 2, value2 & 255);
      return offset + 3;
    }
  };
  exports.INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value2) {
      dv(array).setInt32(offset, value2);
      return offset + 4;
    }
  };
  exports.INT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setInt32(offset, value2, true);
      return offset + 4;
    }
  };
  exports.UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setBigUint64(offset, value2, true);
      return offset + 8;
    }
  };
  exports.INT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setBigInt64(offset, value2, true);
      return offset + 8;
    }
  };
  exports.UINT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset);
    },
    put(array, offset, value2) {
      dv(array).setBigUint64(offset, value2);
      return offset + 8;
    }
  };
  exports.INT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset);
    },
    put(array, offset, value2) {
      dv(array).setBigInt64(offset, value2);
      return offset + 8;
    }
  };
  exports.Float16_BE = {
    len: 2,
    get(dataView, offset) {
      return ieee754.read(dataView, offset, false, 10, this.len);
    },
    put(dataView, offset, value2) {
      ieee754.write(dataView, value2, offset, false, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float16_LE = {
    len: 2,
    get(array, offset) {
      return ieee754.read(array, offset, true, 10, this.len);
    },
    put(array, offset, value2) {
      ieee754.write(array, value2, offset, true, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset);
    },
    put(array, offset, value2) {
      dv(array).setFloat32(offset, value2);
      return offset + 4;
    }
  };
  exports.Float32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setFloat32(offset, value2, true);
      return offset + 4;
    }
  };
  exports.Float64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset);
    },
    put(array, offset, value2) {
      dv(array).setFloat64(offset, value2);
      return offset + 8;
    }
  };
  exports.Float64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setFloat64(offset, value2, true);
      return offset + 8;
    }
  };
  exports.Float80_BE = {
    len: 10,
    get(array, offset) {
      return ieee754.read(array, offset, false, 63, this.len);
    },
    put(array, offset, value2) {
      ieee754.write(array, value2, offset, false, 63, this.len);
      return offset + this.len;
    }
  };
  exports.Float80_LE = {
    len: 10,
    get(array, offset) {
      return ieee754.read(array, offset, true, 63, this.len);
    },
    put(array, offset, value2) {
      ieee754.write(array, value2, offset, true, 63, this.len);
      return offset + this.len;
    }
  };

  class IgnoreType {
    constructor(len) {
      this.len = len;
    }
    get(array, off) {
    }
  }
  exports.IgnoreType = IgnoreType;

  class Uint8ArrayType {
    constructor(len) {
      this.len = len;
    }
    get(array, offset) {
      return array.subarray(offset, offset + this.len);
    }
  }
  exports.Uint8ArrayType = Uint8ArrayType;

  class BufferType {
    constructor(len) {
      this.len = len;
    }
    get(uint8Array, off) {
      return Buffer.from(uint8Array.subarray(off, off + this.len));
    }
  }
  exports.BufferType = BufferType;

  class StringType {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(uint8Array, offset) {
      return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
  }
  exports.StringType = StringType;

  class AnsiStringType {
    constructor(len) {
      this.len = len;
    }
    static decode(buffer, offset, until) {
      let str = "";
      for (let i2 = offset;i2 < until; ++i2) {
        str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i2]));
      }
      return str;
    }
    static inRange(a, min, max) {
      return min <= a && a <= max;
    }
    static codePointToString(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      } else {
        cp -= 65536;
        return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
      }
    }
    static singleByteDecoder(bite) {
      if (AnsiStringType.inRange(bite, 0, 127)) {
        return bite;
      }
      const codePoint = AnsiStringType.windows1252[bite - 128];
      if (codePoint === null) {
        throw Error("invaliding encoding");
      }
      return codePoint;
    }
    get(buffer, offset = 0) {
      return AnsiStringType.decode(buffer, offset, offset + this.len);
    }
  }
  exports.AnsiStringType = AnsiStringType;
  AnsiStringType.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ];
});

// node_modules/file-type/util.js
var require_util = __commonJS((exports) => {
  exports.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
  exports.tarHeaderChecksumMatches = (buffer, offset = 0) => {
    const readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
    if (isNaN(readSum)) {
      return false;
    }
    let sum = 8 * 32;
    for (let i2 = offset;i2 < offset + 148; i2++) {
      sum += buffer[i2];
    }
    for (let i2 = offset + 156;i2 < offset + 512; i2++) {
      sum += buffer[i2];
    }
    return readSum === sum;
  };
  exports.uint32SyncSafeToken = {
    get: (buffer, offset) => {
      return buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
    },
    len: 4
  };
});

// node_modules/file-type/supported.js
var require_supported = __commonJS((exports, module) => {
  module.exports = {
    extensions: [
      "jpg",
      "png",
      "apng",
      "gif",
      "webp",
      "flif",
      "xcf",
      "cr2",
      "cr3",
      "orf",
      "arw",
      "dng",
      "nef",
      "rw2",
      "raf",
      "tif",
      "bmp",
      "icns",
      "jxr",
      "psd",
      "indd",
      "zip",
      "tar",
      "rar",
      "gz",
      "bz2",
      "7z",
      "dmg",
      "mp4",
      "mid",
      "mkv",
      "webm",
      "mov",
      "avi",
      "mpg",
      "mp2",
      "mp3",
      "m4a",
      "oga",
      "ogg",
      "ogv",
      "opus",
      "flac",
      "wav",
      "spx",
      "amr",
      "pdf",
      "epub",
      "exe",
      "swf",
      "rtf",
      "wasm",
      "woff",
      "woff2",
      "eot",
      "ttf",
      "otf",
      "ico",
      "flv",
      "ps",
      "xz",
      "sqlite",
      "nes",
      "crx",
      "xpi",
      "cab",
      "deb",
      "ar",
      "rpm",
      "Z",
      "lz",
      "cfb",
      "mxf",
      "mts",
      "blend",
      "bpg",
      "docx",
      "pptx",
      "xlsx",
      "3gp",
      "3g2",
      "jp2",
      "jpm",
      "jpx",
      "mj2",
      "aif",
      "qcp",
      "odt",
      "ods",
      "odp",
      "xml",
      "mobi",
      "heic",
      "cur",
      "ktx",
      "ape",
      "wv",
      "dcm",
      "ics",
      "glb",
      "pcap",
      "dsf",
      "lnk",
      "alias",
      "voc",
      "ac3",
      "m4v",
      "m4p",
      "m4b",
      "f4v",
      "f4p",
      "f4b",
      "f4a",
      "mie",
      "asf",
      "ogm",
      "ogx",
      "mpc",
      "arrow",
      "shp",
      "aac",
      "mp1",
      "it",
      "s3m",
      "xm",
      "ai",
      "skp",
      "avif",
      "eps",
      "lzh",
      "pgp",
      "asar",
      "stl",
      "chm",
      "3mf",
      "zst",
      "jxl",
      "vcf"
    ],
    mimeTypes: [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/flif",
      "image/x-xcf",
      "image/x-canon-cr2",
      "image/x-canon-cr3",
      "image/tiff",
      "image/bmp",
      "image/vnd.ms-photo",
      "image/vnd.adobe.photoshop",
      "application/x-indesign",
      "application/epub+zip",
      "application/x-xpinstall",
      "application/vnd.oasis.opendocument.text",
      "application/vnd.oasis.opendocument.spreadsheet",
      "application/vnd.oasis.opendocument.presentation",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/zip",
      "application/x-tar",
      "application/x-rar-compressed",
      "application/gzip",
      "application/x-bzip2",
      "application/x-7z-compressed",
      "application/x-apple-diskimage",
      "application/x-apache-arrow",
      "video/mp4",
      "audio/midi",
      "video/x-matroska",
      "video/webm",
      "video/quicktime",
      "video/vnd.avi",
      "audio/vnd.wave",
      "audio/qcelp",
      "audio/x-ms-asf",
      "video/x-ms-asf",
      "application/vnd.ms-asf",
      "video/mpeg",
      "video/3gpp",
      "audio/mpeg",
      "audio/mp4",
      "audio/opus",
      "video/ogg",
      "audio/ogg",
      "application/ogg",
      "audio/x-flac",
      "audio/ape",
      "audio/wavpack",
      "audio/amr",
      "application/pdf",
      "application/x-msdownload",
      "application/x-shockwave-flash",
      "application/rtf",
      "application/wasm",
      "font/woff",
      "font/woff2",
      "application/vnd.ms-fontobject",
      "font/ttf",
      "font/otf",
      "image/x-icon",
      "video/x-flv",
      "application/postscript",
      "application/eps",
      "application/x-xz",
      "application/x-sqlite3",
      "application/x-nintendo-nes-rom",
      "application/x-google-chrome-extension",
      "application/vnd.ms-cab-compressed",
      "application/x-deb",
      "application/x-unix-archive",
      "application/x-rpm",
      "application/x-compress",
      "application/x-lzip",
      "application/x-cfb",
      "application/x-mie",
      "application/mxf",
      "video/mp2t",
      "application/x-blender",
      "image/bpg",
      "image/jp2",
      "image/jpx",
      "image/jpm",
      "image/mj2",
      "audio/aiff",
      "application/xml",
      "application/x-mobipocket-ebook",
      "image/heif",
      "image/heif-sequence",
      "image/heic",
      "image/heic-sequence",
      "image/icns",
      "image/ktx",
      "application/dicom",
      "audio/x-musepack",
      "text/calendar",
      "text/vcard",
      "model/gltf-binary",
      "application/vnd.tcpdump.pcap",
      "audio/x-dsf",
      "application/x.ms.shortcut",
      "application/x.apple.alias",
      "audio/x-voc",
      "audio/vnd.dolby.dd-raw",
      "audio/x-m4a",
      "image/apng",
      "image/x-olympus-orf",
      "image/x-sony-arw",
      "image/x-adobe-dng",
      "image/x-nikon-nef",
      "image/x-panasonic-rw2",
      "image/x-fujifilm-raf",
      "video/x-m4v",
      "video/3gpp2",
      "application/x-esri-shape",
      "audio/aac",
      "audio/x-it",
      "audio/x-s3m",
      "audio/x-xm",
      "video/MP1S",
      "video/MP2P",
      "application/vnd.sketchup.skp",
      "image/avif",
      "application/x-lzh-compressed",
      "application/pgp-encrypted",
      "application/x-asar",
      "model/stl",
      "application/vnd.ms-htmlhelp",
      "model/3mf",
      "image/jxl",
      "application/zstd"
    ]
  };
});

// node_modules/file-type/core.js
var require_core2 = __commonJS((exports, module) => {
  async function fromStream(stream3) {
    const tokenizer = await strtok3.fromStream(stream3);
    try {
      return await fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async function fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Buffer ? input : Buffer.from(input);
    if (!(buffer && buffer.length > 1)) {
      return;
    }
    const tokenizer = strtok3.fromBuffer(buffer);
    return fromTokenizer(tokenizer);
  }
  var _check = function(buffer, headers, options) {
    options = {
      offset: 0,
      ...options
    };
    for (const [index, header] of headers.entries()) {
      if (options.mask) {
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
    return true;
  };
  async function fromTokenizer(tokenizer) {
    try {
      return _fromTokenizer(tokenizer);
    } catch (error) {
      if (!(error instanceof strtok3.EndOfStreamError)) {
        throw error;
      }
    }
  }
  async function _fromTokenizer(tokenizer) {
    let buffer = Buffer.alloc(minimumBytes);
    const bytesRead = 12;
    const check = (header, options) => _check(buffer, header, options);
    const checkString = (header, options) => check(stringToBytes(header), options);
    if (!tokenizer.fileInfo.size) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: true });
    if (check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (check([37, 33])) {
      await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: true });
      if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (check([31, 160]) || check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (check([255, 216, 255])) {
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLen);
      return fromTokenizer(tokenizer);
    }
    if (checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (checkString("WEBP", { offset: 8 })) {
      return {
        ext: "webp",
        mime: "image/webp"
      };
    }
    if (checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (check([80, 75, 3, 4])) {
      try {
        while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
          await tokenizer.readBuffer(buffer, { length: 30 });
          const zipHeader = {
            compressedSize: buffer.readUInt32LE(18),
            uncompressedSize: buffer.readUInt32LE(22),
            filenameLength: buffer.readUInt16LE(26),
            extraFieldLength: buffer.readUInt16LE(28)
          };
          zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
          await tokenizer.ignore(zipHeader.extraFieldLength);
          if (zipHeader.filename === "META-INF/mozilla.rsa") {
            return {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
          }
          if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
            const type = zipHeader.filename.split("/")[0];
            switch (type) {
              case "_rels":
                break;
              case "word":
                return {
                  ext: "docx",
                  mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                };
              case "ppt":
                return {
                  ext: "pptx",
                  mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                };
              case "xl":
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              default:
                break;
            }
          }
          if (zipHeader.filename.startsWith("xl/")) {
            return {
              ext: "xlsx",
              mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            };
          }
          if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
            return {
              ext: "3mf",
              mime: "model/3mf"
            };
          }
          if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
            const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
            switch (mimeType) {
              case "application/epub+zip":
                return {
                  ext: "epub",
                  mime: "application/epub+zip"
                };
              case "application/vnd.oasis.opendocument.text":
                return {
                  ext: "odt",
                  mime: "application/vnd.oasis.opendocument.text"
                };
              case "application/vnd.oasis.opendocument.spreadsheet":
                return {
                  ext: "ods",
                  mime: "application/vnd.oasis.opendocument.spreadsheet"
                };
              case "application/vnd.oasis.opendocument.presentation":
                return {
                  ext: "odp",
                  mime: "application/vnd.oasis.opendocument.presentation"
                };
              default:
            }
          }
          if (zipHeader.compressedSize === 0) {
            let nextHeaderIndex = -1;
            while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
              await tokenizer.peekBuffer(buffer, { mayBeLess: true });
              nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex");
              await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
            }
          } else {
            await tokenizer.ignore(zipHeader.compressedSize);
          }
        }
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError)) {
          throw error;
        }
      }
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = Buffer.alloc(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (checkString("ftyp", { offset: 4 }) && (buffer[8] & 96) !== 0) {
      const brandMajor = buffer.toString("binary", 8, 12).replace("\0", " ").trim();
      switch (brandMajor) {
        case "avif":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (checkString("%PDF")) {
      await tokenizer.ignore(1350);
      const maxBufferSize = 10 * 1024 * 1024;
      const buffer2 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
      await tokenizer.readBuffer(buffer2, { mayBeLess: true });
      if (buffer2.includes(Buffer.from("AIPrivateData"))) {
        return {
          ext: "ai",
          mime: "application/postscript"
        };
      }
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (check([73, 73, 42, 0])) {
      if (checkString("CR", { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 })) {
        return {
          ext: "nef",
          mime: "image/x-nikon-nef"
        };
      }
      if (check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 }))) {
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      }
      buffer = Buffer.alloc(24);
      await tokenizer.peekBuffer(buffer);
      if ((check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      }
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (check([77, 77, 0, 42])) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(Token.UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = Buffer.alloc(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const id = await readField();
        const lenField = await readField();
        lenField[0] ^= 128 >> lenField.length - 1;
        const nrLen = Math.min(6, lenField.length);
        return {
          id: id.readUIntBE(0, id.length),
          len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
        };
      }
      async function readChildren(level, children2) {
        while (children2 > 0) {
          const e = await readElement();
          if (e.id === 17026) {
            return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
          }
          await tokenizer.ignore(e.len);
          --children2;
        }
      }
      const re = await readElement();
      const docType = await readChildren(1, re.len);
      switch (docType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/x-matroska"
          };
        default:
          return;
      }
    }
    if (check([82, 73, 70, 70])) {
      if (check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/vnd.wave"
        };
      }
      if (check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (checkString("MSCF") || checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (check([0, 0, 1, 186])) {
      if (check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const str = await tokenizer.readToken(new Token.StringType(13, "ascii"));
      if (str === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(Token.INT32_BE),
          type: await tokenizer.readToken(new Token.StringType(4, "binary"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/x-apache-arrow"
      };
    }
    if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (check([102, 114, 101, 101], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([109, 111, 111, 118], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = Buffer.alloc(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(Token.UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = Buffer.alloc(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new Token.StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (checkString("BEGIN:")) {
      if (checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (check([4, 0, 0, 0]) && buffer.length >= 16) {
      const jsonSize = buffer.readUInt32LE(12);
      if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
        try {
          const header = buffer.slice(16, jsonSize + 16).toString();
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch (_) {
        }
      }
    }
    if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (tarHeaderChecksumMatches(buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
      return {
        ext: "skp",
        mime: "application/vnd.sketchup.skp"
      };
    }
    if (checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
    if (buffer.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
      if (check([16], { offset: 1, mask: [22] })) {
        if (check([8], { offset: 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (check([2], { offset: 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([4], { offset: 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (check([6], { offset: 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
  var Token = require_lib3();
  var strtok3 = require_core();
  var {
    stringToBytes,
    tarHeaderChecksumMatches,
    uint32SyncSafeToken
  } = require_util();
  var supported = require_supported();
  var minimumBytes = 4100;
  var stream2 = (readableStream) => new Promise((resolve, reject) => {
    const stream = eval("require")("stream");
    readableStream.on("error", reject);
    readableStream.once("readable", async () => {
      const pass = new stream.PassThrough;
      let outputStream;
      if (stream.pipeline) {
        outputStream = stream.pipeline(readableStream, pass, () => {
        });
      } else {
        outputStream = readableStream.pipe(pass);
      }
      const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
      try {
        const fileType2 = await fromBuffer(chunk);
        pass.fileType = fileType2;
      } catch (error) {
        reject(error);
      }
      resolve(outputStream);
    });
  });
  var fileType = {
    fromStream,
    fromTokenizer,
    fromBuffer,
    stream: stream2
  };
  Object.defineProperty(fileType, "extensions", {
    get() {
      return new Set(supported.extensions);
    }
  });
  Object.defineProperty(fileType, "mimeTypes", {
    get() {
      return new Set(supported.mimeTypes);
    }
  });
  module.exports = fileType;
});

// node_modules/file-type/index.js
var require_file_type = __commonJS((exports, module) => {
  async function fromFile(path2) {
    const tokenizer = await strtok3.fromFile(path2);
    try {
      return await core.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  var strtok3 = require_lib2();
  var core = require_core2();
  var fileType = {
    fromFile
  };
  Object.assign(fileType, core);
  Object.defineProperty(fileType, "extensions", {
    get() {
      return core.extensions;
    }
  });
  Object.defineProperty(fileType, "mimeTypes", {
    get() {
      return core.mimeTypes;
    }
  });
  module.exports = fileType;
});

// node_modules/exif-parser/lib/jpeg.js
var require_jpeg = __commonJS((exports, module) => {
  module.exports = {
    parseSections: function(stream2, iterator) {
      var len, markerType;
      stream2.setBigEndian(true);
      while (stream2.remainingLength() > 0 && markerType !== 218) {
        if (stream2.nextUInt8() !== 255) {
          throw new Error("Invalid JPEG section offset");
        }
        markerType = stream2.nextUInt8();
        if (markerType >= 208 && markerType <= 217 || markerType === 218) {
          len = 0;
        } else {
          len = stream2.nextUInt16() - 2;
        }
        iterator(markerType, stream2.branch(0, len));
        stream2.skip(len);
      }
    },
    getSizeFromSOFSection: function(stream2) {
      stream2.skip(1);
      return {
        height: stream2.nextUInt16(),
        width: stream2.nextUInt16()
      };
    },
    getSectionName: function(markerType) {
      var name2, index;
      switch (markerType) {
        case 216:
          name2 = "SOI";
          break;
        case 196:
          name2 = "DHT";
          break;
        case 219:
          name2 = "DQT";
          break;
        case 221:
          name2 = "DRI";
          break;
        case 218:
          name2 = "SOS";
          break;
        case 254:
          name2 = "COM";
          break;
        case 217:
          name2 = "EOI";
          break;
        default:
          if (markerType >= 224 && markerType <= 239) {
            name2 = "APP";
            index = markerType - 224;
          } else if (markerType >= 192 && markerType <= 207 && markerType !== 196 && markerType !== 200 && markerType !== 204) {
            name2 = "SOF";
            index = markerType - 192;
          } else if (markerType >= 208 && markerType <= 215) {
            name2 = "RST";
            index = markerType - 208;
          }
          break;
      }
      var nameStruct = {
        name: name2
      };
      if (typeof index === "number") {
        nameStruct.index = index;
      }
      return nameStruct;
    }
  };
});

// node_modules/exif-parser/lib/exif.js
var require_exif = __commonJS((exports, module) => {
  var readExifValue = function(format, stream2) {
    switch (format) {
      case 1:
        return stream2.nextUInt8();
      case 3:
        return stream2.nextUInt16();
      case 4:
        return stream2.nextUInt32();
      case 5:
        return [stream2.nextUInt32(), stream2.nextUInt32()];
      case 6:
        return stream2.nextInt8();
      case 8:
        return stream2.nextUInt16();
      case 9:
        return stream2.nextUInt32();
      case 10:
        return [stream2.nextInt32(), stream2.nextInt32()];
      case 11:
        return stream2.nextFloat();
      case 12:
        return stream2.nextDouble();
      default:
        throw new Error("Invalid format while decoding: " + format);
    }
  };
  var getBytesPerComponent = function(format) {
    switch (format) {
      case 1:
      case 2:
      case 6:
      case 7:
        return 1;
      case 3:
      case 8:
        return 2;
      case 4:
      case 9:
      case 11:
        return 4;
      case 5:
      case 10:
      case 12:
        return 8;
      default:
        return 0;
    }
  };
  var readExifTag = function(tiffMarker, stream2) {
    var tagType = stream2.nextUInt16(), format = stream2.nextUInt16(), bytesPerComponent = getBytesPerComponent(format), components = stream2.nextUInt32(), valueBytes = bytesPerComponent * components, values, value2, c2;
    if (valueBytes > 4) {
      stream2 = tiffMarker.openWithOffset(stream2.nextUInt32());
    }
    if (format === 2) {
      values = stream2.nextString(components);
      var lastNull = values.indexOf("\0");
      if (lastNull !== -1) {
        values = values.substr(0, lastNull);
      }
    } else if (format === 7) {
      values = stream2.nextBuffer(components);
    } else if (format !== 0) {
      values = [];
      for (c2 = 0;c2 < components; ++c2) {
        values.push(readExifValue(format, stream2));
      }
    }
    if (valueBytes < 4) {
      stream2.skip(4 - valueBytes);
    }
    return [tagType, values, format];
  };
  var readIFDSection = function(tiffMarker, stream2, iterator) {
    var numberOfEntries = stream2.nextUInt16(), tag, i2;
    for (i2 = 0;i2 < numberOfEntries; ++i2) {
      tag = readExifTag(tiffMarker, stream2);
      iterator(tag[0], tag[1], tag[2]);
    }
  };
  var readHeader = function(stream2) {
    var exifHeader = stream2.nextString(6);
    if (exifHeader !== "Exif\0\0") {
      throw new Error("Invalid EXIF header");
    }
    var tiffMarker = stream2.mark();
    var tiffHeader = stream2.nextUInt16();
    if (tiffHeader === 18761) {
      stream2.setBigEndian(false);
    } else if (tiffHeader === 19789) {
      stream2.setBigEndian(true);
    } else {
      throw new Error("Invalid TIFF header");
    }
    if (stream2.nextUInt16() !== 42) {
      throw new Error("Invalid TIFF data");
    }
    return tiffMarker;
  };
  module.exports = {
    IFD0: 1,
    IFD1: 2,
    GPSIFD: 3,
    SubIFD: 4,
    InteropIFD: 5,
    parseTags: function(stream2, iterator) {
      var tiffMarker;
      try {
        tiffMarker = readHeader(stream2);
      } catch (e) {
        return false;
      }
      var subIfdOffset, gpsOffset, interopOffset;
      var ifd0Stream = tiffMarker.openWithOffset(stream2.nextUInt32()), IFD0 = this.IFD0;
      readIFDSection(tiffMarker, ifd0Stream, function(tagType, value2, format) {
        switch (tagType) {
          case 34853:
            gpsOffset = value2[0];
            break;
          case 34665:
            subIfdOffset = value2[0];
            break;
          default:
            iterator(IFD0, tagType, value2, format);
            break;
        }
      });
      var ifd1Offset = ifd0Stream.nextUInt32();
      if (ifd1Offset !== 0) {
        var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
        readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
      }
      if (gpsOffset) {
        var gpsStream = tiffMarker.openWithOffset(gpsOffset);
        readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
      }
      if (subIfdOffset) {
        var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
        readIFDSection(tiffMarker, subIfdStream, function(tagType, value2, format) {
          if (tagType === 40965) {
            interopOffset = value2[0];
          } else {
            iterator(InteropIFD, tagType, value2, format);
          }
        });
      }
      if (interopOffset) {
        var interopStream = tiffMarker.openWithOffset(interopOffset);
        readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
      }
      return true;
    }
  };
});

// node_modules/exif-parser/lib/date.js
var require_date = __commonJS((exports, module) => {
  var parseNumber = function(s) {
    return parseInt(s, 10);
  };
  var parseDateTimeParts = function(dateParts, timeParts) {
    dateParts = dateParts.map(parseNumber);
    timeParts = timeParts.map(parseNumber);
    var year = dateParts[0];
    var month = dateParts[1] - 1;
    var day = dateParts[2];
    var hours2 = timeParts[0];
    var minutes2 = timeParts[1];
    var seconds = timeParts[2];
    var date = Date.UTC(year, month, day, hours2, minutes2, seconds, 0);
    var timestamp = date / 1000;
    return timestamp;
  };
  var parseDateWithTimezoneFormat = function(dateTimeStr) {
    var dateParts = dateTimeStr.substr(0, 10).split("-");
    var timeParts = dateTimeStr.substr(11, 8).split(":");
    var timezoneStr = dateTimeStr.substr(19, 6);
    var timezoneParts = timezoneStr.split(":").map(parseNumber);
    var timezoneOffset = timezoneParts[0] * hours + timezoneParts[1] * minutes;
    var timestamp = parseDateTimeParts(dateParts, timeParts);
    timestamp -= timezoneOffset;
    if (typeof timestamp === "number" && !isNaN(timestamp)) {
      return timestamp;
    }
  };
  var parseDateWithSpecFormat = function(dateTimeStr) {
    var parts = dateTimeStr.split(" "), dateParts = parts[0].split(":"), timeParts = parts[1].split(":");
    var timestamp = parseDateTimeParts(dateParts, timeParts);
    if (typeof timestamp === "number" && !isNaN(timestamp)) {
      return timestamp;
    }
  };
  var parseExifDate = function(dateTimeStr) {
    var isSpecFormat = dateTimeStr.length === 19 && dateTimeStr.charAt(4) === ":";
    var isTimezoneFormat = dateTimeStr.length === 25 && dateTimeStr.charAt(10) === "T";
    var timestamp;
    if (isTimezoneFormat) {
      return parseDateWithTimezoneFormat(dateTimeStr);
    } else if (isSpecFormat) {
      return parseDateWithSpecFormat(dateTimeStr);
    }
  };
  var hours = 3600;
  var minutes = 60;
  module.exports = {
    parseDateWithSpecFormat,
    parseDateWithTimezoneFormat,
    parseExifDate
  };
});

// node_modules/exif-parser/lib/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var exif = require_exif();
  var date = require_date();
  var degreeTags = [
    {
      section: exif.GPSIFD,
      type: 2,
      name: "GPSLatitude",
      refType: 1,
      refName: "GPSLatitudeRef",
      posVal: "N"
    },
    {
      section: exif.GPSIFD,
      type: 4,
      name: "GPSLongitude",
      refType: 3,
      refName: "GPSLongitudeRef",
      posVal: "E"
    }
  ];
  var dateTags = [
    {
      section: exif.SubIFD,
      type: 306,
      name: "ModifyDate"
    },
    {
      section: exif.SubIFD,
      type: 36867,
      name: "DateTimeOriginal"
    },
    {
      section: exif.SubIFD,
      type: 36868,
      name: "CreateDate"
    },
    {
      section: exif.SubIFD,
      type: 306,
      name: "ModifyDate"
    }
  ];
  module.exports = {
    castDegreeValues: function(getTagValue, setTagValue) {
      degreeTags.forEach(function(t) {
        var degreeVal = getTagValue(t);
        if (degreeVal) {
          var degreeRef = getTagValue({ section: t.section, type: t.refType, name: t.refName });
          var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
          var degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
          setTagValue(t, degree);
        }
      });
    },
    castDateValues: function(getTagValue, setTagValue) {
      dateTags.forEach(function(t) {
        var dateStrVal = getTagValue(t);
        if (dateStrVal) {
          var timestamp = date.parseExifDate(dateStrVal);
          if (typeof timestamp !== "undefined") {
            setTagValue(t, timestamp);
          }
        }
      });
    },
    simplifyValue: function(values, format) {
      if (Array.isArray(values)) {
        values = values.map(function(value2) {
          if (format === 10 || format === 5) {
            return value2[0] / value2[1];
          }
          return value2;
        });
        if (values.length === 1) {
          values = values[0];
        }
      }
      return values;
    }
  };
});

// node_modules/exif-parser/lib/exif-tags.js
var require_exif_tags = __commonJS((exports, module) => {
  module.exports = {
    exif: {
      1: "InteropIndex",
      2: "InteropVersion",
      11: "ProcessingSoftware",
      254: "SubfileType",
      255: "OldSubfileType",
      256: "ImageWidth",
      257: "ImageHeight",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      263: "Thresholding",
      264: "CellWidth",
      265: "CellLength",
      266: "FillOrder",
      269: "DocumentName",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      273: "StripOffsets",
      274: "Orientation",
      277: "SamplesPerPixel",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      280: "MinSampleValue",
      281: "MaxSampleValue",
      282: "XResolution",
      283: "YResolution",
      284: "PlanarConfiguration",
      285: "PageName",
      286: "XPosition",
      287: "YPosition",
      288: "FreeOffsets",
      289: "FreeByteCounts",
      290: "GrayResponseUnit",
      291: "GrayResponseCurve",
      292: "T4Options",
      293: "T6Options",
      296: "ResolutionUnit",
      297: "PageNumber",
      300: "ColorResponseUnit",
      301: "TransferFunction",
      305: "Software",
      306: "ModifyDate",
      315: "Artist",
      316: "HostComputer",
      317: "Predictor",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      320: "ColorMap",
      321: "HalftoneHints",
      322: "TileWidth",
      323: "TileLength",
      324: "TileOffsets",
      325: "TileByteCounts",
      326: "BadFaxLines",
      327: "CleanFaxData",
      328: "ConsecutiveBadFaxLines",
      330: "SubIFD",
      332: "InkSet",
      333: "InkNames",
      334: "NumberofInks",
      336: "DotRange",
      337: "TargetPrinter",
      338: "ExtraSamples",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      342: "TransferRange",
      343: "ClipPath",
      344: "XClipPathUnits",
      345: "YClipPathUnits",
      346: "Indexed",
      347: "JPEGTables",
      351: "OPIProxy",
      400: "GlobalParametersIFD",
      401: "ProfileType",
      402: "FaxProfile",
      403: "CodingMethods",
      404: "VersionYear",
      405: "ModeNumber",
      433: "Decode",
      434: "DefaultImageColor",
      435: "T82Options",
      437: "JPEGTables",
      512: "JPEGProc",
      513: "ThumbnailOffset",
      514: "ThumbnailLength",
      515: "JPEGRestartInterval",
      517: "JPEGLosslessPredictors",
      518: "JPEGPointTransforms",
      519: "JPEGQTables",
      520: "JPEGDCTables",
      521: "JPEGACTables",
      529: "YCbCrCoefficients",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      532: "ReferenceBlackWhite",
      559: "StripRowCounts",
      700: "ApplicationNotes",
      999: "USPTOMiscellaneous",
      4096: "RelatedImageFileFormat",
      4097: "RelatedImageWidth",
      4098: "RelatedImageHeight",
      18246: "Rating",
      18247: "XP_DIP_XML",
      18248: "StitchInfo",
      18249: "RatingPercent",
      32781: "ImageID",
      32931: "WangTag1",
      32932: "WangAnnotation",
      32933: "WangTag3",
      32934: "WangTag4",
      32995: "Matteing",
      32996: "DataType",
      32997: "ImageDepth",
      32998: "TileDepth",
      33405: "Model2",
      33421: "CFARepeatPatternDim",
      33422: "CFAPattern2",
      33423: "BatteryLevel",
      33424: "KodakIFD",
      33432: "Copyright",
      33434: "ExposureTime",
      33437: "FNumber",
      33445: "MDFileTag",
      33446: "MDScalePixel",
      33447: "MDColorTable",
      33448: "MDLabName",
      33449: "MDSampleInfo",
      33450: "MDPrepDate",
      33451: "MDPrepTime",
      33452: "MDFileUnits",
      33550: "PixelScale",
      33589: "AdventScale",
      33590: "AdventRevision",
      33628: "UIC1Tag",
      33629: "UIC2Tag",
      33630: "UIC3Tag",
      33631: "UIC4Tag",
      33723: "IPTC-NAA",
      33918: "IntergraphPacketData",
      33919: "IntergraphFlagRegisters",
      33920: "IntergraphMatrix",
      33921: "INGRReserved",
      33922: "ModelTiePoint",
      34016: "Site",
      34017: "ColorSequence",
      34018: "IT8Header",
      34019: "RasterPadding",
      34020: "BitsPerRunLength",
      34021: "BitsPerExtendedRunLength",
      34022: "ColorTable",
      34023: "ImageColorIndicator",
      34024: "BackgroundColorIndicator",
      34025: "ImageColorValue",
      34026: "BackgroundColorValue",
      34027: "PixelIntensityRange",
      34028: "TransparencyIndicator",
      34029: "ColorCharacterization",
      34030: "HCUsage",
      34031: "TrapIndicator",
      34032: "CMYKEquivalent",
      34118: "SEMInfo",
      34152: "AFCP_IPTC",
      34232: "PixelMagicJBIGOptions",
      34264: "ModelTransform",
      34306: "WB_GRGBLevels",
      34310: "LeafData",
      34377: "PhotoshopSettings",
      34665: "ExifOffset",
      34675: "ICC_Profile",
      34687: "TIFF_FXExtensions",
      34688: "MultiProfiles",
      34689: "SharedData",
      34690: "T88Options",
      34732: "ImageLayer",
      34735: "GeoTiffDirectory",
      34736: "GeoTiffDoubleParams",
      34737: "GeoTiffAsciiParams",
      34850: "ExposureProgram",
      34852: "SpectralSensitivity",
      34853: "GPSInfo",
      34855: "ISO",
      34856: "Opto-ElectricConvFactor",
      34857: "Interlace",
      34858: "TimeZoneOffset",
      34859: "SelfTimerMode",
      34864: "SensitivityType",
      34865: "StandardOutputSensitivity",
      34866: "RecommendedExposureIndex",
      34867: "ISOSpeed",
      34868: "ISOSpeedLatitudeyyy",
      34869: "ISOSpeedLatitudezzz",
      34908: "FaxRecvParams",
      34909: "FaxSubAddress",
      34910: "FaxRecvTime",
      34954: "LeafSubIFD",
      36864: "ExifVersion",
      36867: "DateTimeOriginal",
      36868: "CreateDate",
      37121: "ComponentsConfiguration",
      37122: "CompressedBitsPerPixel",
      37377: "ShutterSpeedValue",
      37378: "ApertureValue",
      37379: "BrightnessValue",
      37380: "ExposureCompensation",
      37381: "MaxApertureValue",
      37382: "SubjectDistance",
      37383: "MeteringMode",
      37384: "LightSource",
      37385: "Flash",
      37386: "FocalLength",
      37387: "FlashEnergy",
      37388: "SpatialFrequencyResponse",
      37389: "Noise",
      37390: "FocalPlaneXResolution",
      37391: "FocalPlaneYResolution",
      37392: "FocalPlaneResolutionUnit",
      37393: "ImageNumber",
      37394: "SecurityClassification",
      37395: "ImageHistory",
      37396: "SubjectArea",
      37397: "ExposureIndex",
      37398: "TIFF-EPStandardID",
      37399: "SensingMethod",
      37434: "CIP3DataFile",
      37435: "CIP3Sheet",
      37436: "CIP3Side",
      37439: "StoNits",
      37500: "MakerNote",
      37510: "UserComment",
      37520: "SubSecTime",
      37521: "SubSecTimeOriginal",
      37522: "SubSecTimeDigitized",
      37679: "MSDocumentText",
      37680: "MSPropertySetStorage",
      37681: "MSDocumentTextPosition",
      37724: "ImageSourceData",
      40091: "XPTitle",
      40092: "XPComment",
      40093: "XPAuthor",
      40094: "XPKeywords",
      40095: "XPSubject",
      40960: "FlashpixVersion",
      40961: "ColorSpace",
      40962: "ExifImageWidth",
      40963: "ExifImageHeight",
      40964: "RelatedSoundFile",
      40965: "InteropOffset",
      41483: "FlashEnergy",
      41484: "SpatialFrequencyResponse",
      41485: "Noise",
      41486: "FocalPlaneXResolution",
      41487: "FocalPlaneYResolution",
      41488: "FocalPlaneResolutionUnit",
      41489: "ImageNumber",
      41490: "SecurityClassification",
      41491: "ImageHistory",
      41492: "SubjectLocation",
      41493: "ExposureIndex",
      41494: "TIFF-EPStandardID",
      41495: "SensingMethod",
      41728: "FileSource",
      41729: "SceneType",
      41730: "CFAPattern",
      41985: "CustomRendered",
      41986: "ExposureMode",
      41987: "WhiteBalance",
      41988: "DigitalZoomRatio",
      41989: "FocalLengthIn35mmFormat",
      41990: "SceneCaptureType",
      41991: "GainControl",
      41992: "Contrast",
      41993: "Saturation",
      41994: "Sharpness",
      41995: "DeviceSettingDescription",
      41996: "SubjectDistanceRange",
      42016: "ImageUniqueID",
      42032: "OwnerName",
      42033: "SerialNumber",
      42034: "LensInfo",
      42035: "LensMake",
      42036: "LensModel",
      42037: "LensSerialNumber",
      42112: "GDALMetadata",
      42113: "GDALNoData",
      42240: "Gamma",
      44992: "ExpandSoftware",
      44993: "ExpandLens",
      44994: "ExpandFilm",
      44995: "ExpandFilterLens",
      44996: "ExpandScanner",
      44997: "ExpandFlashLamp",
      48129: "PixelFormat",
      48130: "Transformation",
      48131: "Uncompressed",
      48132: "ImageType",
      48256: "ImageWidth",
      48257: "ImageHeight",
      48258: "WidthResolution",
      48259: "HeightResolution",
      48320: "ImageOffset",
      48321: "ImageByteCount",
      48322: "AlphaOffset",
      48323: "AlphaByteCount",
      48324: "ImageDataDiscard",
      48325: "AlphaDataDiscard",
      50215: "OceScanjobDesc",
      50216: "OceApplicationSelector",
      50217: "OceIDNumber",
      50218: "OceImageLogic",
      50255: "Annotations",
      50341: "PrintIM",
      50560: "USPTOOriginalContentType",
      50706: "DNGVersion",
      50707: "DNGBackwardVersion",
      50708: "UniqueCameraModel",
      50709: "LocalizedCameraModel",
      50710: "CFAPlaneColor",
      50711: "CFALayout",
      50712: "LinearizationTable",
      50713: "BlackLevelRepeatDim",
      50714: "BlackLevel",
      50715: "BlackLevelDeltaH",
      50716: "BlackLevelDeltaV",
      50717: "WhiteLevel",
      50718: "DefaultScale",
      50719: "DefaultCropOrigin",
      50720: "DefaultCropSize",
      50721: "ColorMatrix1",
      50722: "ColorMatrix2",
      50723: "CameraCalibration1",
      50724: "CameraCalibration2",
      50725: "ReductionMatrix1",
      50726: "ReductionMatrix2",
      50727: "AnalogBalance",
      50728: "AsShotNeutral",
      50729: "AsShotWhiteXY",
      50730: "BaselineExposure",
      50731: "BaselineNoise",
      50732: "BaselineSharpness",
      50733: "BayerGreenSplit",
      50734: "LinearResponseLimit",
      50735: "CameraSerialNumber",
      50736: "DNGLensInfo",
      50737: "ChromaBlurRadius",
      50738: "AntiAliasStrength",
      50739: "ShadowScale",
      50740: "DNGPrivateData",
      50741: "MakerNoteSafety",
      50752: "RawImageSegmentation",
      50778: "CalibrationIlluminant1",
      50779: "CalibrationIlluminant2",
      50780: "BestQualityScale",
      50781: "RawDataUniqueID",
      50784: "AliasLayerMetadata",
      50827: "OriginalRawFileName",
      50828: "OriginalRawFileData",
      50829: "ActiveArea",
      50830: "MaskedAreas",
      50831: "AsShotICCProfile",
      50832: "AsShotPreProfileMatrix",
      50833: "CurrentICCProfile",
      50834: "CurrentPreProfileMatrix",
      50879: "ColorimetricReference",
      50898: "PanasonicTitle",
      50899: "PanasonicTitle2",
      50931: "CameraCalibrationSig",
      50932: "ProfileCalibrationSig",
      50933: "ProfileIFD",
      50934: "AsShotProfileName",
      50935: "NoiseReductionApplied",
      50936: "ProfileName",
      50937: "ProfileHueSatMapDims",
      50938: "ProfileHueSatMapData1",
      50939: "ProfileHueSatMapData2",
      50940: "ProfileToneCurve",
      50941: "ProfileEmbedPolicy",
      50942: "ProfileCopyright",
      50964: "ForwardMatrix1",
      50965: "ForwardMatrix2",
      50966: "PreviewApplicationName",
      50967: "PreviewApplicationVersion",
      50968: "PreviewSettingsName",
      50969: "PreviewSettingsDigest",
      50970: "PreviewColorSpace",
      50971: "PreviewDateTime",
      50972: "RawImageDigest",
      50973: "OriginalRawFileDigest",
      50974: "SubTileBlockSize",
      50975: "RowInterleaveFactor",
      50981: "ProfileLookTableDims",
      50982: "ProfileLookTableData",
      51008: "OpcodeList1",
      51009: "OpcodeList2",
      51022: "OpcodeList3",
      51041: "NoiseProfile",
      51043: "TimeCodes",
      51044: "FrameRate",
      51058: "TStop",
      51081: "ReelName",
      51089: "OriginalDefaultFinalSize",
      51090: "OriginalBestQualitySize",
      51091: "OriginalDefaultCropSize",
      51105: "CameraLabel",
      51107: "ProfileHueSatMapEncoding",
      51108: "ProfileLookTableEncoding",
      51109: "BaselineExposureOffset",
      51110: "DefaultBlackRender",
      51111: "NewRawImageDigest",
      51112: "RawToPreviewGain",
      51125: "DefaultUserCrop",
      59932: "Padding",
      59933: "OffsetSchema",
      65000: "OwnerName",
      65001: "SerialNumber",
      65002: "Lens",
      65024: "KDC_IFD",
      65100: "RawFile",
      65101: "Converter",
      65102: "WhiteBalance",
      65105: "Exposure",
      65106: "Shadows",
      65107: "Brightness",
      65108: "Contrast",
      65109: "Saturation",
      65110: "Sharpness",
      65111: "Smoothness",
      65112: "MoireFilter"
    },
    gps: {
      0: "GPSVersionID",
      1: "GPSLatitudeRef",
      2: "GPSLatitude",
      3: "GPSLongitudeRef",
      4: "GPSLongitude",
      5: "GPSAltitudeRef",
      6: "GPSAltitude",
      7: "GPSTimeStamp",
      8: "GPSSatellites",
      9: "GPSStatus",
      10: "GPSMeasureMode",
      11: "GPSDOP",
      12: "GPSSpeedRef",
      13: "GPSSpeed",
      14: "GPSTrackRef",
      15: "GPSTrack",
      16: "GPSImgDirectionRef",
      17: "GPSImgDirection",
      18: "GPSMapDatum",
      19: "GPSDestLatitudeRef",
      20: "GPSDestLatitude",
      21: "GPSDestLongitudeRef",
      22: "GPSDestLongitude",
      23: "GPSDestBearingRef",
      24: "GPSDestBearing",
      25: "GPSDestDistanceRef",
      26: "GPSDestDistance",
      27: "GPSProcessingMethod",
      28: "GPSAreaInformation",
      29: "GPSDateStamp",
      30: "GPSDifferential",
      31: "GPSHPositioningError"
    }
  };
});

// node_modules/exif-parser/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var ExifResult = function(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
    this.startMarker = startMarker;
    this.tags = tags;
    this.imageSize = imageSize;
    this.thumbnailOffset = thumbnailOffset;
    this.thumbnailLength = thumbnailLength;
    this.thumbnailType = thumbnailType;
    this.app1Offset = app1Offset;
  };
  var Parser = function(stream2) {
    this.stream = stream2;
    this.flags = {
      readBinaryTags: false,
      resolveTagNames: true,
      simplifyValues: true,
      imageSize: true,
      hidePointers: true,
      returnTags: true
    };
  };
  var jpeg = require_jpeg();
  var exif = require_exif();
  var simplify = require_simplify();
  ExifResult.prototype = {
    hasThumbnail: function(mime) {
      if (!this.thumbnailOffset || !this.thumbnailLength) {
        return false;
      }
      if (typeof mime !== "string") {
        return true;
      }
      if (mime.toLowerCase().trim() === "image/jpeg") {
        return this.thumbnailType === 6;
      }
      if (mime.toLowerCase().trim() === "image/tiff") {
        return this.thumbnailType === 1;
      }
      return false;
    },
    getThumbnailOffset: function() {
      return this.app1Offset + 6 + this.thumbnailOffset;
    },
    getThumbnailLength: function() {
      return this.thumbnailLength;
    },
    getThumbnailBuffer: function() {
      return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
    },
    _getThumbnailStream: function() {
      return this.startMarker.openWithOffset(this.getThumbnailOffset());
    },
    getImageSize: function() {
      return this.imageSize;
    },
    getThumbnailSize: function() {
      var stream2 = this._getThumbnailStream(), size;
      jpeg.parseSections(stream2, function(sectionType, sectionStream) {
        if (jpeg.getSectionName(sectionType).name === "SOF") {
          size = jpeg.getSizeFromSOFSection(sectionStream);
        }
      });
      return size;
    }
  };
  Parser.prototype = {
    enableBinaryFields: function(enable) {
      this.flags.readBinaryTags = !!enable;
      return this;
    },
    enablePointers: function(enable) {
      this.flags.hidePointers = !enable;
      return this;
    },
    enableTagNames: function(enable) {
      this.flags.resolveTagNames = !!enable;
      return this;
    },
    enableImageSize: function(enable) {
      this.flags.imageSize = !!enable;
      return this;
    },
    enableReturnTags: function(enable) {
      this.flags.returnTags = !!enable;
      return this;
    },
    enableSimpleValues: function(enable) {
      this.flags.simplifyValues = !!enable;
      return this;
    },
    parse: function() {
      var start = this.stream.mark(), stream2 = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue;
      if (flags.resolveTagNames) {
        tagNames = require_exif_tags();
      }
      if (flags.resolveTagNames) {
        tags = {};
        getTagValue = function(t) {
          return tags[t.name];
        };
        setTagValue = function(t, value2) {
          tags[t.name] = value2;
        };
      } else {
        tags = [];
        getTagValue = function(t) {
          var i2;
          for (i2 = 0;i2 < tags.length; ++i2) {
            if (tags[i2].type === t.type && tags[i2].section === t.section) {
              return tags.value;
            }
          }
        };
        setTagValue = function(t, value2) {
          var i2;
          for (i2 = 0;i2 < tags.length; ++i2) {
            if (tags[i2].type === t.type && tags[i2].section === t.section) {
              tags.value = value2;
              return;
            }
          }
        };
      }
      jpeg.parseSections(stream2, function(sectionType, sectionStream) {
        var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
        if (sectionType === 225) {
          validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value2, format) {
            if (!flags.readBinaryTags && format === 7) {
              return;
            }
            if (tagType === 513) {
              thumbnailOffset = value2[0];
              if (flags.hidePointers) {
                return;
              }
            } else if (tagType === 514) {
              thumbnailLength = value2[0];
              if (flags.hidePointers) {
                return;
              }
            } else if (tagType === 259) {
              thumbnailType = value2[0];
              if (flags.hidePointers) {
                return;
              }
            }
            if (!flags.returnTags) {
              return;
            }
            if (flags.simplifyValues) {
              value2 = simplify.simplifyValue(value2, format);
            }
            if (flags.resolveTagNames) {
              var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
              var name2 = sectionTagNames[tagType];
              if (!name2) {
                name2 = tagNames.exif[tagType];
              }
              if (!tags.hasOwnProperty(name2)) {
                tags[name2] = value2;
              }
            } else {
              tags.push({
                section: ifdSection,
                type: tagType,
                value: value2
              });
            }
          });
          if (validExifHeaders) {
            app1Offset = sectionOffset;
          }
        } else if (flags.imageSize && jpeg.getSectionName(sectionType).name === "SOF") {
          imageSize = jpeg.getSizeFromSOFSection(sectionStream);
        }
      });
      if (flags.simplifyValues) {
        simplify.castDegreeValues(getTagValue, setTagValue);
        simplify.castDateValues(getTagValue, setTagValue);
      }
      return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
    }
  };
  module.exports = Parser;
});

// node_modules/exif-parser/lib/dom-bufferstream.js
var require_dom_bufferstream = __commonJS((exports, module) => {
  var DOMBufferStream = function(arrayBuffer, offset, length, bigEndian, global2, parentOffset) {
    this.global = global2;
    offset = offset || 0;
    length = length || arrayBuffer.byteLength - offset;
    this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
    this.view = new global2.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
    this.setBigEndian(bigEndian);
    this.offset = 0;
    this.parentOffset = (parentOffset || 0) + offset;
  };
  DOMBufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.littleEndian = !bigEndian;
    },
    nextUInt8: function() {
      var value2 = this.view.getUint8(this.offset);
      this.offset += 1;
      return value2;
    },
    nextInt8: function() {
      var value2 = this.view.getInt8(this.offset);
      this.offset += 1;
      return value2;
    },
    nextUInt16: function() {
      var value2 = this.view.getUint16(this.offset, this.littleEndian);
      this.offset += 2;
      return value2;
    },
    nextUInt32: function() {
      var value2 = this.view.getUint32(this.offset, this.littleEndian);
      this.offset += 4;
      return value2;
    },
    nextInt16: function() {
      var value2 = this.view.getInt16(this.offset, this.littleEndian);
      this.offset += 2;
      return value2;
    },
    nextInt32: function() {
      var value2 = this.view.getInt32(this.offset, this.littleEndian);
      this.offset += 4;
      return value2;
    },
    nextFloat: function() {
      var value2 = this.view.getFloat32(this.offset, this.littleEndian);
      this.offset += 4;
      return value2;
    },
    nextDouble: function() {
      var value2 = this.view.getFloat64(this.offset, this.littleEndian);
      this.offset += 8;
      return value2;
    },
    nextBuffer: function(length) {
      var value2 = this.arrayBuffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value2;
    },
    remainingLength: function() {
      return this.arrayBuffer.byteLength - this.offset;
    },
    nextString: function(length) {
      var value2 = this.arrayBuffer.slice(this.offset, this.offset + length);
      value2 = String.fromCharCode.apply(null, new this.global.Uint8Array(value2));
      this.offset += length;
      return value2;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new DOMBufferStream(self2.arrayBuffer, offset, self2.arrayBuffer.byteLength - offset, !self2.littleEndian, self2.global, self2.parentOffset);
        },
        offset: this.offset,
        getParentOffset: function() {
          return self2.parentOffset;
        }
      };
    },
    offsetFrom: function(marker) {
      return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.arrayBuffer.byteLength - (this.offset + offset);
      return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
    }
  };
  module.exports = DOMBufferStream;
});

// node_modules/exif-parser/lib/bufferstream.js
var require_bufferstream = __commonJS((exports, module) => {
  var BufferStream = function(buffer, offset, length, bigEndian) {
    this.buffer = buffer;
    this.offset = offset || 0;
    length = typeof length === "number" ? length : buffer.length;
    this.endPosition = this.offset + length;
    this.setBigEndian(bigEndian);
  };
  BufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.bigEndian = !!bigEndian;
    },
    nextUInt8: function() {
      var value2 = this.buffer.readUInt8(this.offset);
      this.offset += 1;
      return value2;
    },
    nextInt8: function() {
      var value2 = this.buffer.readInt8(this.offset);
      this.offset += 1;
      return value2;
    },
    nextUInt16: function() {
      var value2 = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
      this.offset += 2;
      return value2;
    },
    nextUInt32: function() {
      var value2 = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
      this.offset += 4;
      return value2;
    },
    nextInt16: function() {
      var value2 = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
      this.offset += 2;
      return value2;
    },
    nextInt32: function() {
      var value2 = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
      this.offset += 4;
      return value2;
    },
    nextFloat: function() {
      var value2 = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
      this.offset += 4;
      return value2;
    },
    nextDouble: function() {
      var value2 = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
      this.offset += 8;
      return value2;
    },
    nextBuffer: function(length) {
      var value2 = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value2;
    },
    remainingLength: function() {
      return this.endPosition - this.offset;
    },
    nextString: function(length) {
      var value2 = this.buffer.toString("utf8", this.offset, this.offset + length);
      this.offset += length;
      return value2;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new BufferStream(self2.buffer, offset, self2.endPosition - offset, self2.bigEndian);
        },
        offset: this.offset
      };
    },
    offsetFrom: function(marker) {
      return this.offset - marker.offset;
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.endPosition - (this.offset + offset);
      return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
    }
  };
  module.exports = BufferStream;
});

// node_modules/exif-parser/index.js
var require_exif_parser = __commonJS((exports, module) => {
  var getGlobal = function() {
    return (1, eval)("this");
  };
  var Parser = require_parser();
  module.exports = {
    create: function(buffer, global2) {
      global2 = global2 || getGlobal();
      if (buffer instanceof global2.ArrayBuffer) {
        var DOMBufferStream = require_dom_bufferstream();
        return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global2));
      } else {
        var NodeBufferStream = require_bufferstream();
        return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
      }
    }
  };
});

// node_modules/timm/lib/timm.js
var require_timm = __commonJS((exports) => {
  var throwStr = function(msg) {
    throw new Error(msg);
  };
  var getKeysAndSymbols = function(obj) {
    const keys = Object.keys(obj);
    if (Object.getOwnPropertySymbols) {
      return keys.concat(Object.getOwnPropertySymbols(obj));
    }
    return keys;
  };
  var clone2 = function(obj0) {
    if (Array.isArray(obj0))
      return obj0.slice();
    const obj = obj0;
    const keys = getKeysAndSymbols(obj);
    const out = {};
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      out[key] = obj[key];
    }
    return out;
  };
  var isObject = function(o) {
    return o != null && typeof o === "object";
  };
  var addLast = function(array, val) {
    if (Array.isArray(val))
      return array.concat(val);
    return array.concat([val]);
  };
  var addFirst = function(array, val) {
    if (Array.isArray(val))
      return val.concat(array);
    return [val].concat(array);
  };
  var removeLast = function(array) {
    if (!array.length)
      return array;
    return array.slice(0, array.length - 1);
  };
  var removeFirst = function(array) {
    if (!array.length)
      return array;
    return array.slice(1);
  };
  var insert = function(array, idx, val) {
    return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));
  };
  var removeAt = function(array, idx) {
    if (idx >= array.length || idx < 0)
      return array;
    return array.slice(0, idx).concat(array.slice(idx + 1));
  };
  var replaceAt = function(array, idx, newItem) {
    if (array[idx] === newItem)
      return array;
    const len = array.length;
    const result = Array(len);
    for (let i2 = 0;i2 < len; i2++) {
      result[i2] = array[i2];
    }
    result[idx] = newItem;
    return result;
  };
  var getIn = function(obj, path2) {
    if (!Array.isArray(path2)) {
      throwStr(IS_DEV ? "A path array should be provided when calling getIn()" : INVALID_ARGS);
    }
    if (obj == null)
      return;
    let ptr = obj;
    for (let i2 = 0;i2 < path2.length; i2++) {
      const key = path2[i2];
      ptr = ptr != null ? ptr[key] : undefined;
      if (ptr === undefined)
        return ptr;
    }
    return ptr;
  };
  var set = function(obj0, key, val) {
    let obj = obj0;
    if (obj == null)
      obj = typeof key === "number" ? [] : {};
    if (obj[key] === val)
      return obj;
    const obj2 = clone2(obj);
    obj2[key] = val;
    return obj2;
  };
  var setIn = function(obj, path2, val) {
    if (!path2.length)
      return val;
    return doSetIn(obj, path2, val, 0);
  };
  var doSetIn = function(obj, path2, val, idx) {
    let newValue;
    const key = path2[idx];
    if (idx === path2.length - 1) {
      newValue = val;
    } else {
      const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path2[idx + 1] === "number" ? [] : {};
      newValue = doSetIn(nestedObj, path2, val, idx + 1);
    }
    return set(obj, key, newValue);
  };
  var update = function(obj, key, fnUpdate) {
    const prevVal = obj == null ? undefined : obj[key];
    const nextVal = fnUpdate(prevVal);
    return set(obj, key, nextVal);
  };
  var updateIn = function(obj, path2, fnUpdate) {
    const prevVal = getIn(obj, path2);
    const nextVal = fnUpdate(prevVal);
    return setIn(obj, path2, nextVal);
  };
  var merge = function(a, b, c2, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, false, false, a, b, c2, d, e, f, ...rest) : doMerge(false, false, a, b, c2, d, e, f);
  };
  var mergeDeep = function(a, b, c2, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, false, true, a, b, c2, d, e, f, ...rest) : doMerge(false, true, a, b, c2, d, e, f);
  };
  var mergeIn = function(a, path2, b, c2, d, e, f, ...rest) {
    let prevVal = getIn(a, path2);
    if (prevVal == null)
      prevVal = {};
    let nextVal;
    if (rest.length) {
      nextVal = doMerge.call(null, false, false, prevVal, b, c2, d, e, f, ...rest);
    } else {
      nextVal = doMerge(false, false, prevVal, b, c2, d, e, f);
    }
    return setIn(a, path2, nextVal);
  };
  var omit = function(obj, attrs) {
    const omitList = Array.isArray(attrs) ? attrs : [attrs];
    let fDoSomething = false;
    for (let i2 = 0;i2 < omitList.length; i2++) {
      if (hasOwnProperty.call(obj, omitList[i2])) {
        fDoSomething = true;
        break;
      }
    }
    if (!fDoSomething)
      return obj;
    const out = {};
    const keys = getKeysAndSymbols(obj);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      if (omitList.indexOf(key) >= 0)
        continue;
      out[key] = obj[key];
    }
    return out;
  };
  var addDefaults = function(a, b, c2, d, e, f, ...rest) {
    return rest.length ? doMerge.call(null, true, false, a, b, c2, d, e, f, ...rest) : doMerge(true, false, a, b, c2, d, e, f);
  };
  var doMerge = function(fAddDefaults, fDeep, first, ...rest) {
    let out = first;
    if (!(out != null)) {
      throwStr(IS_DEV ? "At least one object should be provided to merge()" : INVALID_ARGS);
    }
    let fChanged = false;
    for (let idx = 0;idx < rest.length; idx++) {
      const obj = rest[idx];
      if (obj == null)
        continue;
      const keys = getKeysAndSymbols(obj);
      if (!keys.length)
        continue;
      for (let j = 0;j <= keys.length; j++) {
        const key = keys[j];
        if (fAddDefaults && out[key] !== undefined)
          continue;
        let nextVal = obj[key];
        if (fDeep && isObject(out[key]) && isObject(nextVal)) {
          nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);
        }
        if (nextVal === undefined || nextVal === out[key])
          continue;
        if (!fChanged) {
          fChanged = true;
          out = clone2(out);
        }
        out[key] = nextVal;
      }
    }
    return out;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.clone = clone2;
  exports.addLast = addLast;
  exports.addFirst = addFirst;
  exports.removeLast = removeLast;
  exports.removeFirst = removeFirst;
  exports.insert = insert;
  exports.removeAt = removeAt;
  exports.replaceAt = replaceAt;
  exports.getIn = getIn;
  exports.set = set;
  exports.setIn = setIn;
  exports.update = update;
  exports.updateIn = updateIn;
  exports.merge = merge;
  exports.mergeDeep = mergeDeep;
  exports.mergeIn = mergeIn;
  exports.omit = omit;
  exports.addDefaults = addDefaults;
  exports.default = undefined;
  /*!
   * Timm
   *
   * Immutability helpers with fast reads and acceptable writes.
   *
   * @copyright Guillermo Grau Panea 2016
   * @license MIT
   */
  var INVALID_ARGS = "INVALID_ARGS";
  var IS_DEV = true;
  var hasOwnProperty = {}.hasOwnProperty;
  var timm = {
    clone: clone2,
    addLast,
    addFirst,
    removeLast,
    removeFirst,
    insert,
    removeAt,
    replaceAt,
    getIn,
    set,
    setIn,
    update,
    updateIn,
    merge,
    mergeDeep,
    mergeIn,
    omit,
    addDefaults
  };
  var _default = timm;
  exports.default = _default;
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS((exports, module) => {
  var JPEGEncoder = function(quality2) {
    var self2 = this;
    var fround = Math.round;
    var ffloor = Math.floor;
    var YTable = new Array(64);
    var UVTable = new Array(64);
    var fdtbl_Y = new Array(64);
    var fdtbl_UV = new Array(64);
    var YDC_HT;
    var UVDC_HT;
    var YAC_HT;
    var UVAC_HT;
    var bitcode = new Array(65535);
    var category = new Array(65535);
    var outputfDCTQuant = new Array(64);
    var DU = new Array(64);
    var byteout = [];
    var bytenew = 0;
    var bytepos = 7;
    var YDU = new Array(64);
    var UDU = new Array(64);
    var VDU = new Array(64);
    var clt = new Array(256);
    var RGB_YUV_TABLE = new Array(2048);
    var currentQuality;
    var ZigZag = [
      0,
      1,
      5,
      6,
      14,
      15,
      27,
      28,
      2,
      4,
      7,
      13,
      16,
      26,
      29,
      42,
      3,
      8,
      12,
      17,
      25,
      30,
      41,
      43,
      9,
      11,
      18,
      24,
      31,
      40,
      44,
      53,
      10,
      19,
      23,
      32,
      39,
      45,
      52,
      54,
      20,
      22,
      33,
      38,
      46,
      51,
      55,
      60,
      21,
      34,
      37,
      47,
      50,
      56,
      59,
      61,
      35,
      36,
      48,
      49,
      57,
      58,
      62,
      63
    ];
    var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
    var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
    var std_ac_luminance_values = [
      1,
      2,
      3,
      0,
      4,
      17,
      5,
      18,
      33,
      49,
      65,
      6,
      19,
      81,
      97,
      7,
      34,
      113,
      20,
      50,
      129,
      145,
      161,
      8,
      35,
      66,
      177,
      193,
      21,
      82,
      209,
      240,
      36,
      51,
      98,
      114,
      130,
      9,
      10,
      22,
      23,
      24,
      25,
      26,
      37,
      38,
      39,
      40,
      41,
      42,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
    var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
    var std_ac_chrominance_values = [
      0,
      1,
      2,
      3,
      17,
      4,
      5,
      33,
      49,
      6,
      18,
      65,
      81,
      7,
      97,
      113,
      19,
      34,
      50,
      129,
      8,
      20,
      66,
      145,
      161,
      177,
      193,
      9,
      35,
      51,
      82,
      240,
      21,
      98,
      114,
      209,
      10,
      22,
      36,
      52,
      225,
      37,
      241,
      23,
      24,
      25,
      26,
      38,
      39,
      40,
      41,
      42,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    function initQuantTables(sf) {
      var YQT = [
        16,
        11,
        10,
        16,
        24,
        40,
        51,
        61,
        12,
        12,
        14,
        19,
        26,
        58,
        60,
        55,
        14,
        13,
        16,
        24,
        40,
        57,
        69,
        56,
        14,
        17,
        22,
        29,
        51,
        87,
        80,
        62,
        18,
        22,
        37,
        56,
        68,
        109,
        103,
        77,
        24,
        35,
        55,
        64,
        81,
        104,
        113,
        92,
        49,
        64,
        78,
        87,
        103,
        121,
        120,
        101,
        72,
        92,
        95,
        98,
        112,
        100,
        103,
        99
      ];
      for (var i2 = 0;i2 < 64; i2++) {
        var t = ffloor((YQT[i2] * sf + 50) / 100);
        if (t < 1) {
          t = 1;
        } else if (t > 255) {
          t = 255;
        }
        YTable[ZigZag[i2]] = t;
      }
      var UVQT = [
        17,
        18,
        24,
        47,
        99,
        99,
        99,
        99,
        18,
        21,
        26,
        66,
        99,
        99,
        99,
        99,
        24,
        26,
        56,
        99,
        99,
        99,
        99,
        99,
        47,
        66,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99
      ];
      for (var j = 0;j < 64; j++) {
        var u = ffloor((UVQT[j] * sf + 50) / 100);
        if (u < 1) {
          u = 1;
        } else if (u > 255) {
          u = 255;
        }
        UVTable[ZigZag[j]] = u;
      }
      var aasf = [
        1,
        1.387039845,
        1.306562965,
        1.175875602,
        1,
        0.785694958,
        0.5411961,
        0.275899379
      ];
      var k = 0;
      for (var row = 0;row < 8; row++) {
        for (var col = 0;col < 8; col++) {
          fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          k++;
        }
      }
    }
    function computeHuffmanTbl(nrcodes, std_table) {
      var codevalue = 0;
      var pos_in_table = 0;
      var HT = new Array;
      for (var k = 1;k <= 16; k++) {
        for (var j = 1;j <= nrcodes[k]; j++) {
          HT[std_table[pos_in_table]] = [];
          HT[std_table[pos_in_table]][0] = codevalue;
          HT[std_table[pos_in_table]][1] = k;
          pos_in_table++;
          codevalue++;
        }
        codevalue *= 2;
      }
      return HT;
    }
    function initHuffmanTbl() {
      YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
      UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
      YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
      UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
    }
    function initCategoryNumber() {
      var nrlower = 1;
      var nrupper = 2;
      for (var cat = 1;cat <= 15; cat++) {
        for (var nr = nrlower;nr < nrupper; nr++) {
          category[32767 + nr] = cat;
          bitcode[32767 + nr] = [];
          bitcode[32767 + nr][1] = cat;
          bitcode[32767 + nr][0] = nr;
        }
        for (var nrneg = -(nrupper - 1);nrneg <= -nrlower; nrneg++) {
          category[32767 + nrneg] = cat;
          bitcode[32767 + nrneg] = [];
          bitcode[32767 + nrneg][1] = cat;
          bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
        }
        nrlower <<= 1;
        nrupper <<= 1;
      }
    }
    function initRGBYUVTable() {
      for (var i2 = 0;i2 < 256; i2++) {
        RGB_YUV_TABLE[i2] = 19595 * i2;
        RGB_YUV_TABLE[i2 + 256 >> 0] = 38470 * i2;
        RGB_YUV_TABLE[i2 + 512 >> 0] = 7471 * i2 + 32768;
        RGB_YUV_TABLE[i2 + 768 >> 0] = -11059 * i2;
        RGB_YUV_TABLE[i2 + 1024 >> 0] = -21709 * i2;
        RGB_YUV_TABLE[i2 + 1280 >> 0] = 32768 * i2 + 8421375;
        RGB_YUV_TABLE[i2 + 1536 >> 0] = -27439 * i2;
        RGB_YUV_TABLE[i2 + 1792 >> 0] = -5329 * i2;
      }
    }
    function writeBits(bs) {
      var value2 = bs[0];
      var posval = bs[1] - 1;
      while (posval >= 0) {
        if (value2 & 1 << posval) {
          bytenew |= 1 << bytepos;
        }
        posval--;
        bytepos--;
        if (bytepos < 0) {
          if (bytenew == 255) {
            writeByte(255);
            writeByte(0);
          } else {
            writeByte(bytenew);
          }
          bytepos = 7;
          bytenew = 0;
        }
      }
    }
    function writeByte(value2) {
      byteout.push(value2);
    }
    function writeWord(value2) {
      writeByte(value2 >> 8 & 255);
      writeByte(value2 & 255);
    }
    function fDCTQuant(data2, fdtbl) {
      var d0, d1, d2, d3, d4, d5, d6, d7;
      var dataOff = 0;
      var i2;
      var I8 = 8;
      var I64 = 64;
      for (i2 = 0;i2 < I8; ++i2) {
        d0 = data2[dataOff];
        d1 = data2[dataOff + 1];
        d2 = data2[dataOff + 2];
        d3 = data2[dataOff + 3];
        d4 = data2[dataOff + 4];
        d5 = data2[dataOff + 5];
        d6 = data2[dataOff + 6];
        d7 = data2[dataOff + 7];
        var tmp0 = d0 + d7;
        var tmp7 = d0 - d7;
        var tmp1 = d1 + d6;
        var tmp6 = d1 - d6;
        var tmp2 = d2 + d5;
        var tmp5 = d2 - d5;
        var tmp3 = d3 + d4;
        var tmp4 = d3 - d4;
        var tmp10 = tmp0 + tmp3;
        var tmp13 = tmp0 - tmp3;
        var tmp11 = tmp1 + tmp2;
        var tmp12 = tmp1 - tmp2;
        data2[dataOff] = tmp10 + tmp11;
        data2[dataOff + 4] = tmp10 - tmp11;
        var z1 = (tmp12 + tmp13) * 0.707106781;
        data2[dataOff + 2] = tmp13 + z1;
        data2[dataOff + 6] = tmp13 - z1;
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        var z5 = (tmp10 - tmp12) * 0.382683433;
        var z2 = 0.5411961 * tmp10 + z5;
        var z4 = 1.306562965 * tmp12 + z5;
        var z3 = tmp11 * 0.707106781;
        var z11 = tmp7 + z3;
        var z13 = tmp7 - z3;
        data2[dataOff + 5] = z13 + z2;
        data2[dataOff + 3] = z13 - z2;
        data2[dataOff + 1] = z11 + z4;
        data2[dataOff + 7] = z11 - z4;
        dataOff += 8;
      }
      dataOff = 0;
      for (i2 = 0;i2 < I8; ++i2) {
        d0 = data2[dataOff];
        d1 = data2[dataOff + 8];
        d2 = data2[dataOff + 16];
        d3 = data2[dataOff + 24];
        d4 = data2[dataOff + 32];
        d5 = data2[dataOff + 40];
        d6 = data2[dataOff + 48];
        d7 = data2[dataOff + 56];
        var tmp0p2 = d0 + d7;
        var tmp7p2 = d0 - d7;
        var tmp1p2 = d1 + d6;
        var tmp6p2 = d1 - d6;
        var tmp2p2 = d2 + d5;
        var tmp5p2 = d2 - d5;
        var tmp3p2 = d3 + d4;
        var tmp4p2 = d3 - d4;
        var tmp10p2 = tmp0p2 + tmp3p2;
        var tmp13p2 = tmp0p2 - tmp3p2;
        var tmp11p2 = tmp1p2 + tmp2p2;
        var tmp12p2 = tmp1p2 - tmp2p2;
        data2[dataOff] = tmp10p2 + tmp11p2;
        data2[dataOff + 32] = tmp10p2 - tmp11p2;
        var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
        data2[dataOff + 16] = tmp13p2 + z1p2;
        data2[dataOff + 48] = tmp13p2 - z1p2;
        tmp10p2 = tmp4p2 + tmp5p2;
        tmp11p2 = tmp5p2 + tmp6p2;
        tmp12p2 = tmp6p2 + tmp7p2;
        var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
        var z2p2 = 0.5411961 * tmp10p2 + z5p2;
        var z4p2 = 1.306562965 * tmp12p2 + z5p2;
        var z3p2 = tmp11p2 * 0.707106781;
        var z11p2 = tmp7p2 + z3p2;
        var z13p2 = tmp7p2 - z3p2;
        data2[dataOff + 40] = z13p2 + z2p2;
        data2[dataOff + 24] = z13p2 - z2p2;
        data2[dataOff + 8] = z11p2 + z4p2;
        data2[dataOff + 56] = z11p2 - z4p2;
        dataOff++;
      }
      var fDCTQuant2;
      for (i2 = 0;i2 < I64; ++i2) {
        fDCTQuant2 = data2[i2] * fdtbl[i2];
        outputfDCTQuant[i2] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
      }
      return outputfDCTQuant;
    }
    function writeAPP0() {
      writeWord(65504);
      writeWord(16);
      writeByte(74);
      writeByte(70);
      writeByte(73);
      writeByte(70);
      writeByte(0);
      writeByte(1);
      writeByte(1);
      writeByte(0);
      writeWord(1);
      writeWord(1);
      writeByte(0);
      writeByte(0);
    }
    function writeAPP1(exifBuffer) {
      if (!exifBuffer)
        return;
      writeWord(65505);
      if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
        writeWord(exifBuffer.length + 2);
      } else {
        writeWord(exifBuffer.length + 5 + 2);
        writeByte(69);
        writeByte(120);
        writeByte(105);
        writeByte(102);
        writeByte(0);
      }
      for (var i2 = 0;i2 < exifBuffer.length; i2++) {
        writeByte(exifBuffer[i2]);
      }
    }
    function writeSOF0(width, height) {
      writeWord(65472);
      writeWord(17);
      writeByte(8);
      writeWord(height);
      writeWord(width);
      writeByte(3);
      writeByte(1);
      writeByte(17);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(1);
      writeByte(3);
      writeByte(17);
      writeByte(1);
    }
    function writeDQT() {
      writeWord(65499);
      writeWord(132);
      writeByte(0);
      for (var i2 = 0;i2 < 64; i2++) {
        writeByte(YTable[i2]);
      }
      writeByte(1);
      for (var j = 0;j < 64; j++) {
        writeByte(UVTable[j]);
      }
    }
    function writeDHT() {
      writeWord(65476);
      writeWord(418);
      writeByte(0);
      for (var i2 = 0;i2 < 16; i2++) {
        writeByte(std_dc_luminance_nrcodes[i2 + 1]);
      }
      for (var j = 0;j <= 11; j++) {
        writeByte(std_dc_luminance_values[j]);
      }
      writeByte(16);
      for (var k = 0;k < 16; k++) {
        writeByte(std_ac_luminance_nrcodes[k + 1]);
      }
      for (var l = 0;l <= 161; l++) {
        writeByte(std_ac_luminance_values[l]);
      }
      writeByte(1);
      for (var m = 0;m < 16; m++) {
        writeByte(std_dc_chrominance_nrcodes[m + 1]);
      }
      for (var n = 0;n <= 11; n++) {
        writeByte(std_dc_chrominance_values[n]);
      }
      writeByte(17);
      for (var o = 0;o < 16; o++) {
        writeByte(std_ac_chrominance_nrcodes[o + 1]);
      }
      for (var p = 0;p <= 161; p++) {
        writeByte(std_ac_chrominance_values[p]);
      }
    }
    function writeCOM(comments) {
      if (typeof comments === "undefined" || comments.constructor !== Array)
        return;
      comments.forEach((e) => {
        if (typeof e !== "string")
          return;
        writeWord(65534);
        var l = e.length;
        writeWord(l + 2);
        var i2;
        for (i2 = 0;i2 < l; i2++)
          writeByte(e.charCodeAt(i2));
      });
    }
    function writeSOS() {
      writeWord(65498);
      writeWord(12);
      writeByte(3);
      writeByte(1);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(3);
      writeByte(17);
      writeByte(0);
      writeByte(63);
      writeByte(0);
    }
    function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
      var EOB = HTAC[0];
      var M16zeroes = HTAC[240];
      var pos;
      var I16 = 16;
      var I63 = 63;
      var I64 = 64;
      var DU_DCT = fDCTQuant(CDU, fdtbl);
      for (var j = 0;j < I64; ++j) {
        DU[ZigZag[j]] = DU_DCT[j];
      }
      var Diff = DU[0] - DC;
      DC = DU[0];
      if (Diff == 0) {
        writeBits(HTDC[0]);
      } else {
        pos = 32767 + Diff;
        writeBits(HTDC[category[pos]]);
        writeBits(bitcode[pos]);
      }
      var end0pos = 63;
      for (;end0pos > 0 && DU[end0pos] == 0; end0pos--) {
      }
      if (end0pos == 0) {
        writeBits(EOB);
        return DC;
      }
      var i2 = 1;
      var lng;
      while (i2 <= end0pos) {
        var startpos = i2;
        for (;DU[i2] == 0 && i2 <= end0pos; ++i2) {
        }
        var nrzeroes = i2 - startpos;
        if (nrzeroes >= I16) {
          lng = nrzeroes >> 4;
          for (var nrmarker = 1;nrmarker <= lng; ++nrmarker)
            writeBits(M16zeroes);
          nrzeroes = nrzeroes & 15;
        }
        pos = 32767 + DU[i2];
        writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
        writeBits(bitcode[pos]);
        i2++;
      }
      if (end0pos != I63) {
        writeBits(EOB);
      }
      return DC;
    }
    function initCharLookupTable() {
      var sfcc = String.fromCharCode;
      for (var i2 = 0;i2 < 256; i2++) {
        clt[i2] = sfcc(i2);
      }
    }
    this.encode = function(image2, quality3) {
      var time_start = new Date().getTime();
      if (quality3)
        setQuality(quality3);
      byteout = new Array;
      bytenew = 0;
      bytepos = 7;
      writeWord(65496);
      writeAPP0();
      writeCOM(image2.comments);
      writeAPP1(image2.exifBuffer);
      writeDQT();
      writeSOF0(image2.width, image2.height);
      writeDHT();
      writeSOS();
      var DCY = 0;
      var DCU = 0;
      var DCV = 0;
      bytenew = 0;
      bytepos = 7;
      this.encode.displayName = "_encode_";
      var imageData = image2.data;
      var width = image2.width;
      var height = image2.height;
      var quadWidth = width * 4;
      var tripleWidth = width * 3;
      var x, y = 0;
      var r, g, b;
      var start, p, col, row, pos;
      while (y < height) {
        x = 0;
        while (x < quadWidth) {
          start = quadWidth * y + x;
          p = start;
          col = -1;
          row = 0;
          for (pos = 0;pos < 64; pos++) {
            row = pos >> 3;
            col = (pos & 7) * 4;
            p = start + row * quadWidth + col;
            if (y + row >= height) {
              p -= quadWidth * (y + 1 + row - height);
            }
            if (x + col >= quadWidth) {
              p -= x + col - quadWidth + 4;
            }
            r = imageData[p++];
            g = imageData[p++];
            b = imageData[p++];
            YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
            UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
            VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
          }
          DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
          DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
          DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
          x += 32;
        }
        y += 8;
      }
      if (bytepos >= 0) {
        var fillbits = [];
        fillbits[1] = bytepos + 1;
        fillbits[0] = (1 << bytepos + 1) - 1;
        writeBits(fillbits);
      }
      writeWord(65497);
      if (typeof module === "undefined")
        return new Uint8Array(byteout);
      return Buffer.from(byteout);
      var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
      byteout = [];
      var duration = new Date().getTime() - time_start;
      return jpegDataUri;
    };
    function setQuality(quality3) {
      if (quality3 <= 0) {
        quality3 = 1;
      }
      if (quality3 > 100) {
        quality3 = 100;
      }
      if (currentQuality == quality3)
        return;
      var sf = 0;
      if (quality3 < 50) {
        sf = Math.floor(5000 / quality3);
      } else {
        sf = Math.floor(200 - quality3 * 2);
      }
      initQuantTables(sf);
      currentQuality = quality3;
    }
    function init() {
      var time_start = new Date().getTime();
      if (!quality2)
        quality2 = 50;
      initCharLookupTable();
      initHuffmanTbl();
      initCategoryNumber();
      initRGBYUVTable();
      setQuality(quality2);
      var duration = new Date().getTime() - time_start;
    }
    init();
  };
  var encode = function(imgData, qu) {
    if (typeof qu === "undefined")
      qu = 50;
    var encoder = new JPEGEncoder(qu);
    var data2 = encoder.encode(imgData, qu);
    return {
      data: data2,
      width: imgData.width,
      height: imgData.height
    };
  };
  var btoa = btoa || function(buf) {
    return Buffer.from(buf).toString("base64");
  };
  if (typeof module !== "undefined") {
    module.exports = encode;
  } else if (typeof window !== "undefined") {
    window["jpeg-js"] = window["jpeg-js"] || {};
    window["jpeg-js"].encode = encode;
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS((exports, module) => {
  var decode = function(jpegData, userOpts = {}) {
    var defaultOpts = {
      colorTransform: undefined,
      useTArray: false,
      formatAsRGBA: true,
      tolerantDecoding: true,
      maxResolutionInMP: 100,
      maxMemoryUsageInMB: 512
    };
    var opts = { ...defaultOpts, ...userOpts };
    var arr = new Uint8Array(jpegData);
    var decoder = new JpegImage;
    decoder.opts = opts;
    JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
    decoder.parse(arr);
    var channels = opts.formatAsRGBA ? 4 : 3;
    var bytesNeeded = decoder.width * decoder.height * channels;
    try {
      JpegImage.requestMemoryAllocation(bytesNeeded);
      var image2 = {
        width: decoder.width,
        height: decoder.height,
        exifBuffer: decoder.exifBuffer,
        data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
      };
      if (decoder.comments.length > 0) {
        image2["comments"] = decoder.comments;
      }
    } catch (err) {
      if (err instanceof RangeError) {
        throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
      }
      if (err instanceof ReferenceError) {
        if (err.message === "Buffer is not defined") {
          throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
        }
      }
      throw err;
    }
    decoder.copyToImageData(image2, opts.formatAsRGBA);
    return image2;
  };
  var JpegImage = function jpegImage() {
    var dctZigZag = new Int32Array([
      0,
      1,
      8,
      16,
      9,
      2,
      3,
      10,
      17,
      24,
      32,
      25,
      18,
      11,
      4,
      5,
      12,
      19,
      26,
      33,
      40,
      48,
      41,
      34,
      27,
      20,
      13,
      6,
      7,
      14,
      21,
      28,
      35,
      42,
      49,
      56,
      57,
      50,
      43,
      36,
      29,
      22,
      15,
      23,
      30,
      37,
      44,
      51,
      58,
      59,
      52,
      45,
      38,
      31,
      39,
      46,
      53,
      60,
      61,
      54,
      47,
      55,
      62,
      63
    ]);
    var dctCos1 = 4017;
    var dctSin1 = 799;
    var dctCos3 = 3406;
    var dctSin3 = 2276;
    var dctCos6 = 1567;
    var dctSin6 = 3784;
    var dctSqrt2 = 5793;
    var dctSqrt1d2 = 2896;
    function constructor() {
    }
    function buildHuffmanTable(codeLengths, values) {
      var k = 0, code = [], i2, j, length = 16;
      while (length > 0 && !codeLengths[length - 1])
        length--;
      code.push({ children: [], index: 0 });
      var p = code[0], q;
      for (i2 = 0;i2 < length; i2++) {
        for (j = 0;j < codeLengths[i2]; j++) {
          p = code.pop();
          p.children[p.index] = values[k];
          while (p.index > 0) {
            if (code.length === 0)
              throw new Error("Could not recreate Huffman Table");
            p = code.pop();
          }
          p.index++;
          code.push(p);
          while (code.length <= i2) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
          k++;
        }
        if (i2 + 1 < length) {
          code.push(q = { children: [], index: 0 });
          p.children[p.index] = q.children;
          p = q;
        }
      }
      return code[0].children;
    }
    function decodeScan(data2, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
      var precision = frame.precision;
      var samplesPerLine = frame.samplesPerLine;
      var scanLines = frame.scanLines;
      var mcusPerLine = frame.mcusPerLine;
      var progressive = frame.progressive;
      var { maxH, maxV } = frame;
      var startOffset = offset, bitsData = 0, bitsCount = 0;
      function readBit() {
        if (bitsCount > 0) {
          bitsCount--;
          return bitsData >> bitsCount & 1;
        }
        bitsData = data2[offset++];
        if (bitsData == 255) {
          var nextByte = data2[offset++];
          if (nextByte) {
            throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
          }
        }
        bitsCount = 7;
        return bitsData >>> 7;
      }
      function decodeHuffman(tree) {
        var node = tree, bit;
        while ((bit = readBit()) !== null) {
          node = node[bit];
          if (typeof node === "number")
            return node;
          if (typeof node !== "object")
            throw new Error("invalid huffman sequence");
        }
        return null;
      }
      function receive(length) {
        var n2 = 0;
        while (length > 0) {
          var bit = readBit();
          if (bit === null)
            return;
          n2 = n2 << 1 | bit;
          length--;
        }
        return n2;
      }
      function receiveAndExtend(length) {
        var n2 = receive(length);
        if (n2 >= 1 << length - 1)
          return n2;
        return n2 + (-1 << length) + 1;
      }
      function decodeBaseline(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff = t === 0 ? 0 : receiveAndExtend(t);
        zz[0] = component2.pred += diff;
        var k2 = 1;
        while (k2 < 64) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15)
              break;
            k2 += 16;
            continue;
          }
          k2 += r;
          var z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s);
          k2++;
        }
      }
      function decodeDCFirst(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
        zz[0] = component2.pred += diff;
      }
      function decodeDCSuccessive(component2, zz) {
        zz[0] |= readBit() << successive;
      }
      var eobrun = 0;
      function decodeACFirst(component2, zz) {
        if (eobrun > 0) {
          eobrun--;
          return;
        }
        var k2 = spectralStart, e = spectralEnd;
        while (k2 <= e) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r) - 1;
              break;
            }
            k2 += 16;
            continue;
          }
          k2 += r;
          var z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s) * (1 << successive);
          k2++;
        }
      }
      var successiveACState = 0, successiveACNextValue;
      function decodeACSuccessive(component2, zz) {
        var k2 = spectralStart, e = spectralEnd, r = 0;
        while (k2 <= e) {
          var z = dctZigZag[k2];
          var direction = zz[z] < 0 ? -1 : 1;
          switch (successiveACState) {
            case 0:
              var rs = decodeHuffman(component2.huffmanTableAC);
              var s = rs & 15, r = rs >> 4;
              if (s === 0) {
                if (r < 15) {
                  eobrun = receive(r) + (1 << r);
                  successiveACState = 4;
                } else {
                  r = 16;
                  successiveACState = 1;
                }
              } else {
                if (s !== 1)
                  throw new Error("invalid ACn encoding");
                successiveACNextValue = receiveAndExtend(s);
                successiveACState = r ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              else {
                r--;
                if (r === 0)
                  successiveACState = successiveACState == 2 ? 3 : 0;
              }
              break;
            case 3:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              else {
                zz[z] = successiveACNextValue << successive;
                successiveACState = 0;
              }
              break;
            case 4:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              break;
          }
          k2++;
        }
        if (successiveACState === 4) {
          eobrun--;
          if (eobrun === 0)
            successiveACState = 0;
        }
      }
      function decodeMcu(component2, decode2, mcu2, row, col) {
        var mcuRow = mcu2 / mcusPerLine | 0;
        var mcuCol = mcu2 % mcusPerLine;
        var blockRow = mcuRow * component2.v + row;
        var blockCol = mcuCol * component2.h + col;
        if (component2.blocks[blockRow] === undefined && opts.tolerantDecoding)
          return;
        decode2(component2, component2.blocks[blockRow][blockCol]);
      }
      function decodeBlock(component2, decode2, mcu2) {
        var blockRow = mcu2 / component2.blocksPerLine | 0;
        var blockCol = mcu2 % component2.blocksPerLine;
        if (component2.blocks[blockRow] === undefined && opts.tolerantDecoding)
          return;
        decode2(component2, component2.blocks[blockRow][blockCol]);
      }
      var componentsLength = components.length;
      var component, i2, j, k, n;
      var decodeFn;
      if (progressive) {
        if (spectralStart === 0)
          decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
        else
          decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      } else {
        decodeFn = decodeBaseline;
      }
      var mcu = 0, marker;
      var mcuExpected;
      if (componentsLength == 1) {
        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
      } else {
        mcuExpected = mcusPerLine * frame.mcusPerColumn;
      }
      if (!resetInterval)
        resetInterval = mcuExpected;
      var h, v;
      while (mcu < mcuExpected) {
        for (i2 = 0;i2 < componentsLength; i2++)
          components[i2].pred = 0;
        eobrun = 0;
        if (componentsLength == 1) {
          component = components[0];
          for (n = 0;n < resetInterval; n++) {
            decodeBlock(component, decodeFn, mcu);
            mcu++;
          }
        } else {
          for (n = 0;n < resetInterval; n++) {
            for (i2 = 0;i2 < componentsLength; i2++) {
              component = components[i2];
              h = component.h;
              v = component.v;
              for (j = 0;j < v; j++) {
                for (k = 0;k < h; k++) {
                  decodeMcu(component, decodeFn, mcu, j, k);
                }
              }
            }
            mcu++;
            if (mcu === mcuExpected)
              break;
          }
        }
        if (mcu === mcuExpected) {
          do {
            if (data2[offset] === 255) {
              if (data2[offset + 1] !== 0) {
                break;
              }
            }
            offset += 1;
          } while (offset < data2.length - 2);
        }
        bitsCount = 0;
        marker = data2[offset] << 8 | data2[offset + 1];
        if (marker < 65280) {
          throw new Error("marker was not found");
        }
        if (marker >= 65488 && marker <= 65495) {
          offset += 2;
        } else
          break;
      }
      return offset - startOffset;
    }
    function buildComponentData(frame, component) {
      var lines = [];
      var blocksPerLine = component.blocksPerLine;
      var blocksPerColumn = component.blocksPerColumn;
      var samplesPerLine = blocksPerLine << 3;
      var R = new Int32Array(64), r = new Uint8Array(64);
      function quantizeAndInverse(zz, dataOut, dataIn) {
        var qt = component.quantizationTable;
        var v0, v1, v2, v3, v4, v5, v6, v7, t;
        var p = dataIn;
        var i3;
        for (i3 = 0;i3 < 64; i3++)
          p[i3] = zz[i3] * qt[i3];
        for (i3 = 0;i3 < 8; ++i3) {
          var row = 8 * i3;
          if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
            t = dctSqrt2 * p[0 + row] + 512 >> 10;
            p[0 + row] = t;
            p[1 + row] = t;
            p[2 + row] = t;
            p[3 + row] = t;
            p[4 + row] = t;
            p[5 + row] = t;
            p[6 + row] = t;
            p[7 + row] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
          v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
          v2 = p[2 + row];
          v3 = p[6 + row];
          v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
          v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
          v5 = p[3 + row] << 4;
          v6 = p[5 + row] << 4;
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 + row] = v0 + v7;
          p[7 + row] = v0 - v7;
          p[1 + row] = v1 + v6;
          p[6 + row] = v1 - v6;
          p[2 + row] = v2 + v5;
          p[5 + row] = v2 - v5;
          p[3 + row] = v3 + v4;
          p[4 + row] = v3 - v4;
        }
        for (i3 = 0;i3 < 8; ++i3) {
          var col = i3;
          if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
            t = dctSqrt2 * dataIn[i3 + 0] + 8192 >> 14;
            p[0 * 8 + col] = t;
            p[1 * 8 + col] = t;
            p[2 * 8 + col] = t;
            p[3 * 8 + col] = t;
            p[4 * 8 + col] = t;
            p[5 * 8 + col] = t;
            p[6 * 8 + col] = t;
            p[7 * 8 + col] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
          v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
          v2 = p[2 * 8 + col];
          v3 = p[6 * 8 + col];
          v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
          v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
          v5 = p[3 * 8 + col];
          v6 = p[5 * 8 + col];
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 * 8 + col] = v0 + v7;
          p[7 * 8 + col] = v0 - v7;
          p[1 * 8 + col] = v1 + v6;
          p[6 * 8 + col] = v1 - v6;
          p[2 * 8 + col] = v2 + v5;
          p[5 * 8 + col] = v2 - v5;
          p[3 * 8 + col] = v3 + v4;
          p[4 * 8 + col] = v3 - v4;
        }
        for (i3 = 0;i3 < 64; ++i3) {
          var sample2 = 128 + (p[i3] + 8 >> 4);
          dataOut[i3] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
        }
      }
      requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
      var i2, j;
      for (var blockRow = 0;blockRow < blocksPerColumn; blockRow++) {
        var scanLine = blockRow << 3;
        for (i2 = 0;i2 < 8; i2++)
          lines.push(new Uint8Array(samplesPerLine));
        for (var blockCol = 0;blockCol < blocksPerLine; blockCol++) {
          quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
          var offset = 0, sample = blockCol << 3;
          for (j = 0;j < 8; j++) {
            var line = lines[scanLine + j];
            for (i2 = 0;i2 < 8; i2++)
              line[sample + i2] = r[offset++];
          }
        }
      }
      return lines;
    }
    function clampTo8bit(a) {
      return a < 0 ? 0 : a > 255 ? 255 : a;
    }
    constructor.prototype = {
      load: function load(path2) {
        var xhr = new XMLHttpRequest;
        xhr.open("GET", path2, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function() {
          var data2 = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
          this.parse(data2);
          if (this.onload)
            this.onload();
        }.bind(this);
        xhr.send(null);
      },
      parse: function parse(data2) {
        var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;
        var offset = 0, length = data2.length;
        function readUint16() {
          var value2 = data2[offset] << 8 | data2[offset + 1];
          offset += 2;
          return value2;
        }
        function readDataBlock() {
          var length2 = readUint16();
          var array = data2.subarray(offset, offset + length2 - 2);
          offset += array.length;
          return array;
        }
        function prepareComponents(frame2) {
          var maxH2 = 1, maxV2 = 1;
          var component2, componentId2;
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              if (maxH2 < component2.h)
                maxH2 = component2.h;
              if (maxV2 < component2.v)
                maxV2 = component2.v;
            }
          }
          var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
          var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
              var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
              var blocksPerLineForMcu = mcusPerLine * component2.h;
              var blocksPerColumnForMcu = mcusPerColumn * component2.v;
              var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
              var blocks = [];
              requestMemoryAllocation(blocksToAllocate * 256);
              for (var i3 = 0;i3 < blocksPerColumnForMcu; i3++) {
                var row = [];
                for (var j2 = 0;j2 < blocksPerLineForMcu; j2++)
                  row.push(new Int32Array(64));
                blocks.push(row);
              }
              component2.blocksPerLine = blocksPerLine;
              component2.blocksPerColumn = blocksPerColumn;
              component2.blocks = blocks;
            }
          }
          frame2.maxH = maxH2;
          frame2.maxV = maxV2;
          frame2.mcusPerLine = mcusPerLine;
          frame2.mcusPerColumn = mcusPerColumn;
        }
        var jfif = null;
        var adobe = null;
        var pixels = null;
        var frame, resetInterval;
        var quantizationTables = [], frames = [];
        var huffmanTablesAC = [], huffmanTablesDC = [];
        var fileMarker = readUint16();
        var malformedDataOffset = -1;
        this.comments = [];
        if (fileMarker != 65496) {
          throw new Error("SOI not found");
        }
        fileMarker = readUint16();
        while (fileMarker != 65497) {
          var i2, j, l;
          switch (fileMarker) {
            case 65280:
              break;
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              var appData = readDataBlock();
              if (fileMarker === 65534) {
                var comment = String.fromCharCode.apply(null, appData);
                this.comments.push(comment);
              }
              if (fileMarker === 65504) {
                if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                  jfif = {
                    version: { major: appData[5], minor: appData[6] },
                    densityUnits: appData[7],
                    xDensity: appData[8] << 8 | appData[9],
                    yDensity: appData[10] << 8 | appData[11],
                    thumbWidth: appData[12],
                    thumbHeight: appData[13],
                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                  };
                }
              }
              if (fileMarker === 65505) {
                if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                  this.exifBuffer = appData.subarray(5, appData.length);
                }
              }
              if (fileMarker === 65518) {
                if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                  adobe = {
                    version: appData[6],
                    flags0: appData[7] << 8 | appData[8],
                    flags1: appData[9] << 8 | appData[10],
                    transformCode: appData[11]
                  };
                }
              }
              break;
            case 65499:
              var quantizationTablesLength = readUint16();
              var quantizationTablesEnd = quantizationTablesLength + offset - 2;
              while (offset < quantizationTablesEnd) {
                var quantizationTableSpec = data2[offset++];
                requestMemoryAllocation(64 * 4);
                var tableData = new Int32Array(64);
                if (quantizationTableSpec >> 4 === 0) {
                  for (j = 0;j < 64; j++) {
                    var z = dctZigZag[j];
                    tableData[z] = data2[offset++];
                  }
                } else if (quantizationTableSpec >> 4 === 1) {
                  for (j = 0;j < 64; j++) {
                    var z = dctZigZag[j];
                    tableData[z] = readUint16();
                  }
                } else
                  throw new Error("DQT: invalid table spec");
                quantizationTables[quantizationTableSpec & 15] = tableData;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              readUint16();
              frame = {};
              frame.extended = fileMarker === 65473;
              frame.progressive = fileMarker === 65474;
              frame.precision = data2[offset++];
              frame.scanLines = readUint16();
              frame.samplesPerLine = readUint16();
              frame.components = {};
              frame.componentsOrder = [];
              var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
              if (pixelsInFrame > maxResolutionInPixels) {
                var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
              }
              var componentsCount = data2[offset++], componentId;
              var maxH = 0, maxV = 0;
              for (i2 = 0;i2 < componentsCount; i2++) {
                componentId = data2[offset];
                var h = data2[offset + 1] >> 4;
                var v = data2[offset + 1] & 15;
                var qId = data2[offset + 2];
                if (h <= 0 || v <= 0) {
                  throw new Error("Invalid sampling factor, expected values above 0");
                }
                frame.componentsOrder.push(componentId);
                frame.components[componentId] = {
                  h,
                  v,
                  quantizationIdx: qId
                };
                offset += 3;
              }
              prepareComponents(frame);
              frames.push(frame);
              break;
            case 65476:
              var huffmanLength = readUint16();
              for (i2 = 2;i2 < huffmanLength; ) {
                var huffmanTableSpec = data2[offset++];
                var codeLengths = new Uint8Array(16);
                var codeLengthSum = 0;
                for (j = 0;j < 16; j++, offset++) {
                  codeLengthSum += codeLengths[j] = data2[offset];
                }
                requestMemoryAllocation(16 + codeLengthSum);
                var huffmanValues = new Uint8Array(codeLengthSum);
                for (j = 0;j < codeLengthSum; j++, offset++)
                  huffmanValues[j] = data2[offset];
                i2 += 17 + codeLengthSum;
                (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
              }
              break;
            case 65501:
              readUint16();
              resetInterval = readUint16();
              break;
            case 65500:
              readUint16();
              readUint16();
              break;
            case 65498:
              var scanLength = readUint16();
              var selectorsCount = data2[offset++];
              var components = [], component;
              for (i2 = 0;i2 < selectorsCount; i2++) {
                component = frame.components[data2[offset++]];
                var tableSpec = data2[offset++];
                component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                components.push(component);
              }
              var spectralStart = data2[offset++];
              var spectralEnd = data2[offset++];
              var successiveApproximation = data2[offset++];
              var processed = decodeScan(data2, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
              offset += processed;
              break;
            case 65535:
              if (data2[offset] !== 255) {
                offset--;
              }
              break;
            default:
              if (data2[offset - 3] == 255 && data2[offset - 2] >= 192 && data2[offset - 2] <= 254) {
                offset -= 3;
                break;
              } else if (fileMarker === 224 || fileMarker == 225) {
                if (malformedDataOffset !== -1) {
                  throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                }
                malformedDataOffset = offset - 1;
                const nextOffset = readUint16();
                if (data2[offset + nextOffset - 2] === 255) {
                  offset += nextOffset - 2;
                  break;
                }
              }
              throw new Error("unknown JPEG marker " + fileMarker.toString(16));
          }
          fileMarker = readUint16();
        }
        if (frames.length != 1)
          throw new Error("only single frame JPEGs supported");
        for (var i2 = 0;i2 < frames.length; i2++) {
          var cp = frames[i2].components;
          for (var j in cp) {
            cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
            delete cp[j].quantizationIdx;
          }
        }
        this.width = frame.samplesPerLine;
        this.height = frame.scanLines;
        this.jfif = jfif;
        this.adobe = adobe;
        this.components = [];
        for (var i2 = 0;i2 < frame.componentsOrder.length; i2++) {
          var component = frame.components[frame.componentsOrder[i2]];
          this.components.push({
            lines: buildComponentData(frame, component),
            scaleX: component.h / frame.maxH,
            scaleY: component.v / frame.maxV
          });
        }
      },
      getData: function getData(width, height) {
        var scaleX = this.width / width, scaleY = this.height / height;
        var component1, component2, component3, component4;
        var component1Line, component2Line, component3Line, component4Line;
        var x, y;
        var offset = 0;
        var Y, Cb, Cr, K, C, M, Ye, R, G, B;
        var colorTransform;
        var dataLength = width * height * this.components.length;
        requestMemoryAllocation(dataLength);
        var data2 = new Uint8Array(dataLength);
        switch (this.components.length) {
          case 1:
            component1 = this.components[0];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                Y = component1Line[0 | x * component1.scaleX * scaleX];
                data2[offset++] = Y;
              }
            }
            break;
          case 2:
            component1 = this.components[0];
            component2 = this.components[1];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                Y = component1Line[0 | x * component1.scaleX * scaleX];
                data2[offset++] = Y;
                Y = component2Line[0 | x * component2.scaleX * scaleX];
                data2[offset++] = Y;
              }
            }
            break;
          case 3:
            colorTransform = true;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                if (!colorTransform) {
                  R = component1Line[0 | x * component1.scaleX * scaleX];
                  G = component2Line[0 | x * component2.scaleX * scaleX];
                  B = component3Line[0 | x * component3.scaleX * scaleX];
                } else {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x * component3.scaleX * scaleX];
                  R = clampTo8bit(Y + 1.402 * (Cr - 128));
                  G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  B = clampTo8bit(Y + 1.772 * (Cb - 128));
                }
                data2[offset++] = R;
                data2[offset++] = G;
                data2[offset++] = B;
              }
            }
            break;
          case 4:
            if (!this.adobe)
              throw new Error("Unsupported color mode (4 components)");
            colorTransform = false;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            component4 = this.components[3];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
              component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                if (!colorTransform) {
                  C = component1Line[0 | x * component1.scaleX * scaleX];
                  M = component2Line[0 | x * component2.scaleX * scaleX];
                  Ye = component3Line[0 | x * component3.scaleX * scaleX];
                  K = component4Line[0 | x * component4.scaleX * scaleX];
                } else {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x * component3.scaleX * scaleX];
                  K = component4Line[0 | x * component4.scaleX * scaleX];
                  C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                  M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                }
                data2[offset++] = 255 - C;
                data2[offset++] = 255 - M;
                data2[offset++] = 255 - Ye;
                data2[offset++] = 255 - K;
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
        return data2;
      },
      copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
        var { width, height } = imageData;
        var imageDataArray = imageData.data;
        var data2 = this.getData(width, height);
        var i2 = 0, j = 0, x, y;
        var Y, K, C, M, R, G, B;
        switch (this.components.length) {
          case 1:
            for (y = 0;y < height; y++) {
              for (x = 0;x < width; x++) {
                Y = data2[i2++];
                imageDataArray[j++] = Y;
                imageDataArray[j++] = Y;
                imageDataArray[j++] = Y;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 3:
            for (y = 0;y < height; y++) {
              for (x = 0;x < width; x++) {
                R = data2[i2++];
                G = data2[i2++];
                B = data2[i2++];
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 4:
            for (y = 0;y < height; y++) {
              for (x = 0;x < width; x++) {
                C = data2[i2++];
                M = data2[i2++];
                Y = data2[i2++];
                K = data2[i2++];
                R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
      }
    };
    var totalBytesAllocated = 0;
    var maxMemoryUsageBytes = 0;
    function requestMemoryAllocation(increaseAmount = 0) {
      var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
      if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
        var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
        throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
      }
      totalBytesAllocated = totalMemoryImpactBytes;
    }
    constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
      totalBytesAllocated = 0;
      maxMemoryUsageBytes = maxMemoryUsageBytes_;
    };
    constructor.getBytesAllocated = function() {
      return totalBytesAllocated;
    };
    constructor.requestMemoryAllocation = requestMemoryAllocation;
    return constructor;
  }();
  if (typeof module !== "undefined") {
    module.exports = decode;
  } else if (typeof window !== "undefined") {
    window["jpeg-js"] = window["jpeg-js"] || {};
    window["jpeg-js"].decode = decode;
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS((exports, module) => {
  var encode = require_encoder();
  var decode = require_decoder();
  module.exports = {
    encode,
    decode
  };
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var Stream = import.meta.require("stream");
  var ChunkStream = module.exports = function() {
    Stream.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util.inherits(ChunkStream, Stream);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(function() {
      this._process();
      if (this._paused && this._reads && this._reads.length > 0) {
        this._paused = false;
        this.emit("drain");
      }
    }.bind(this));
  };
  ChunkStream.prototype.write = function(data2, encoding) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    let dataBuffer;
    if (Buffer.isBuffer(data2)) {
      dataBuffer = data2;
    } else {
      dataBuffer = Buffer.from(data2, encoding || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data2, encoding) {
    if (data2) {
      this.write(data2, encoding);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    let smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    let pos = 0;
    let count = 0;
    let data2 = Buffer.alloc(read.length);
    while (pos < read.length) {
      let buf = this._buffers[count++];
      let len = Math.min(buf.length, read.length - pos);
      buf.copy(data2, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count] = buf.slice(len);
      }
    }
    if (count > 0) {
      this._buffers.splice(0, count);
    }
    this._buffered -= read.length;
    read.func.call(this, data2);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        let read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS((exports) => {
  var imagePasses = [
    {
      x: [0],
      y: [0]
    },
    {
      x: [4],
      y: [0]
    },
    {
      x: [0, 4],
      y: [4]
    },
    {
      x: [2, 6],
      y: [0, 4]
    },
    {
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  exports.getImagePasses = function(width, height) {
    let images = [];
    let xLeftOver = width % 8;
    let yLeftOver = height % 8;
    let xRepeats = (width - xLeftOver) / 8;
    let yRepeats = (height - yLeftOver) / 8;
    for (let i2 = 0;i2 < imagePasses.length; i2++) {
      let pass = imagePasses[i2];
      let passWidth = xRepeats * pass.x.length;
      let passHeight = yRepeats * pass.y.length;
      for (let j = 0;j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (let j = 0;j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i2 });
      }
    }
    return images;
  };
  exports.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      let outerXLeftOver = x % imagePasses[pass].x.length;
      let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      let outerYLeftOver = y % imagePasses[pass].y.length;
      let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS((exports, module) => {
  module.exports = function paethPredictor(left, above, upLeft) {
    let paeth = left + above - upLeft;
    let pLeft = Math.abs(paeth - left);
    let pAbove = Math.abs(paeth - above);
    let pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  };
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS((exports, module) => {
  var getByteWidth = function(width, bpp, depth) {
    let byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  };
  var interlaceUtils = require_interlace();
  var paethPredictor = require_paeth_predictor();
  var Filter = module.exports = function(bitmapInfo, dependencies) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let interlace = bitmapInfo.interlace;
    let bpp = bitmapInfo.bpp;
    let depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace) {
      let passes = interlaceUtils.getImagePasses(width, height);
      for (let i2 = 0;i2 < passes.length; i2++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i2].width, bpp, depth),
          height: passes[i2].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f3Up = lastLine ? lastLine[x] : 0;
      let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f4Up = lastLine ? lastLine[x] : 0;
      let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    let filter = rawData[0];
    let unfilteredLine;
    let currentImage = this._images[this._imageIndex];
    let byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = Buffer.alloc(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var ChunkStream = require_chunkstream();
  var Filter = require_filter_parse();
  var FilterAsync = module.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    let buffers = [];
    let that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: function(buffer) {
        buffers.push(buffer);
      },
      complete: function() {
        that.emit("complete", Buffer.concat(buffers));
      }
    });
    this._filter.start();
  };
  util.inherits(FilterAsync, ChunkStream);
});

// node_modules/pngjs/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    TYPE_gAMA: 1732332865,
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS((exports, module) => {
  var crcTable = [];
  (function() {
    for (let i2 = 0;i2 < 256; i2++) {
      let currentCrc = i2;
      for (let j = 0;j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i2] = currentCrc;
    }
  })();
  var CrcCalculator = module.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data2) {
    for (let i2 = 0;i2 < data2.length; i2++) {
      this._crc = crcTable[(this._crc ^ data2[i2]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    let crc = -1;
    for (let i2 = 0;i2 < buf.length; i2++) {
      crc = crcTable[(crc ^ buf[i2]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  };
});

// node_modules/pngjs/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var constants2 = require_constants();
  var CrcCalculator = require_crc();
  var Parser = module.exports = function(options, dependencies) {
    this._options = options;
    options.checkCRC = options.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants2.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants2.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants2.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants2.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants2.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants2.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {
    };
  };
  Parser.prototype.start = function() {
    this.read(constants2.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser.prototype._parseSignature = function(data2) {
    let signature = constants2.PNG_SIGNATURE;
    for (let i2 = 0;i2 < signature.length; i2++) {
      if (data2[i2] !== signature[i2]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._parseChunkBegin = function(data2) {
    let length = data2.readUInt32BE(0);
    let type = data2.readUInt32BE(4);
    let name2 = "";
    for (let i2 = 4;i2 < 8; i2++) {
      name2 += String.fromCharCode(data2[i2]);
    }
    let ancillary = Boolean(data2[4] & 32);
    if (!this._hasIHDR && type !== constants2.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator;
    this._crc.write(Buffer.from(name2));
    if (this._chunks[type]) {
      return this._chunks[type](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name2));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser.prototype._parseChunkEnd = function(data2) {
    let fileCrc = data2.readInt32BE(0);
    let calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser.prototype._parseIHDR = function(data2) {
    this._crc.write(data2);
    let width = data2.readUInt32BE(0);
    let height = data2.readUInt32BE(4);
    let depth = data2[8];
    let colorType = data2[9];
    let compr = data2[10];
    let filter = data2[11];
    let interlace = data2[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants2.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace !== 0 && interlace !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace),
      palette: Boolean(colorType & constants2.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants2.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants2.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser.prototype._parsePLTE = function(data2) {
    this._crc.write(data2);
    let entries = Math.floor(data2.length / 3);
    for (let i2 = 0;i2 < entries; i2++) {
      this._palette.push([data2[i2 * 3], data2[i2 * 3 + 1], data2[i2 * 3 + 2], 255]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser.prototype._parseTRNS = function(data2) {
    this._crc.write(data2);
    if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data2.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (let i2 = 0;i2 < data2.length; i2++) {
        this._palette[i2][3] = data2[i2];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants2.COLORTYPE_GRAYSCALE) {
      this.transColor([data2.readUInt16BE(0)]);
    }
    if (this._colorType === constants2.COLORTYPE_COLOR) {
      this.transColor([
        data2.readUInt16BE(0),
        data2.readUInt16BE(2),
        data2.readUInt16BE(4)
      ]);
    }
    this._handleChunkEnd();
  };
  Parser.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser.prototype._parseGAMA = function(data2) {
    this._crc.write(data2);
    this.gamma(data2.readUInt32BE(0) / constants2.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser.prototype._parseIDAT = function(length, data2) {
    this._crc.write(data2);
    if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data2);
    let leftOverLength = length - data2.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser.prototype._parseIEND = function(data2) {
    this._crc.write(data2);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS((exports) => {
  var bitRetriever = function(data2, depth) {
    let leftOver = [];
    let i2 = 0;
    function split() {
      if (i2 === data2.length) {
        throw new Error("Ran out of data");
      }
      let byte = data2[i2];
      i2++;
      let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data2[i2];
          i2++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    return {
      get: function(count) {
        while (leftOver.length < count) {
          split();
        }
        let returner = leftOver.slice(0, count);
        leftOver = leftOver.slice(count);
        return returner;
      },
      resetAfterLine: function() {
        leftOver.length = 0;
      },
      end: function() {
        if (i2 !== data2.length) {
          throw new Error("extra data found");
        }
      }
    };
  };
  var mapImage8Bit = function(image2, pxData, getPxPos, bpp, data2, rawPos) {
    let imageWidth = image2.width;
    let imageHeight = image2.height;
    let imagePass = image2.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data2, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  };
  var mapImageCustomBit = function(image2, pxData, getPxPos, bpp, bits, maxBit) {
    let imageWidth = image2.width;
    let imageHeight = image2.height;
    let imagePass = image2.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pixelData = bits.get(bpp);
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  };
  var interlaceUtils = require_interlace();
  var pixelBppMapper = [
    function() {
    },
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos === data2.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data2[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 1 >= data2.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data2[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data2[rawPos + 1];
    },
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 2 >= data2.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data2[rawPos];
      pxData[pxPos + 1] = data2[rawPos + 1];
      pxData[pxPos + 2] = data2[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 3 >= data2.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data2[rawPos];
      pxData[pxPos + 1] = data2[rawPos + 1];
      pxData[pxPos + 2] = data2[rawPos + 2];
      pxData[pxPos + 3] = data2[rawPos + 3];
    }
  ];
  var pixelBppCustomMapper = [
    function() {
    },
    function(pxData, pixelData, pxPos, maxBit) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  exports.dataToBitMap = function(data2, bitmapInfo) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let depth = bitmapInfo.depth;
    let bpp = bitmapInfo.bpp;
    let interlace = bitmapInfo.interlace;
    let bits;
    if (depth !== 8) {
      bits = bitRetriever(data2, depth);
    }
    let pxData;
    if (depth <= 8) {
      pxData = Buffer.alloc(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    let maxBit = Math.pow(2, depth) - 1;
    let rawPos = 0;
    let images;
    let getPxPos;
    if (interlace) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      let nonInterlacedPxPos = 0;
      getPxPos = function() {
        let returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      };
      images = [{ width, height }];
    }
    for (let imageIndex = 0;imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data2, rawPos);
      } else {
        mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
      }
    }
    if (depth === 8) {
      if (rawPos !== data2.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS((exports, module) => {
  var dePalette = function(indata, outdata, width, height, palette2) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let color = palette2[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (let i2 = 0;i2 < 4; i2++) {
          outdata[pxPos + i2] = color[i2];
        }
        pxPos += 4;
      }
    }
  };
  var replaceTransparentColor = function(indata, outdata, width, height, transColor) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (let i2 = 0;i2 < 4; i2++) {
            outdata[pxPos + i2] = 0;
          }
        }
        pxPos += 4;
      }
    }
  };
  var scaleDepth = function(indata, outdata, width, height, depth) {
    let maxOutSample = 255;
    let maxInSample = Math.pow(2, depth) - 1;
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        for (let i2 = 0;i2 < 4; i2++) {
          outdata[pxPos + i2] = Math.floor(indata[pxPos + i2] * maxOutSample / maxInSample + 0.5);
        }
        pxPos += 4;
      }
    }
  };
  module.exports = function(indata, imageData, skipRescale = false) {
    let depth = imageData.depth;
    let width = imageData.width;
    let height = imageData.height;
    let colorType = imageData.colorType;
    let transColor = imageData.transColor;
    let palette2 = imageData.palette;
    let outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette2);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8 && !skipRescale) {
        if (depth === 16) {
          outdata = Buffer.alloc(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  };
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var zlib = import.meta.require("zlib");
  var ChunkStream = require_chunkstream();
  var FilterAsync = require_filter_parse_async();
  var Parser = require_parser2();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  var ParserAsync = module.exports = function(options) {
    ChunkStream.call(this);
    this._parser = new Parser(options, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options;
    this.writable = true;
    this._parser.start();
  };
  util.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {
      });
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data2) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        let imageSize = rowSize * this._bitmapInfo.height;
        let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
        this._inflate = zlib.createInflate({ chunkSize });
        let leftToInflate = imageSize;
        let emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        let filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data2);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette2) {
    this._bitmapInfo.palette = palette2;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    let normalisedBitmapData;
    try {
      let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
      normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo, this._options.skipRescale);
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS((exports, module) => {
  var constants2 = require_constants();
  module.exports = function(dataIn, width, height, options) {
    let outHasAlpha = [constants2.COLORTYPE_COLOR_ALPHA, constants2.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
    if (options.colorType === options.inputColorType) {
      let bigEndian = function() {
        let buffer = new ArrayBuffer(2);
        new DataView(buffer).setInt16(0, 256, true);
        return new Int16Array(buffer)[0] !== 256;
      }();
      if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    let data2 = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    let maxValue = 255;
    let inBpp = constants2.COLORTYPE_TO_BPP_MAP[options.inputColorType];
    if (inBpp === 4 && !options.inputHasAlpha) {
      inBpp = 3;
    }
    let outBpp = constants2.COLORTYPE_TO_BPP_MAP[options.colorType];
    if (options.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    let outData = Buffer.alloc(width * height * outBpp);
    let inIndex = 0;
    let outIndex = 0;
    let bgColor = options.bgColor || {};
    if (bgColor.red === undefined) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === undefined) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === undefined) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      let red;
      let green;
      let blue;
      let alpha = maxValue;
      switch (options.inputColorType) {
        case constants2.COLORTYPE_COLOR_ALPHA:
          alpha = data2[inIndex + 3];
          red = data2[inIndex];
          green = data2[inIndex + 1];
          blue = data2[inIndex + 2];
          break;
        case constants2.COLORTYPE_COLOR:
          red = data2[inIndex];
          green = data2[inIndex + 1];
          blue = data2[inIndex + 2];
          break;
        case constants2.COLORTYPE_ALPHA:
          alpha = data2[inIndex + 1];
          red = data2[inIndex];
          green = red;
          blue = red;
          break;
        case constants2.COLORTYPE_GRAYSCALE:
          red = data2[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error("input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
          green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
          blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
        }
      }
      return { red, green, blue, alpha };
    }
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let rgba = getRGBA(data2, inIndex);
        switch (options.colorType) {
          case constants2.COLORTYPE_COLOR_ALPHA:
          case constants2.COLORTYPE_COLOR:
            if (options.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants2.COLORTYPE_ALPHA:
          case constants2.COLORTYPE_GRAYSCALE: {
            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          }
          default:
            throw new Error("unrecognised color Type " + options.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  };
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS((exports, module) => {
  var filterNone = function(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  };
  var filterSumNone = function(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let i2 = pxPos;i2 < length; i2++) {
      sum += Math.abs(pxData[i2]);
    }
    return sum;
  };
  var filterSub = function(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  };
  var filterSumSub = function(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  };
  var filterUp = function(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  };
  var filterSumUp = function(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let x = pxPos;x < length; x++) {
      let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      let val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  };
  var filterAvg = function(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  };
  var filterSumAvg = function(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  };
  var filterPaeth = function(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  };
  var filterSumPaeth = function(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  };
  var paethPredictor = require_paeth_predictor();
  var filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  var filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  module.exports = function(pxData, width, height, options, bpp) {
    let filterTypes;
    if (!("filterType" in options) || options.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options.filterType === "number") {
      filterTypes = [options.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options.bitDepth === 16) {
      bpp *= 2;
    }
    let byteWidth = width * bpp;
    let rawPos = 0;
    let pxPos = 0;
    let rawData = Buffer.alloc((byteWidth + 1) * height);
    let sel = filterTypes[0];
    for (let y = 0;y < height; y++) {
      if (filterTypes.length > 1) {
        let min = Infinity;
        for (let i2 = 0;i2 < filterTypes.length; i2++) {
          let sum = filterSums[filterTypes[i2]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i2];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  };
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS((exports, module) => {
  var constants2 = require_constants();
  var CrcStream = require_crc();
  var bitPacker = require_bitpacker();
  var filter = require_filter_pack();
  var zlib = import.meta.require("zlib");
  var Packer = module.exports = function(options) {
    this._options = options;
    options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
    options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
    options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
    options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
    options.deflateFactory = options.deflateFactory || zlib.createDeflate;
    options.bitDepth = options.bitDepth || 8;
    options.colorType = typeof options.colorType === "number" ? options.colorType : constants2.COLORTYPE_COLOR_ALPHA;
    options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants2.COLORTYPE_COLOR_ALPHA;
    if ([
      constants2.COLORTYPE_GRAYSCALE,
      constants2.COLORTYPE_COLOR,
      constants2.COLORTYPE_COLOR_ALPHA,
      constants2.COLORTYPE_ALPHA
    ].indexOf(options.colorType) === -1) {
      throw new Error("option color type:" + options.colorType + " is not supported at present");
    }
    if ([
      constants2.COLORTYPE_GRAYSCALE,
      constants2.COLORTYPE_COLOR,
      constants2.COLORTYPE_COLOR_ALPHA,
      constants2.COLORTYPE_ALPHA
    ].indexOf(options.inputColorType) === -1) {
      throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
    }
    if (options.bitDepth !== 8 && options.bitDepth !== 16) {
      throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data2, width, height) {
    let packedData = bitPacker(data2, width, height, this._options);
    let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    let filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type, data2) {
    let len = data2 ? data2.length : 0;
    let buf = Buffer.alloc(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type, 4);
    if (data2) {
      data2.copy(buf, 8);
    }
    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    let buf = Buffer.alloc(4);
    buf.writeUInt32BE(Math.floor(gamma * constants2.GAMMA_DIVISION), 0);
    return this._packChunk(constants2.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    let buf = Buffer.alloc(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants2.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data2) {
    return this._packChunk(constants2.TYPE_IDAT, data2);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants2.TYPE_IEND, null);
  };
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var Stream = import.meta.require("stream");
  var constants2 = require_constants();
  var Packer = require_packer();
  var PackerAsync = module.exports = function(opt) {
    Stream.call(this);
    let options = opt || {};
    this._packer = new Packer(options);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util.inherits(PackerAsync, Stream);
  PackerAsync.prototype.pack = function(data2, width, height, gamma) {
    this.emit("data", Buffer.from(constants2.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    let filteredData = this._packer.filterData(data2, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on("data", function(compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }.bind(this));
    this._deflate.on("end", function() {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }.bind(this));
    this._deflate.end(filteredData);
  };
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS((exports, module) => {
  var Inflate = function(opts) {
    if (!(this instanceof Inflate)) {
      return new Inflate(opts);
    }
    if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
      opts.chunkSize = zlib.Z_MIN_CHUNK;
    }
    zlib.Inflate.call(this, opts);
    this._offset = this._offset === undefined ? this._outOffset : this._offset;
    this._buffer = this._buffer || this._outBuffer;
    if (opts && opts.maxLength != null) {
      this._maxLength = opts.maxLength;
    }
  };
  var createInflate = function(opts) {
    return new Inflate(opts);
  };
  var _close = function(engine, callback) {
    if (callback) {
      process.nextTick(callback);
    }
    if (!engine._handle) {
      return;
    }
    engine._handle.close();
    engine._handle = null;
  };
  var zlibBufferSync = function(engine, buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer);
    }
    if (!(buffer instanceof Buffer)) {
      throw new TypeError("Not a string or buffer");
    }
    let flushFlag = engine._finishFlushFlag;
    if (flushFlag == null) {
      flushFlag = zlib.Z_FINISH;
    }
    return engine._processChunk(buffer, flushFlag);
  };
  var inflateSync = function(buffer, opts) {
    return zlibBufferSync(new Inflate(opts), buffer);
  };
  var assert = import.meta.require("assert").ok;
  var zlib = import.meta.require("zlib");
  var util = import.meta.require("util");
  var kMaxLength = import.meta.require("buffer").kMaxLength;
  Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
    if (typeof asyncCb === "function") {
      return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
    }
    let self2 = this;
    let availInBefore = chunk && chunk.length;
    let availOutBefore = this._chunkSize - this._offset;
    let leftToInflate = this._maxLength;
    let inOff = 0;
    let buffers = [];
    let nread = 0;
    let error;
    this.on("error", function(err) {
      error = err;
    });
    function handleChunk(availInAfter, availOutAfter) {
      if (self2._hadError) {
        return;
      }
      let have = availOutBefore - availOutAfter;
      assert(have >= 0, "have should not go down");
      if (have > 0) {
        let out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (out.length > leftToInflate) {
          out = out.slice(0, leftToInflate);
        }
        buffers.push(out);
        nread += out.length;
        leftToInflate -= out.length;
        if (leftToInflate === 0) {
          return false;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        return true;
      }
      return false;
    }
    assert(this._handle, "zlib binding closed");
    let res;
    do {
      res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      res = res || this._writeState;
    } while (!this._hadError && handleChunk(res[0], res[1]));
    if (this._hadError) {
      throw error;
    }
    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
    }
    let buf = Buffer.concat(buffers, nread);
    _close(this);
    return buf;
  };
  util.inherits(Inflate, zlib.Inflate);
  module.exports = exports = inflateSync;
  exports.Inflate = Inflate;
  exports.createInflate = createInflate;
  exports.inflateSync = inflateSync;
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS((exports, module) => {
  var SyncReader = module.exports = function(buffer) {
    this._buffer = buffer;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      let read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        let buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      throw new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      throw new Error("unrecognised content at end of stream");
    }
  };
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS((exports) => {
  var SyncReader = require_sync_reader();
  var Filter = require_filter_parse();
  exports.process = function(inBuffer, bitmapInfo) {
    let outBuffers = [];
    let reader = new SyncReader(inBuffer);
    let filter = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: function(bufferPart) {
        outBuffers.push(bufferPart);
      },
      complete: function() {
      }
    });
    filter.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = import.meta.require("zlib");
  var inflateSync = require_sync_inflate();
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var SyncReader = require_sync_reader();
  var FilterSync = require_filter_parse_sync();
  var Parser = require_parser2();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  module.exports = function(buffer, options) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let err;
    function handleError(_err_) {
      err = _err_;
    }
    let metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    function handlePalette(palette2) {
      metaData.palette = palette2;
    }
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    let gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    let inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    let reader = new SyncReader(buffer);
    let parser = new Parser(options, {
      read: reader.read.bind(reader),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser.start();
    reader.process();
    if (err) {
      throw err;
    }
    let inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    let inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib.inflateSync(inflateData);
    } else {
      let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      let imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {
        chunkSize: imageSize,
        maxLength: imageSize
      });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    let unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    let normalisedBitmapData = formatNormaliser(bitmapData, metaData, options.skipRescale);
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  };
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = import.meta.require("zlib");
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var constants2 = require_constants();
  var Packer = require_packer();
  module.exports = function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let options = opt || {};
    let packer = new Packer(options);
    let chunks = [];
    chunks.push(Buffer.from(constants2.PNG_SIGNATURE));
    chunks.push(packer.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer.packGAMA(metaData.gamma));
    }
    let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
    let compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer.packIDAT(compressedData));
    chunks.push(packer.packIEND());
    return Buffer.concat(chunks);
  };
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS((exports) => {
  var parse = require_parser_sync();
  var pack = require_packer_sync();
  exports.read = function(buffer, options) {
    return parse(buffer, options || {});
  };
  exports.write = function(png, options) {
    return pack(png, options);
  };
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS((exports) => {
  var util = import.meta.require("util");
  var Stream = import.meta.require("stream");
  var Parser = require_parser_async();
  var Packer = require_packer_async();
  var PNGSync = require_png_sync();
  var PNG = exports.PNG = function(options) {
    Stream.call(this);
    options = options || {};
    this.width = options.width | 0;
    this.height = options.height | 0;
    this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
    if (options.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser(options);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on("parsed", function(data2) {
      this.data = data2;
      this.emit("parsed", data2);
    }.bind(this));
    this._packer = new Packer(options);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util.inherits(PNG, Stream);
  PNG.sync = PNGSync;
  PNG.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(function() {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }.bind(this));
    return this;
  };
  PNG.prototype.parse = function(data2, callback) {
    if (callback) {
      let onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data2);
    return this;
  };
  PNG.prototype.write = function(data2) {
    this._parser.write(data2);
    return true;
  };
  PNG.prototype.end = function(data2) {
    this._parser.end(data2);
  };
  PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (let y = 0;y < height; y++) {
      src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
    }
  };
  PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG.adjustGamma = function(src) {
    if (src.gamma) {
      for (let y = 0;y < src.height; y++) {
        for (let x = 0;x < src.width; x++) {
          let idx = src.width * y + x << 2;
          for (let i2 = 0;i2 < 3; i2++) {
            let sample = src.data[idx + i2] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma);
            src.data[idx + i2] = Math.round(sample * 255);
          }
        }
      }
      src.gamma = 0;
    }
  };
  PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
  };
});

// node_modules/bmp-js/lib/encoder.js
var require_encoder2 = __commonJS((exports, module) => {
  var BmpEncoder = function(imgData) {
    this.buffer = imgData.data;
    this.width = imgData.width;
    this.height = imgData.height;
    this.extraBytes = this.width % 4;
    this.rgbSize = this.height * (3 * this.width + this.extraBytes);
    this.headerInfoSize = 40;
    this.data = [];
    this.flag = "BM";
    this.reserved = 0;
    this.offset = 54;
    this.fileSize = this.rgbSize + this.offset;
    this.planes = 1;
    this.bitPP = 24;
    this.compress = 0;
    this.hr = 0;
    this.vr = 0;
    this.colors = 0;
    this.importantColors = 0;
  };
  BmpEncoder.prototype.encode = function() {
    var tempBuffer = new Buffer(this.offset + this.rgbSize);
    this.pos = 0;
    tempBuffer.write(this.flag, this.pos, 2);
    this.pos += 2;
    tempBuffer.writeUInt32LE(this.fileSize, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.reserved, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.offset, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.headerInfoSize, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.width, this.pos);
    this.pos += 4;
    tempBuffer.writeInt32LE(-this.height, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt16LE(this.planes, this.pos);
    this.pos += 2;
    tempBuffer.writeUInt16LE(this.bitPP, this.pos);
    this.pos += 2;
    tempBuffer.writeUInt32LE(this.compress, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.rgbSize, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.hr, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.vr, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.colors, this.pos);
    this.pos += 4;
    tempBuffer.writeUInt32LE(this.importantColors, this.pos);
    this.pos += 4;
    var i2 = 0;
    var rowBytes = 3 * this.width + this.extraBytes;
    for (var y = 0;y < this.height; y++) {
      for (var x = 0;x < this.width; x++) {
        var p = this.pos + y * rowBytes + x * 3;
        i2++;
        tempBuffer[p] = this.buffer[i2++];
        tempBuffer[p + 1] = this.buffer[i2++];
        tempBuffer[p + 2] = this.buffer[i2++];
      }
      if (this.extraBytes > 0) {
        var fillOffset = this.pos + y * rowBytes + this.width * 3;
        tempBuffer.fill(0, fillOffset, fillOffset + this.extraBytes);
      }
    }
    return tempBuffer;
  };
  module.exports = function(imgData, quality2) {
    if (typeof quality2 === "undefined")
      quality2 = 100;
    var encoder = new BmpEncoder(imgData);
    var data2 = encoder.encode();
    return {
      data: data2,
      width: imgData.width,
      height: imgData.height
    };
  };
});

// node_modules/bmp-js/lib/decoder.js
var require_decoder2 = __commonJS((exports, module) => {
  var BmpDecoder = function(buffer, is_with_alpha) {
    this.pos = 0;
    this.buffer = buffer;
    this.is_with_alpha = !!is_with_alpha;
    this.bottom_up = true;
    this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
    if (this.flag != "BM")
      throw new Error("Invalid BMP File");
    this.parseHeader();
    this.parseRGBA();
  };
  BmpDecoder.prototype.parseHeader = function() {
    this.fileSize = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.reserved = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.offset = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.headerSize = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.width = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.height = this.buffer.readInt32LE(this.pos);
    this.pos += 4;
    this.planes = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.bitPP = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.compress = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.rawSize = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.hr = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.vr = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.colors = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    this.importantColors = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    if (this.bitPP === 16 && this.is_with_alpha) {
      this.bitPP = 15;
    }
    if (this.bitPP < 15) {
      var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
      this.palette = new Array(len);
      for (var i2 = 0;i2 < len; i2++) {
        var blue = this.buffer.readUInt8(this.pos++);
        var green = this.buffer.readUInt8(this.pos++);
        var red = this.buffer.readUInt8(this.pos++);
        var quad = this.buffer.readUInt8(this.pos++);
        this.palette[i2] = {
          red,
          green,
          blue,
          quad
        };
      }
    }
    if (this.height < 0) {
      this.height *= -1;
      this.bottom_up = false;
    }
  };
  BmpDecoder.prototype.parseRGBA = function() {
    var bitn = "bit" + this.bitPP;
    var len = this.width * this.height * 4;
    this.data = new Buffer(len);
    this[bitn]();
  };
  BmpDecoder.prototype.bit1 = function() {
    var xlen = Math.ceil(this.width / 8);
    var mode = xlen % 4;
    var y = this.height >= 0 ? this.height - 1 : -this.height;
    for (var y = this.height - 1;y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0;x < xlen; x++) {
        var b = this.buffer.readUInt8(this.pos++);
        var location = line * this.width * 4 + x * 8 * 4;
        for (var i2 = 0;i2 < 8; i2++) {
          if (x * 8 + i2 < this.width) {
            var rgb = this.palette[b >> 7 - i2 & 1];
            this.data[location + i2 * 4] = 0;
            this.data[location + i2 * 4 + 1] = rgb.blue;
            this.data[location + i2 * 4 + 2] = rgb.green;
            this.data[location + i2 * 4 + 3] = rgb.red;
          } else {
            break;
          }
        }
      }
      if (mode != 0) {
        this.pos += 4 - mode;
      }
    }
  };
  BmpDecoder.prototype.bit4 = function() {
    if (this.compress == 2) {
      let setPixelData2 = function(rgbIndex) {
        var rgb2 = this.palette[rgbIndex];
        this.data[location] = 0;
        this.data[location + 1] = rgb2.blue;
        this.data[location + 2] = rgb2.green;
        this.data[location + 3] = rgb2.red;
        location += 4;
      };
      var setPixelData = setPixelData2;
      this.data.fill(255);
      var location = 0;
      var lines = this.bottom_up ? this.height - 1 : 0;
      var low_nibble = false;
      while (location < this.data.length) {
        var a = this.buffer.readUInt8(this.pos++);
        var b = this.buffer.readUInt8(this.pos++);
        if (a == 0) {
          if (b == 0) {
            if (this.bottom_up) {
              lines--;
            } else {
              lines++;
            }
            location = lines * this.width * 4;
            low_nibble = false;
            continue;
          } else if (b == 1) {
            break;
          } else if (b == 2) {
            var x = this.buffer.readUInt8(this.pos++);
            var y = this.buffer.readUInt8(this.pos++);
            if (this.bottom_up) {
              lines -= y;
            } else {
              lines += y;
            }
            location += y * this.width * 4 + x * 4;
          } else {
            var c2 = this.buffer.readUInt8(this.pos++);
            for (var i2 = 0;i2 < b; i2++) {
              if (low_nibble) {
                setPixelData2.call(this, c2 & 15);
              } else {
                setPixelData2.call(this, (c2 & 240) >> 4);
              }
              if (i2 & 1 && i2 + 1 < b) {
                c2 = this.buffer.readUInt8(this.pos++);
              }
              low_nibble = !low_nibble;
            }
            if ((b + 1 >> 1 & 1) == 1) {
              this.pos++;
            }
          }
        } else {
          for (var i2 = 0;i2 < a; i2++) {
            if (low_nibble) {
              setPixelData2.call(this, b & 15);
            } else {
              setPixelData2.call(this, (b & 240) >> 4);
            }
            low_nibble = !low_nibble;
          }
        }
      }
    } else {
      var xlen = Math.ceil(this.width / 2);
      var mode = xlen % 4;
      for (var y = this.height - 1;y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0;x < xlen; x++) {
          var b = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 2 * 4;
          var before = b >> 4;
          var after = b & 15;
          var rgb = this.palette[before];
          this.data[location] = 0;
          this.data[location + 1] = rgb.blue;
          this.data[location + 2] = rgb.green;
          this.data[location + 3] = rgb.red;
          if (x * 2 + 1 >= this.width)
            break;
          rgb = this.palette[after];
          this.data[location + 4] = 0;
          this.data[location + 4 + 1] = rgb.blue;
          this.data[location + 4 + 2] = rgb.green;
          this.data[location + 4 + 3] = rgb.red;
        }
        if (mode != 0) {
          this.pos += 4 - mode;
        }
      }
    }
  };
  BmpDecoder.prototype.bit8 = function() {
    if (this.compress == 1) {
      let setPixelData2 = function(rgbIndex) {
        var rgb2 = this.palette[rgbIndex];
        this.data[location] = 0;
        this.data[location + 1] = rgb2.blue;
        this.data[location + 2] = rgb2.green;
        this.data[location + 3] = rgb2.red;
        location += 4;
      };
      var setPixelData = setPixelData2;
      this.data.fill(255);
      var location = 0;
      var lines = this.bottom_up ? this.height - 1 : 0;
      while (location < this.data.length) {
        var a = this.buffer.readUInt8(this.pos++);
        var b = this.buffer.readUInt8(this.pos++);
        if (a == 0) {
          if (b == 0) {
            if (this.bottom_up) {
              lines--;
            } else {
              lines++;
            }
            location = lines * this.width * 4;
            continue;
          } else if (b == 1) {
            break;
          } else if (b == 2) {
            var x = this.buffer.readUInt8(this.pos++);
            var y = this.buffer.readUInt8(this.pos++);
            if (this.bottom_up) {
              lines -= y;
            } else {
              lines += y;
            }
            location += y * this.width * 4 + x * 4;
          } else {
            for (var i2 = 0;i2 < b; i2++) {
              var c2 = this.buffer.readUInt8(this.pos++);
              setPixelData2.call(this, c2);
            }
            if (b & true) {
              this.pos++;
            }
          }
        } else {
          for (var i2 = 0;i2 < a; i2++) {
            setPixelData2.call(this, b);
          }
        }
      }
    } else {
      var mode = this.width % 4;
      for (var y = this.height - 1;y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0;x < this.width; x++) {
          var b = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          if (b < this.palette.length) {
            var rgb = this.palette[b];
            this.data[location] = 0;
            this.data[location + 1] = rgb.blue;
            this.data[location + 2] = rgb.green;
            this.data[location + 3] = rgb.red;
          } else {
            this.data[location] = 0;
            this.data[location + 1] = 255;
            this.data[location + 2] = 255;
            this.data[location + 3] = 255;
          }
        }
        if (mode != 0) {
          this.pos += 4 - mode;
        }
      }
    }
  };
  BmpDecoder.prototype.bit15 = function() {
    var dif_w = this.width % 3;
    var _11111 = parseInt("11111", 2), _1_5 = _11111;
    for (var y = this.height - 1;y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0;x < this.width; x++) {
        var B = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        var blue = (B & _1_5) / _1_5 * 255 | 0;
        var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;
        var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
        var alpha = B >> 15 ? 255 : 0;
        var location = line * this.width * 4 + x * 4;
        this.data[location] = alpha;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
      this.pos += dif_w;
    }
  };
  BmpDecoder.prototype.bit16 = function() {
    var dif_w = this.width % 2 * 2;
    this.maskRed = 31744;
    this.maskGreen = 992;
    this.maskBlue = 31;
    this.mask0 = 0;
    if (this.compress == 3) {
      this.maskRed = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskGreen = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskBlue = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.mask0 = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
    }
    var ns = [0, 0, 0];
    for (var i2 = 0;i2 < 16; i2++) {
      if (this.maskRed >> i2 & 1)
        ns[0]++;
      if (this.maskGreen >> i2 & 1)
        ns[1]++;
      if (this.maskBlue >> i2 & 1)
        ns[2]++;
    }
    ns[1] += ns[0];
    ns[2] += ns[1];
    ns[0] = 8 - ns[0];
    ns[1] -= 8;
    ns[2] -= 8;
    for (var y = this.height - 1;y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0;x < this.width; x++) {
        var B = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        var blue = (B & this.maskBlue) << ns[0];
        var green = (B & this.maskGreen) >> ns[1];
        var red = (B & this.maskRed) >> ns[2];
        var location = line * this.width * 4 + x * 4;
        this.data[location] = 0;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
      this.pos += dif_w;
    }
  };
  BmpDecoder.prototype.bit24 = function() {
    for (var y = this.height - 1;y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;
      for (var x = 0;x < this.width; x++) {
        var blue = this.buffer.readUInt8(this.pos++);
        var green = this.buffer.readUInt8(this.pos++);
        var red = this.buffer.readUInt8(this.pos++);
        var location = line * this.width * 4 + x * 4;
        this.data[location] = 0;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
      this.pos += this.width % 4;
    }
  };
  BmpDecoder.prototype.bit32 = function() {
    if (this.compress == 3) {
      this.maskRed = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskGreen = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.maskBlue = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.mask0 = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      for (var y = this.height - 1;y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0;x < this.width; x++) {
          var alpha = this.buffer.readUInt8(this.pos++);
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          this.data[location] = alpha;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
      }
    } else {
      for (var y = this.height - 1;y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0;x < this.width; x++) {
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var alpha = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          this.data[location] = alpha;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
      }
    }
  };
  BmpDecoder.prototype.getData = function() {
    return this.data;
  };
  module.exports = function(bmpData) {
    var decoder = new BmpDecoder(bmpData);
    return decoder;
  };
});

// node_modules/bmp-js/index.js
var require_bmp_js = __commonJS((exports, module) => {
  var encode = require_encoder2();
  var decode = require_decoder2();
  module.exports = {
    encode,
    decode
  };
});

// node_modules/pako/lib/utils/common.js
var require_common2 = __commonJS((exports) => {
  var _has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i2 = 0;i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    },
    flattenChunks: function(chunks) {
      var i2, l, len, pos, chunk, result;
      len = 0;
      for (i2 = 0, l = chunks.length;i2 < l; i2++) {
        len += chunks[i2].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i2 = 0, l = chunks.length;i2 < l; i2++) {
        chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i2 = 0;i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports) => {
  var zero = function(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  };
  var TreeDesc = function(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  };
  var d_code = function(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  };
  var put_short = function(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  };
  var send_bits = function(s, value2, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value2 << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value2 >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value2 << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  };
  var send_code = function(s, c2, tree) {
    send_bits(s, tree[c2 * 2], tree[c2 * 2 + 1]);
  };
  var bi_reverse = function(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  };
  var bi_flush = function(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  };
  var gen_bitlen = function(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0;bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1;h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length;bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  };
  var gen_codes = function(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1;bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0;n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  };
  var tr_static_init = function() {
    var n;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0;code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0;n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0;code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0;n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (;code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n = 0;n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0;bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0;n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  };
  var init_block = function(s) {
    var n;
    for (n = 0;n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0;n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0;n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  };
  var bi_windup = function(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  };
  var copy_block = function(s, buf, len, header) {
    bi_windup(s);
    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils8.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  };
  var smaller = function(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  };
  var pqdownheap = function(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  };
  var compress_block = function(s, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  };
  var build_tree = function(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0;n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1;n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  };
  var scan_tree = function(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var send_tree = function(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0;n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var build_bl_tree = function(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  };
  var send_all_trees = function(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0;rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  };
  var detect_data_type = function(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0;n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32;n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  };
  var _tr_init = function(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  };
  var _tr_stored_block = function(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  };
  var _tr_align = function(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  };
  var _tr_flush_block = function(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  };
  var _tr_tally = function(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  };
  var utils8 = require_common2();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  var static_init_done = false;
  exports._tr_init = _tr_init;
  exports._tr_stored_block = _tr_stored_block;
  exports._tr_flush_block = _tr_flush_block;
  exports._tr_tally = _tr_tally;
  exports._tr_align = _tr_align;
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports, module) => {
  var adler32 = function(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  };
  module.exports = adler32;
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  var makeTable = function() {
    var c2, table = [];
    for (var n = 0;n < 256; n++) {
      c2 = n;
      for (var k = 0;k < 8; k++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table[n] = c2;
    }
    return table;
  };
  var crc32 = function(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i2 = pos;i2 < end; i2++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
    }
    return crc ^ -1;
  };
  var crcTable = makeTable();
  module.exports = crc32;
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports, module) => {
  module.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports) => {
  var err = function(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  };
  var rank = function(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  };
  var zero = function(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  var flush_pending = function(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils8.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  };
  var flush_block_only = function(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  };
  var put_byte = function(s, b) {
    s.pending_buf[s.pending++] = b;
  };
  var putShortMSB = function(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  };
  var read_buf = function(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils8.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  };
  var longest_match = function(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan2 = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan2 + best_len - 1];
    var scan_end = _win[scan2 + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan2] || _win[++match] !== _win[scan2 + 1]) {
        continue;
      }
      scan2 += 2;
      match++;
      do {
      } while (_win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && scan2 < strend);
      len = MAX_MATCH - (strend - scan2);
      scan2 = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan2 + best_len - 1];
        scan_end = _win[scan2 + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  };
  var fill_window = function(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils8.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  };
  var deflate_stored = function(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (;; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  };
  var deflate_fast = function(s, flush) {
    var hash_head;
    var bflush;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_slow = function(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_rle = function(s, flush) {
    var bflush;
    var prev;
    var scan2, strend;
    var _win = s.window;
    for (;; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan2 = s.strstart - 1;
        prev = _win[scan2];
        if (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && scan2 < strend);
          s.match_length = MAX_MATCH - (strend - scan2);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_huff = function(s, flush) {
    var bflush;
    for (;; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  };
  var lm_init = function(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  };
  var DeflateState = function() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils8.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils8.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils8.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils8.Buf16(MAX_BITS + 1);
    this.heap = new utils8.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils8.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  };
  var deflateResetKeep = function(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees._tr_init(s);
    return Z_OK;
  };
  var deflateReset = function(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  };
  var deflateSetHeader = function(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  };
  var deflateInit2 = function(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState;
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils8.Buf8(s.w_size * 2);
    s.head = new utils8.Buf16(s.hash_size);
    s.prev = new utils8.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils8.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  };
  var deflateInit = function(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  };
  var deflate = function(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  };
  var deflateEnd = function(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  };
  var deflateSetDictionary = function(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils8.Buf8(s.w_size);
      utils8.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  };
  var utils8 = require_common2();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  exports.deflateInit = deflateInit;
  exports.deflateInit2 = deflateInit2;
  exports.deflateReset = deflateReset;
  exports.deflateResetKeep = deflateResetKeep;
  exports.deflateSetHeader = deflateSetHeader;
  exports.deflate = deflate;
  exports.deflateEnd = deflateEnd;
  exports.deflateSetDictionary = deflateSetDictionary;
  exports.deflateInfo = "pako deflate (from Nodeca project)";
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports) => {
  var buf2binstring = function(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils8.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i2 = 0;i2 < len; i2++) {
      result += String.fromCharCode(buf[i2]);
    }
    return result;
  };
  var utils8 = require_common2();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils8.Buf8(256);
  for (q = 0;q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  var q;
  _utf8len[254] = _utf8len[254] = 1;
  exports.string2buf = function(str) {
    var buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    buf = new utils8.Buf8(buf_len);
    for (i2 = 0, m_pos = 0;i2 < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i2++] = c2;
      } else if (c2 < 2048) {
        buf[i2++] = 192 | c2 >>> 6;
        buf[i2++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i2++] = 224 | c2 >>> 12;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      } else {
        buf[i2++] = 240 | c2 >>> 18;
        buf[i2++] = 128 | c2 >>> 12 & 63;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  exports.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports.binstring2buf = function(str) {
    var buf = new utils8.Buf8(str.length);
    for (var i2 = 0, len = buf.length;i2 < len; i2++) {
      buf[i2] = str.charCodeAt(i2);
    }
    return buf;
  };
  exports.buf2string = function(buf, max) {
    var i2, out, c2, c_len;
    var len = max || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i2 = 0;i2 < len; ) {
      c2 = buf[i2++];
      if (c2 < 128) {
        utf16buf[out++] = c2;
        continue;
      }
      c_len = _utf8len[c2];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c2 = c2 << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out++] = 56320 | c2 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports.utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports, module) => {
  var ZStream = function() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  };
  module.exports = ZStream;
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports) => {
  var Deflate = function(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils8.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  };
  var deflate = function(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  };
  var deflateRaw = function(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  };
  var gzip = function(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  };
  var zlib_deflate = require_deflate();
  var utils8 = require_common2();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString2 = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  Deflate.prototype.push = function(data2, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data2 === "string") {
      strm.input = strings.string2buf(data2);
    } else if (toString2.call(data2) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data2);
    } else {
      strm.input = data2;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils8.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils8.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils8.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils8.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports, module) => {
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (;; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (;; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports, module) => {
  var utils8 = require_common2();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils8.Buf16(MAXBITS + 1);
    var offs = new utils8.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0;len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0;sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS;max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1;min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1;len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1;len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0;sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (;; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports) => {
  var zswap32 = function(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  };
  var InflateState = function() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils8.Buf16(320);
    this.work = new utils8.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  };
  var inflateResetKeep = function(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils8.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils8.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  };
  var inflateReset = function(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  };
  var inflateReset2 = function(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };
  var inflateInit2 = function(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState;
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  };
  var inflateInit = function(strm) {
    return inflateInit2(strm, DEF_WBITS);
  };
  var fixedtables = function(state) {
    if (virgin) {
      var sym;
      lenfix = new utils8.Buf32(512);
      distfix = new utils8.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };
  var updatewindow = function(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils8.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils8.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils8.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils8.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  };
  var inflate = function(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils8.Buf8(4);
    var opts;
    var n;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (;; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils8.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils8.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };
  var inflateEnd = function(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  };
  var inflateGetHeader = function(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  };
  var inflateSetDictionary = function(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  };
  var utils8 = require_common2();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  var virgin = true;
  var lenfix;
  var distfix;
  exports.inflateReset = inflateReset;
  exports.inflateReset2 = inflateReset2;
  exports.inflateResetKeep = inflateResetKeep;
  exports.inflateInit = inflateInit;
  exports.inflateInit2 = inflateInit2;
  exports.inflate = inflate;
  exports.inflateEnd = inflateEnd;
  exports.inflateGetHeader = inflateGetHeader;
  exports.inflateSetDictionary = inflateSetDictionary;
  exports.inflateInfo = "pako inflate (from Nodeca project)";
});

// node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports, module) => {
  var GZheader = function() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  };
  module.exports = GZheader;
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports) => {
  var Inflate = function(options) {
    if (!(this instanceof Inflate))
      return new Inflate(options);
    this.options = utils8.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c2.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader;
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c2.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  };
  var inflate = function(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  };
  var inflateRaw = function(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  };
  var zlib_inflate = require_inflate();
  var utils8 = require_common2();
  var strings = require_strings();
  var c2 = require_constants2();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString2 = Object.prototype.toString;
  Inflate.prototype.push = function(data2, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
    if (typeof data2 === "string") {
      strm.input = strings.binstring2buf(data2);
    } else if (toString2.call(data2) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data2);
    } else {
      strm.input = data2;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils8.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
      if (status === c2.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c2.Z_BUF_ERROR && allowBufError === true) {
        status = c2.Z_OK;
        allowBufError = false;
      }
      if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils8.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils8.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
    if (status === c2.Z_STREAM_END) {
      _mode = c2.Z_FINISH;
    }
    if (_mode === c2.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c2.Z_OK;
    }
    if (_mode === c2.Z_SYNC_FLUSH) {
      this.onEnd(c2.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c2.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils8.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  exports.Inflate = Inflate;
  exports.inflate = inflate;
  exports.inflateRaw = inflateRaw;
  exports.ungzip = inflate;
});

// node_modules/pako/index.js
var require_pako = __commonJS((exports, module) => {
  var assign = require_common2().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants2 = require_constants2();
  var pako = {};
  assign(pako, deflate, inflate, constants2);
  module.exports = pako;
});

// node_modules/utif2/UTIF.js
var require_UTIF = __commonJS((exports, module) => {
  (function() {
    var UTIF = {};
    if (typeof module == "object") {
      module.exports = UTIF;
    } else {
      self.UTIF = UTIF;
    }
    var pako = typeof import.meta.require === "function" ? require_pako() : self.pako;
    function log() {
      if (typeof process == "undefined" || true)
        console.log.apply(console, arguments);
    }
    (function(UTIF2, pako2) {
      (function() {
        var W = function a1() {
          function W2(p) {
            this.message = "JPEG error: " + p;
          }
          W2.prototype = new Error;
          W2.prototype.name = "JpegError";
          W2.constructor = W2;
          return W2;
        }(), ak = function ag() {
          var p = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t = 4017, ac = 799, ah = 3406, ao = 2276, ar = 1567, ai = 3784, s = 5793, ad = 2896;
          function ak2(Q) {
            if (Q == null)
              Q = {};
            if (Q.w == null)
              Q.w = -1;
            this.V = Q.n;
            this.N = Q.w;
          }
          function a5(Q, h) {
            var f = 0, G = [], n, E, a = 16, F;
            while (a > 0 && !Q[a - 1]) {
              a--;
            }
            G.push({ children: [], index: 0 });
            var C = G[0];
            for (n = 0;n < a; n++) {
              for (E = 0;E < Q[n]; E++) {
                C = G.pop();
                C.children[C.index] = h[f];
                while (C.index > 0) {
                  C = G.pop();
                }
                C.index++;
                G.push(C);
                while (G.length <= n) {
                  G.push(F = { children: [], index: 0 });
                  C.children[C.index] = F.children;
                  C = F;
                }
                f++;
              }
              if (n + 1 < a) {
                G.push(F = { children: [], index: 0 });
                C.children[C.index] = F.children;
                C = F;
              }
            }
            return G[0].children;
          }
          function a2(Q, h, f) {
            return 64 * ((Q.P + 1) * h + f);
          }
          function a7(Q, h, f, G, n, E, a, C, F, d) {
            if (d == null)
              d = false;
            var { m: T, Z: U } = f, z = h, J = 0, V = 0, r = 0, D = 0, a8, q = 0, X, O, _, N, e, K, x = 0, k, g, R, c2;
            function Y() {
              if (V > 0) {
                V--;
                return J >> V & 1;
              }
              J = Q[h++];
              if (J === 255) {
                var I = Q[h++];
                if (I) {
                  if (I === 220 && d) {
                    h += 2;
                    var l = Z(Q, h);
                    h += 2;
                    if (l > 0 && l !== f.s) {
                      throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", l);
                    }
                  } else if (I === 217) {
                    if (d) {
                      var M = q * 8;
                      if (M > 0 && M < f.s / 10) {
                        throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", M);
                      }
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new W("unexpected marker");
                }
              }
              V = 7;
              return J >>> 7;
            }
            function u(I) {
              var l = I;
              while (true) {
                l = l[Y()];
                switch (typeof l) {
                  case "number":
                    return l;
                  case "object":
                    continue;
                }
                throw new W("invalid huffman sequence");
              }
            }
            function m(I) {
              var e2 = 0;
              while (I > 0) {
                e2 = e2 << 1 | Y();
                I--;
              }
              return e2;
            }
            function j(I) {
              if (I === 1) {
                return Y() === 1 ? 1 : -1;
              }
              var e2 = m(I);
              if (e2 >= 1 << I - 1) {
                return e2;
              }
              return e2 + (-1 << I) + 1;
            }
            function v(X2, I) {
              var l = u(X2.J), M = l === 0 ? 0 : j(l), N2 = 1;
              X2.D[I] = X2.Q += M;
              while (N2 < 64) {
                var S = u(X2.i), i2 = S & 15, A = S >> 4;
                if (i2 === 0) {
                  if (A < 15) {
                    break;
                  }
                  N2 += 16;
                  continue;
                }
                N2 += A;
                var o = p[N2];
                X2.D[I + o] = j(i2);
                N2++;
              }
            }
            function $2(X2, I) {
              var l = u(X2.J), M = l === 0 ? 0 : j(l) << F;
              X2.D[I] = X2.Q += M;
            }
            function b(X2, I) {
              X2.D[I] |= Y() << F;
            }
            function P(X2, I) {
              if (r > 0) {
                r--;
                return;
              }
              var N2 = E, l = a;
              while (N2 <= l) {
                var M = u(X2.i), S = M & 15, i2 = M >> 4;
                if (S === 0) {
                  if (i2 < 15) {
                    r = m(i2) + (1 << i2) - 1;
                    break;
                  }
                  N2 += 16;
                  continue;
                }
                N2 += i2;
                var A = p[N2];
                X2.D[I + A] = j(S) * (1 << F);
                N2++;
              }
            }
            function a4(X2, I) {
              var N2 = E, l = a, M = 0, S, i2;
              while (N2 <= l) {
                var A = I + p[N2], o = X2.D[A] < 0 ? -1 : 1;
                switch (D) {
                  case 0:
                    i2 = u(X2.i);
                    S = i2 & 15;
                    M = i2 >> 4;
                    if (S === 0) {
                      if (M < 15) {
                        r = m(M) + (1 << M);
                        D = 4;
                      } else {
                        M = 16;
                        D = 1;
                      }
                    } else {
                      if (S !== 1) {
                        throw new W("invalid ACn encoding");
                      }
                      a8 = j(S);
                      D = M ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    if (X2.D[A]) {
                      X2.D[A] += o * (Y() << F);
                    } else {
                      M--;
                      if (M === 0) {
                        D = D === 2 ? 3 : 0;
                      }
                    }
                    break;
                  case 3:
                    if (X2.D[A]) {
                      X2.D[A] += o * (Y() << F);
                    } else {
                      X2.D[A] = a8 << F;
                      D = 0;
                    }
                    break;
                  case 4:
                    if (X2.D[A]) {
                      X2.D[A] += o * (Y() << F);
                    }
                    break;
                }
                N2++;
              }
              if (D === 4) {
                r--;
                if (r === 0) {
                  D = 0;
                }
              }
            }
            function H(X2, I, x2, l, M) {
              var S = x2 / T | 0, i2 = x2 % T;
              q = S * X2.A + l;
              var A = i2 * X2.h + M, o = a2(X2, q, A);
              I(X2, o);
            }
            function w(X2, I, x2) {
              q = x2 / X2.P | 0;
              var l = x2 % X2.P, M = a2(X2, q, l);
              I(X2, M);
            }
            var y = G.length;
            if (U) {
              if (E === 0) {
                K = C === 0 ? $2 : b;
              } else {
                K = C === 0 ? P : a4;
              }
            } else {
              K = v;
            }
            if (y === 1) {
              g = G[0].P * G[0].c;
            } else {
              g = T * f.R;
            }
            while (x <= g) {
              var L = n ? Math.min(g - x, n) : g;
              if (L > 0) {
                for (O = 0;O < y; O++) {
                  G[O].Q = 0;
                }
                r = 0;
                if (y === 1) {
                  X = G[0];
                  for (e = 0;e < L; e++) {
                    w(X, K, x);
                    x++;
                  }
                } else {
                  for (e = 0;e < L; e++) {
                    for (O = 0;O < y; O++) {
                      X = G[O];
                      R = X.h;
                      c2 = X.A;
                      for (_ = 0;_ < c2; _++) {
                        for (N = 0;N < R; N++) {
                          H(X, K, x, _, N);
                        }
                      }
                    }
                    x++;
                  }
                }
              }
              V = 0;
              k = an(Q, h);
              if (!k) {
                break;
              }
              if (k.u) {
                var a6 = L > 0 ? "unexpected" : "excessive";
                h = k.offset;
              }
              if (k.M >= 65488 && k.M <= 65495) {
                h += 2;
              } else {
                break;
              }
            }
            return h - z;
          }
          function al(Q, h, f) {
            var { $: G, D: n } = Q, E, a, C, F, d, T, U, z, J, V, Y, u, m, j, v, $2, b;
            if (!G) {
              throw new W("missing required Quantization Table.");
            }
            for (var r = 0;r < 64; r += 8) {
              J = n[h + r];
              V = n[h + r + 1];
              Y = n[h + r + 2];
              u = n[h + r + 3];
              m = n[h + r + 4];
              j = n[h + r + 5];
              v = n[h + r + 6];
              $2 = n[h + r + 7];
              J *= G[r];
              if ((V | Y | u | m | j | v | $2) === 0) {
                b = s * J + 512 >> 10;
                f[r] = b;
                f[r + 1] = b;
                f[r + 2] = b;
                f[r + 3] = b;
                f[r + 4] = b;
                f[r + 5] = b;
                f[r + 6] = b;
                f[r + 7] = b;
                continue;
              }
              V *= G[r + 1];
              Y *= G[r + 2];
              u *= G[r + 3];
              m *= G[r + 4];
              j *= G[r + 5];
              v *= G[r + 6];
              $2 *= G[r + 7];
              E = s * J + 128 >> 8;
              a = s * m + 128 >> 8;
              C = Y;
              F = v;
              d = ad * (V - $2) + 128 >> 8;
              z = ad * (V + $2) + 128 >> 8;
              T = u << 4;
              U = j << 4;
              E = E + a + 1 >> 1;
              a = E - a;
              b = C * ai + F * ar + 128 >> 8;
              C = C * ar - F * ai + 128 >> 8;
              F = b;
              d = d + U + 1 >> 1;
              U = d - U;
              z = z + T + 1 >> 1;
              T = z - T;
              E = E + F + 1 >> 1;
              F = E - F;
              a = a + C + 1 >> 1;
              C = a - C;
              b = d * ao + z * ah + 2048 >> 12;
              d = d * ah - z * ao + 2048 >> 12;
              z = b;
              b = T * ac + U * t + 2048 >> 12;
              T = T * t - U * ac + 2048 >> 12;
              U = b;
              f[r] = E + z;
              f[r + 7] = E - z;
              f[r + 1] = a + U;
              f[r + 6] = a - U;
              f[r + 2] = C + T;
              f[r + 5] = C - T;
              f[r + 3] = F + d;
              f[r + 4] = F - d;
            }
            for (var P = 0;P < 8; ++P) {
              J = f[P];
              V = f[P + 8];
              Y = f[P + 16];
              u = f[P + 24];
              m = f[P + 32];
              j = f[P + 40];
              v = f[P + 48];
              $2 = f[P + 56];
              if ((V | Y | u | m | j | v | $2) === 0) {
                b = s * J + 8192 >> 14;
                if (b < -2040) {
                  b = 0;
                } else if (b >= 2024) {
                  b = 255;
                } else {
                  b = b + 2056 >> 4;
                }
                n[h + P] = b;
                n[h + P + 8] = b;
                n[h + P + 16] = b;
                n[h + P + 24] = b;
                n[h + P + 32] = b;
                n[h + P + 40] = b;
                n[h + P + 48] = b;
                n[h + P + 56] = b;
                continue;
              }
              E = s * J + 2048 >> 12;
              a = s * m + 2048 >> 12;
              C = Y;
              F = v;
              d = ad * (V - $2) + 2048 >> 12;
              z = ad * (V + $2) + 2048 >> 12;
              T = u;
              U = j;
              E = (E + a + 1 >> 1) + 4112;
              a = E - a;
              b = C * ai + F * ar + 2048 >> 12;
              C = C * ar - F * ai + 2048 >> 12;
              F = b;
              d = d + U + 1 >> 1;
              U = d - U;
              z = z + T + 1 >> 1;
              T = z - T;
              E = E + F + 1 >> 1;
              F = E - F;
              a = a + C + 1 >> 1;
              C = a - C;
              b = d * ao + z * ah + 2048 >> 12;
              d = d * ah - z * ao + 2048 >> 12;
              z = b;
              b = T * ac + U * t + 2048 >> 12;
              T = T * t - U * ac + 2048 >> 12;
              U = b;
              J = E + z;
              $2 = E - z;
              V = a + U;
              v = a - U;
              Y = C + T;
              j = C - T;
              u = F + d;
              m = F - d;
              if (J < 16) {
                J = 0;
              } else if (J >= 4080) {
                J = 255;
              } else {
                J >>= 4;
              }
              if (V < 16) {
                V = 0;
              } else if (V >= 4080) {
                V = 255;
              } else {
                V >>= 4;
              }
              if (Y < 16) {
                Y = 0;
              } else if (Y >= 4080) {
                Y = 255;
              } else {
                Y >>= 4;
              }
              if (u < 16) {
                u = 0;
              } else if (u >= 4080) {
                u = 255;
              } else {
                u >>= 4;
              }
              if (m < 16) {
                m = 0;
              } else if (m >= 4080) {
                m = 255;
              } else {
                m >>= 4;
              }
              if (j < 16) {
                j = 0;
              } else if (j >= 4080) {
                j = 255;
              } else {
                j >>= 4;
              }
              if (v < 16) {
                v = 0;
              } else if (v >= 4080) {
                v = 255;
              } else {
                v >>= 4;
              }
              if ($2 < 16) {
                $2 = 0;
              } else if ($2 >= 4080) {
                $2 = 255;
              } else {
                $2 >>= 4;
              }
              n[h + P] = J;
              n[h + P + 8] = V;
              n[h + P + 16] = Y;
              n[h + P + 24] = u;
              n[h + P + 32] = m;
              n[h + P + 40] = j;
              n[h + P + 48] = v;
              n[h + P + 56] = $2;
            }
          }
          function a0(Q, h) {
            var { P: f, c: G } = h, n = new Int16Array(64);
            for (var E = 0;E < G; E++) {
              for (var a = 0;a < f; a++) {
                var C = a2(h, E, a);
                al(h, C, n);
              }
            }
            return h.D;
          }
          function an(Q, h, f) {
            if (f == null)
              f = h;
            var G = Q.length - 1, n = f < h ? f : h;
            if (h >= G) {
              return null;
            }
            var E = Z(Q, h);
            if (E >= 65472 && E <= 65534) {
              return { u: null, M: E, offset: h };
            }
            var a = Z(Q, n);
            while (!(a >= 65472 && a <= 65534)) {
              if (++n >= G) {
                return null;
              }
              a = Z(Q, n);
            }
            return { u: E.toString(16), M: a, offset: n };
          }
          ak2.prototype = { parse(Q, h) {
            if (h == null)
              h = {};
            var f = h.F, E = 0, a = null, C = null, F, d, T = 0;
            function G() {
              var o = Z(Q, E);
              E += 2;
              var B = E + o - 2, V2 = an(Q, B, E);
              if (V2 && V2.u) {
                B = V2.offset;
              }
              var ab = Q.subarray(E, B);
              E += ab.length;
              return ab;
            }
            function n(F2) {
              var o = Math.ceil(F2.o / 8 / F2.X), B = Math.ceil(F2.s / 8 / F2.B);
              for (var Y2 = 0;Y2 < F2.W.length; Y2++) {
                R = F2.W[Y2];
                var ab = Math.ceil(Math.ceil(F2.o / 8) * R.h / F2.X), af = Math.ceil(Math.ceil(F2.s / 8) * R.A / F2.B), ap = o * R.h, aq = B * R.A, ae = 64 * aq * (ap + 1);
                R.D = new Int16Array(ae);
                R.P = ab;
                R.c = af;
              }
              F2.m = o;
              F2.R = B;
            }
            var U = [], z = [], J = [], V = Z(Q, E);
            E += 2;
            if (V !== 65496) {
              throw new W("SOI not found");
            }
            V = Z(Q, E);
            E += 2;
            markerLoop:
              while (V !== 65497) {
                var Y, u, m;
                switch (V) {
                  case 65504:
                  case 65505:
                  case 65506:
                  case 65507:
                  case 65508:
                  case 65509:
                  case 65510:
                  case 65511:
                  case 65512:
                  case 65513:
                  case 65514:
                  case 65515:
                  case 65516:
                  case 65517:
                  case 65518:
                  case 65519:
                  case 65534:
                    var j = G();
                    if (V === 65504) {
                      if (j[0] === 74 && j[1] === 70 && j[2] === 73 && j[3] === 70 && j[4] === 0) {
                        a = { version: { d: j[5], T: j[6] }, K: j[7], j: j[8] << 8 | j[9], H: j[10] << 8 | j[11], S: j[12], I: j[13], C: j.subarray(14, 14 + 3 * j[12] * j[13]) };
                      }
                    }
                    if (V === 65518) {
                      if (j[0] === 65 && j[1] === 100 && j[2] === 111 && j[3] === 98 && j[4] === 101) {
                        C = { version: j[5] << 8 | j[6], k: j[7] << 8 | j[8], q: j[9] << 8 | j[10], a: j[11] };
                      }
                    }
                    break;
                  case 65499:
                    var v = Z(Q, E), b;
                    E += 2;
                    var $2 = v + E - 2;
                    while (E < $2) {
                      var r = Q[E++], P = new Uint16Array(64);
                      if (r >> 4 === 0) {
                        for (u = 0;u < 64; u++) {
                          b = p[u];
                          P[b] = Q[E++];
                        }
                      } else if (r >> 4 === 1) {
                        for (u = 0;u < 64; u++) {
                          b = p[u];
                          P[b] = Z(Q, E);
                          E += 2;
                        }
                      } else {
                        throw new W("DQT - invalid table spec");
                      }
                      U[r & 15] = P;
                    }
                    break;
                  case 65472:
                  case 65473:
                  case 65474:
                    if (F) {
                      throw new W("Only single frame JPEGs supported");
                    }
                    E += 2;
                    F = {};
                    F.G = V === 65473;
                    F.Z = V === 65474;
                    F.precision = Q[E++];
                    var D = Z(Q, E), a4, q = 0, H = 0;
                    E += 2;
                    F.s = f || D;
                    F.o = Z(Q, E);
                    E += 2;
                    F.W = [];
                    F._ = {};
                    var a8 = Q[E++];
                    for (Y = 0;Y < a8; Y++) {
                      a4 = Q[E];
                      var w = Q[E + 1] >> 4, y = Q[E + 1] & 15;
                      if (q < w) {
                        q = w;
                      }
                      if (H < y) {
                        H = y;
                      }
                      var X = Q[E + 2];
                      m = F.W.push({ h: w, A: y, L: X, $: null });
                      F._[a4] = m - 1;
                      E += 3;
                    }
                    F.X = q;
                    F.B = H;
                    n(F);
                    break;
                  case 65476:
                    var O = Z(Q, E);
                    E += 2;
                    for (Y = 2;Y < O; ) {
                      var _ = Q[E++], N = new Uint8Array(16), e = 0;
                      for (u = 0;u < 16; u++, E++) {
                        e += N[u] = Q[E];
                      }
                      var K = new Uint8Array(e);
                      for (u = 0;u < e; u++, E++) {
                        K[u] = Q[E];
                      }
                      Y += 17 + e;
                      (_ >> 4 === 0 ? J : z)[_ & 15] = a5(N, K);
                    }
                    break;
                  case 65501:
                    E += 2;
                    d = Z(Q, E);
                    E += 2;
                    break;
                  case 65498:
                    var x = ++T === 1 && !f, R;
                    E += 2;
                    var k = Q[E++], g = [];
                    for (Y = 0;Y < k; Y++) {
                      var c2 = Q[E++], L = F._[c2];
                      R = F.W[L];
                      R.index = c2;
                      var a6 = Q[E++];
                      R.J = J[a6 >> 4];
                      R.i = z[a6 & 15];
                      g.push(R);
                    }
                    var I = Q[E++], l = Q[E++], M = Q[E++];
                    try {
                      var S = a7(Q, E, F, g, d, I, l, M >> 4, M & 15, x);
                      E += S;
                    } catch (ex) {
                      if (ex instanceof DNLMarkerError) {
                        return this.parse(Q, { F: ex.s });
                      } else if (ex instanceof EOIMarkerError) {
                        break markerLoop;
                      }
                      throw ex;
                    }
                    break;
                  case 65500:
                    E += 4;
                    break;
                  case 65535:
                    if (Q[E] !== 255) {
                      E--;
                    }
                    break;
                  default:
                    var i2 = an(Q, E - 2, E - 3);
                    if (i2 && i2.u) {
                      E = i2.offset;
                      break;
                    }
                    if (E >= Q.length - 1) {
                      break markerLoop;
                    }
                    throw new W("JpegImage.parse - unknown marker: " + V.toString(16));
                }
                V = Z(Q, E);
                E += 2;
              }
            this.width = F.o;
            this.height = F.s;
            this.g = a;
            this.b = C;
            this.W = [];
            for (Y = 0;Y < F.W.length; Y++) {
              R = F.W[Y];
              var A = U[R.L];
              if (A) {
                R.$ = A;
              }
              this.W.push({ index: R.index, e: a0(F, R), l: R.h / F.X, t: R.A / F.B, P: R.P, c: R.c });
            }
            this.p = this.W.length;
            return;
          }, Y(Q, h, f) {
            if (f == null)
              f = false;
            var G = this.width / Q, n = this.height / h, E, a, C, F, d, T, U, z, J, V, Y = 0, u, m = this.W.length, j = Q * h * m, v = new Uint8ClampedArray(j), $2 = new Uint32Array(Q), b = 4294967288, r;
            for (U = 0;U < m; U++) {
              E = this.W[U];
              a = E.l * G;
              C = E.t * n;
              Y = U;
              u = E.e;
              F = E.P + 1 << 3;
              if (a !== r) {
                for (d = 0;d < Q; d++) {
                  z = 0 | d * a;
                  $2[d] = (z & b) << 3 | z & 7;
                }
                r = a;
              }
              for (T = 0;T < h; T++) {
                z = 0 | T * C;
                V = F * (z & b) | (z & 7) << 3;
                for (d = 0;d < Q; d++) {
                  v[Y] = u[V + $2[d]];
                  Y += m;
                }
              }
            }
            var P = this.V;
            if (!f && m === 4 && !P) {
              P = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
            }
            if (P) {
              for (U = 0;U < j; ) {
                for (z = 0, J = 0;z < m; z++, U++, J += 2) {
                  v[U] = (v[U] * P[J] >> 8) + P[J + 1];
                }
              }
            }
            return v;
          }, get f() {
            if (this.b) {
              return !!this.b.a;
            }
            if (this.p === 3) {
              if (this.N === 0) {
                return false;
              } else if (this.W[0].index === 82 && this.W[1].index === 71 && this.W[2].index === 66) {
                return false;
              }
              return true;
            }
            if (this.N === 1) {
              return true;
            }
            return false;
          }, z: function aj(Q) {
            var h, f, G;
            for (var n = 0, E = Q.length;n < E; n += 3) {
              h = Q[n];
              f = Q[n + 1];
              G = Q[n + 2];
              Q[n] = h - 179.456 + 1.402 * G;
              Q[n + 1] = h + 135.459 - 0.344 * f - 0.714 * G;
              Q[n + 2] = h - 226.816 + 1.772 * f;
            }
            return Q;
          }, O: function aa(Q) {
            var h, f, G, n, E = 0;
            for (var a = 0, C = Q.length;a < C; a += 4) {
              h = Q[a];
              f = Q[a + 1];
              G = Q[a + 2];
              n = Q[a + 3];
              Q[E++] = -122.67195406894 + f * (-0.0000660635669420364 * f + 0.000437130475926232 * G - 0.000054080610064599 * h + 0.00048449797120281 * n - 0.154362151871126) + G * (-0.000957964378445773 * G + 0.000817076911346625 * h - 0.00477271405408747 * n + 1.53380253221734) + h * (0.000961250184130688 * h - 0.00266257332283933 * n + 0.48357088451265) + n * (-0.000336197177618394 * n + 0.484791561490776);
              Q[E++] = 107.268039397724 + f * (0.0000219927104525741 * f - 0.000640992018297945 * G + 0.000659397001245577 * h + 0.000426105652938837 * n - 0.176491792462875) + G * (-0.000778269941513683 * G + 0.00130872261408275 * h + 0.000770482631801132 * n - 0.151051492775562) + h * (0.00126935368114843 * h - 0.00265090189010898 * n + 0.25802910206845) + n * (-0.000318913117588328 * n - 0.213742400323665);
              Q[E++] = -20.810012546947 + f * (-0.000570115196973677 * f - 0.0000263409051004589 * G + 0.0020741088115012 * h - 0.00288260236853442 * n + 0.814272968359295) + G * (-0.0000153496057440975 * G - 0.000132689043961446 * h + 0.000560833691242812 * n - 0.195152027534049) + h * (0.00174418132927582 * h - 0.00255243321439347 * n + 0.116935020465145) + n * (-0.000343531996510555 * n + 0.24165260232407);
            }
            return Q.subarray(0, E);
          }, r: function a3(Q) {
            var h, f, G;
            for (var n = 0, E = Q.length;n < E; n += 4) {
              h = Q[n];
              f = Q[n + 1];
              G = Q[n + 2];
              Q[n] = 434.456 - h - 1.402 * G;
              Q[n + 1] = 119.541 - h + 0.344 * f + 0.714 * G;
              Q[n + 2] = 481.816 - h - 1.772 * f;
            }
            return Q;
          }, U: function as(Q) {
            var h, f, G, n, E = 0;
            for (var a = 0, C = Q.length;a < C; a += 4) {
              h = Q[a];
              f = Q[a + 1];
              G = Q[a + 2];
              n = Q[a + 3];
              Q[E++] = 255 + h * (-0.00006747147073602441 * h + 0.0008379262121013727 * f + 0.0002894718188643294 * G + 0.003264231057537806 * n - 1.1185611867203937) + f * (0.000026374107616089405 * f - 0.00008626949158638572 * G - 0.0002748769067499491 * n - 0.02155688794978967) + G * (-0.00003878099212869363 * G - 0.0003267808279485286 * n + 0.0686742238595345) - n * (0.0003361971776183937 * n + 0.7430659151342254);
              Q[E++] = 255 + h * (0.00013596372813588848 * h + 0.000924537132573585 * f + 0.00010567359618683593 * G + 0.0004791864687436512 * n - 0.3109689587515875) + f * (-0.00023545346108370344 * f + 0.0002702845253534714 * G + 0.0020200308977307156 * n - 0.7488052167015494) + G * (0.00006834815998235662 * G + 0.00015168452363460973 * n - 0.09751927774728933) - n * (0.0003189131175883281 * n + 0.7364883807733168);
              Q[E++] = 255 + h * (0.000013598650411385307 * h + 0.00012423956175490851 * f + 0.0004751985097583589 * G - 0.0000036729317476630422 * n - 0.05562186980264034) + f * (0.00016141380598724676 * f + 0.0009692239130725186 * G + 0.0007782692450036253 * n - 0.44015232367526463) + G * (0.0000005068882914068769 * G + 0.0017778369011375071 * n - 0.7591454649749609) - n * (0.0003435319965105553 * n + 0.7063770186160144);
            }
            return Q.subarray(0, E);
          }, getData: function(Q) {
            var { width: h, height: f, forceRGB: G, isSourcePDF: n } = Q;
            if (this.p > 4) {
              throw new W("Unsupported color mode");
            }
            var E = this.Y(h, f, n);
            if (this.p === 1 && G) {
              var a = E.length, C = new Uint8ClampedArray(a * 3), F = 0;
              for (var d = 0;d < a; d++) {
                var T = E[d];
                C[F++] = T;
                C[F++] = T;
                C[F++] = T;
              }
              return C;
            } else if (this.p === 3 && this.f) {
              return this.z(E);
            } else if (this.p === 4) {
              if (this.f) {
                if (G) {
                  return this.O(E);
                }
                return this.r(E);
              } else if (G) {
                return this.U(E);
              }
            }
            return E;
          } };
          return ak2;
        }();
        function a9(p, t) {
          return p[t] << 24 >> 24;
        }
        function Z(p, t) {
          return p[t] << 8 | p[t + 1];
        }
        function am(p, t) {
          return (p[t] << 24 | p[t + 1] << 16 | p[t + 2] << 8 | p[t + 3]) >>> 0;
        }
        UTIF2.JpegDecoder = ak;
      })();
      UTIF2.encodeImage = function(rgba, w, h, metadata) {
        var idf = {
          t256: [w],
          t257: [h],
          t258: [8, 8, 8, 8],
          t259: [1],
          t262: [2],
          t273: [1000],
          t277: [4],
          t278: [h],
          t279: [w * h * 4],
          t282: [[72, 1]],
          t283: [[72, 1]],
          t284: [1],
          t286: [[0, 1]],
          t287: [[0, 1]],
          t296: [1],
          t305: ["Photopea (UTIF.js)"],
          t338: [1]
        };
        if (metadata)
          for (var i2 in metadata)
            idf[i2] = metadata[i2];
        var prfx = new Uint8Array(UTIF2.encode([idf]));
        var img = new Uint8Array(rgba);
        var data2 = new Uint8Array(1000 + w * h * 4);
        for (var i2 = 0;i2 < prfx.length; i2++)
          data2[i2] = prfx[i2];
        for (var i2 = 0;i2 < img.length; i2++)
          data2[1000 + i2] = img[i2];
        return data2.buffer;
      };
      UTIF2.encode = function(ifds) {
        var LE = false;
        var data2 = new Uint8Array(20000), offset = 4, bin = LE ? UTIF2._binLE : UTIF2._binBE;
        data2[0] = data2[1] = LE ? 73 : 77;
        bin.writeUshort(data2, 2, 42);
        var ifdo = 8;
        bin.writeUint(data2, offset, ifdo);
        offset += 4;
        for (var i2 = 0;i2 < ifds.length; i2++) {
          var noffs = UTIF2._writeIFD(bin, UTIF2._types.basic, data2, ifdo, ifds[i2]);
          ifdo = noffs[1];
          if (i2 < ifds.length - 1) {
            if ((ifdo & 3) != 0)
              ifdo += 4 - (ifdo & 3);
            bin.writeUint(data2, noffs[0], ifdo);
          }
        }
        return data2.slice(0, ifdo).buffer;
      };
      UTIF2.decode = function(buff, prm) {
        if (prm == null)
          prm = { parseMN: true, debug: false };
        var data2 = new Uint8Array(buff), offset = 0;
        var id = UTIF2._binBE.readASCII(data2, offset, 2);
        offset += 2;
        var bin = id == "II" ? UTIF2._binLE : UTIF2._binBE;
        var num = bin.readUshort(data2, offset);
        offset += 2;
        var ifdo = bin.readUint(data2, offset);
        offset += 4;
        var ifds = [];
        while (true) {
          var cnt = bin.readUshort(data2, ifdo), typ = bin.readUshort(data2, ifdo + 4);
          if (cnt != 0) {
            if (typ < 1 || 13 < typ) {
              log("error in TIFF");
              break;
            }
          }
          UTIF2._readIFD(bin, data2, ifdo, ifds, 0, prm);
          ifdo = bin.readUint(data2, ifdo + 2 + cnt * 12);
          if (ifdo == 0)
            break;
        }
        return ifds;
      };
      UTIF2.decodeImage = function(buff, img, ifds) {
        if (img.data)
          return;
        var data2 = new Uint8Array(buff);
        var id = UTIF2._binBE.readASCII(data2, 0, 2);
        if (img["t256"] == null)
          return;
        img.isLE = id == "II";
        img.width = img["t256"][0];
        img.height = img["t257"][0];
        var cmpr = img["t259"] ? img["t259"][0] : 1;
        var fo = img["t266"] ? img["t266"][0] : 1;
        if (img["t284"] && img["t284"][0] == 2)
          log("PlanarConfiguration 2 should not be used!");
        if (cmpr == 7 && img["t258"] && img["t258"].length > 3)
          img["t258"] = img["t258"].slice(0, 3);
        var spp = img["t277"] ? img["t277"][0] : 1;
        var bps = img["t258"] ? img["t258"][0] : 1;
        var bipp = bps * spp;
        if (cmpr == 1 && img["t279"] != null && img["t278"] && img["t262"][0] == 32803) {
          bipp = Math.round(img["t279"][0] * 8 / (img.width * img["t278"][0]));
        }
        if (img["t50885"] && img["t50885"][0] == 4)
          bipp = img["t258"][0] * 3;
        var bipl = Math.ceil(img.width * bipp / 8) * 8;
        var soff = img["t273"];
        if (soff == null || img["t322"])
          soff = img["t324"];
        var bcnt = img["t279"];
        if (cmpr == 1 && soff.length == 1)
          bcnt = [img.height * (bipl >>> 3)];
        if (bcnt == null || img["t322"])
          bcnt = img["t325"];
        var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
        if (img["t322"] != null) {
          var tw = img["t322"][0], th = img["t323"][0];
          var tx = Math.floor((img.width + tw - 1) / tw);
          var ty = Math.floor((img.height + th - 1) / th);
          var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);
          console.log("====", tx, ty);
          for (var y = 0;y < ty; y++)
            for (var x = 0;x < tx; x++) {
              var i2 = y * tx + x;
              tbuff.fill(0);
              UTIF2.decode._decompress(img, ifds, data2, soff[i2], bcnt[i2], cmpr, tbuff, 0, fo, tw, th);
              if (cmpr == 6)
                bytes = tbuff;
              else
                UTIF2._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x * tw * bipp / 8) | 0, y * th);
            }
          bilen = bytes.length * 8;
        } else {
          if (soff == null)
            return;
          var rps = img["t278"] ? img["t278"][0] : img.height;
          rps = Math.min(rps, img.height);
          for (var i2 = 0;i2 < soff.length; i2++) {
            UTIF2.decode._decompress(img, ifds, data2, soff[i2], bcnt[i2], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo, img.width, rps);
            bilen += bipl * rps;
          }
          bilen = Math.min(bilen, bytes.length * 8);
        }
        img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);
      };
      UTIF2.decode._decompress = function(img, ifds, data2, off, len, cmpr, tgt, toff, fo, w, h) {
        if (img["t271"] && img["t271"][0] == "Panasonic" && img["t45"] && img["t45"][0] == 6)
          cmpr = 34316;
        if (false) {
        } else if (cmpr == 1)
          for (var j = 0;j < len; j++)
            tgt[toff + j] = data2[off + j];
        else if (cmpr == 2)
          UTIF2.decode._decodeG2(data2, off, len, tgt, toff, w, fo);
        else if (cmpr == 3)
          UTIF2.decode._decodeG3(data2, off, len, tgt, toff, w, fo, img["t292"] ? (img["t292"][0] & 1) == 1 : false);
        else if (cmpr == 4)
          UTIF2.decode._decodeG4(data2, off, len, tgt, toff, w, fo);
        else if (cmpr == 5)
          UTIF2.decode._decodeLZW(data2, off, len, tgt, toff, 8);
        else if (cmpr == 6)
          UTIF2.decode._decodeOldJPEG(img, data2, off, len, tgt, toff);
        else if (cmpr == 7 || cmpr == 34892)
          UTIF2.decode._decodeNewJPEG(img, data2, off, len, tgt, toff);
        else if (cmpr == 8 || cmpr == 32946) {
          var src = new Uint8Array(data2.buffer, off + 2, len - 6);
          var bin = pako2["inflateRaw"](src);
          if (toff + bin.length <= tgt.length)
            tgt.set(bin, toff);
        } else if (cmpr == 9)
          UTIF2.decode._decodeVC5(data2, off, len, tgt, toff, img["t33422"]);
        else if (cmpr == 32767)
          UTIF2.decode._decodeARW(img, data2, off, len, tgt, toff);
        else if (cmpr == 32773)
          UTIF2.decode._decodePackBits(data2, off, len, tgt, toff);
        else if (cmpr == 32809)
          UTIF2.decode._decodeThunder(data2, off, len, tgt, toff);
        else if (cmpr == 34316)
          UTIF2.decode._decodePanasonic(img, data2, off, len, tgt, toff);
        else if (cmpr == 34713)
          UTIF2.decode._decodeNikon(img, ifds, data2, off, len, tgt, toff);
        else if (cmpr == 34676)
          UTIF2.decode._decodeLogLuv32(img, data2, off, len, tgt, toff);
        else
          log("Unknown compression", cmpr);
        var bps = img["t258"] ? Math.min(32, img["t258"][0]) : 1;
        var noc = img["t277"] ? img["t277"][0] : 1, bpp = bps * noc >>> 3, bpl = Math.ceil(bps * noc * w / 8);
        if (bps == 16 && !img.isLE && img["t33422"] == null)
          for (var y = 0;y < h; y++) {
            var roff = toff + y * bpl;
            for (var x = 1;x < bpl; x += 2) {
              var t = tgt[roff + x];
              tgt[roff + x] = tgt[roff + x - 1];
              tgt[roff + x - 1] = t;
            }
          }
        if (img["t317"] && img["t317"][0] == 2) {
          for (var y = 0;y < h; y++) {
            var ntoff = toff + y * bpl;
            if (bps == 16)
              for (var j = bpp;j < bpl; j += 2) {
                var nv = (tgt[ntoff + j + 1] << 8 | tgt[ntoff + j]) + (tgt[ntoff + j - bpp + 1] << 8 | tgt[ntoff + j - bpp]);
                tgt[ntoff + j] = nv & 255;
                tgt[ntoff + j + 1] = nv >>> 8 & 255;
              }
            else if (noc == 3)
              for (var j = 3;j < bpl; j += 3) {
                tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;
                tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;
                tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;
              }
            else
              for (var j = bpp;j < bpl; j++)
                tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - bpp] & 255;
          }
        }
      };
      UTIF2.decode._decodePanasonic = function(img, data2, off, len, tgt, toff) {
        var img_buffer = data2.buffer;
        var rawWidth = img["t2"][0];
        var rawHeight = img["t3"][0];
        var bitsPerSample = img["t10"][0];
        var RW2_Format = img["t45"][0];
        var bidx = 0;
        var imageIndex = 0;
        var vpos = 0;
        var byte = 0;
        var arr_a, arr_b;
        var bytes = RW2_Format == 6 ? new Uint32Array(18) : new Uint8Array(16);
        var i2, j, sh, pred = [0, 0], nonz = [0, 0], isOdd, idx = 0, pixel_base;
        var row, col, crow;
        var buffer = new Uint8Array(16384);
        var result = new Uint16Array(tgt.buffer);
        function getDataRaw(bits) {
          if (vpos == 0) {
            var arr_a2 = new Uint8Array(img_buffer, off + imageIndex + 8184, 16384 - 8184);
            var arr_b2 = new Uint8Array(img_buffer, off + imageIndex, 8184);
            buffer.set(arr_a2);
            buffer.set(arr_b2, arr_a2.length);
            imageIndex += 16384;
          }
          if (RW2_Format == 5) {
            for (i2 = 0;i2 < 16; i2++) {
              bytes[i2] = buffer[vpos++];
              vpos &= 16383;
            }
          } else {
            vpos = vpos - bits & 131071;
            byte = vpos >> 3 ^ 16368;
            return (buffer[byte] | buffer[byte + 1] << 8) >> (vpos & 7) & ~(-1 << bits);
          }
        }
        function getBufferDataRW6(i3) {
          return buffer[vpos + 15 - i3];
        }
        function readPageRW6() {
          bytes[0] = getBufferDataRW6(0) << 6 | getBufferDataRW6(1) >> 2;
          bytes[1] = ((getBufferDataRW6(1) & 3) << 12 | getBufferDataRW6(2) << 4 | getBufferDataRW6(3) >> 4) & 16383;
          bytes[2] = getBufferDataRW6(3) >> 2 & 3;
          bytes[3] = (getBufferDataRW6(3) & 3) << 8 | getBufferDataRW6(4);
          bytes[4] = getBufferDataRW6(5) << 2 | getBufferDataRW6(6) >> 6;
          bytes[5] = (getBufferDataRW6(6) & 63) << 4 | getBufferDataRW6(7) >> 4;
          bytes[6] = getBufferDataRW6(7) >> 2 & 3;
          bytes[7] = (getBufferDataRW6(7) & 3) << 8 | getBufferDataRW6(8);
          bytes[8] = getBufferDataRW6(9) << 2 & 1020 | getBufferDataRW6(10) >> 6;
          bytes[9] = (getBufferDataRW6(10) << 4 | getBufferDataRW6(11) >> 4) & 1023;
          bytes[10] = getBufferDataRW6(11) >> 2 & 3;
          bytes[11] = (getBufferDataRW6(11) & 3) << 8 | getBufferDataRW6(12);
          bytes[12] = (getBufferDataRW6(13) << 2 & 1020 | getBufferDataRW6(14) >> 6) & 1023;
          bytes[13] = (getBufferDataRW6(14) << 4 | getBufferDataRW6(15) >> 4) & 1023;
          vpos += 16;
          byte = 0;
        }
        function readPageRw6_bps12() {
          bytes[0] = getBufferDataRW6(0) << 4 | getBufferDataRW6(1) >> 4;
          bytes[1] = ((getBufferDataRW6(1) & 15) << 8 | getBufferDataRW6(2)) & 4095;
          bytes[2] = getBufferDataRW6(3) >> 6 & 3;
          bytes[3] = (getBufferDataRW6(3) & 63) << 2 | getBufferDataRW6(4) >> 6;
          bytes[4] = (getBufferDataRW6(4) & 63) << 2 | getBufferDataRW6(5) >> 6;
          bytes[5] = (getBufferDataRW6(5) & 63) << 2 | getBufferDataRW6(6) >> 6;
          bytes[6] = getBufferDataRW6(6) >> 4 & 3;
          bytes[7] = (getBufferDataRW6(6) & 15) << 4 | getBufferDataRW6(7) >> 4;
          bytes[8] = (getBufferDataRW6(7) & 15) << 4 | getBufferDataRW6(8) >> 4;
          bytes[9] = (getBufferDataRW6(8) & 15) << 4 | getBufferDataRW6(9) >> 4;
          bytes[10] = getBufferDataRW6(9) >> 2 & 3;
          bytes[11] = (getBufferDataRW6(9) & 3) << 6 | getBufferDataRW6(10) >> 2;
          bytes[12] = (getBufferDataRW6(10) & 3) << 6 | getBufferDataRW6(11) >> 2;
          bytes[13] = (getBufferDataRW6(11) & 3) << 6 | getBufferDataRW6(12) >> 2;
          bytes[14] = getBufferDataRW6(12) & 3;
          bytes[15] = getBufferDataRW6(13);
          bytes[16] = getBufferDataRW6(14);
          bytes[17] = getBufferDataRW6(15);
          vpos += 16;
          byte = 0;
        }
        function resetPredNonzeros() {
          pred[0] = 0;
          pred[1] = 0;
          nonz[0] = 0;
          nonz[1] = 0;
        }
        if (RW2_Format == 7) {
          throw RW2_Format;
        } else if (RW2_Format == 6) {
          var is12bit = bitsPerSample == 12, readPageRw6Fn = is12bit ? readPageRw6_bps12 : readPageRW6, pixelsPerBlock = is12bit ? 14 : 11, pixelbase0 = is12bit ? 128 : 512, pixelbase_compare = is12bit ? 2048 : 8192, spix_compare = is12bit ? 16383 : 65535, pixel_mask = is12bit ? 4095 : 16383, blocksperrow = rawWidth / pixelsPerBlock, rowbytes = blocksperrow * 16, bufferSize = is12bit ? 18 : 14;
          for (row = 0;row < rawHeight - 15; row += 16) {
            var rowstoread = Math.min(16, rawHeight - row);
            var readlen = rowbytes * rowstoread;
            buffer = new Uint8Array(img_buffer, off + bidx, readlen);
            vpos = 0;
            bidx += readlen;
            for (crow = 0, col = 0;crow < rowstoread; crow++, col = 0) {
              idx = (row + crow) * rawWidth;
              for (var rblock = 0;rblock < blocksperrow; rblock++) {
                readPageRw6Fn();
                resetPredNonzeros();
                sh = 0;
                pixel_base = 0;
                for (i2 = 0;i2 < pixelsPerBlock; i2++) {
                  isOdd = i2 & 1;
                  if (i2 % 3 == 2) {
                    var base = byte < bufferSize ? bytes[byte++] : 0;
                    if (base == 3)
                      base = 4;
                    pixel_base = pixelbase0 << base;
                    sh = 1 << base;
                  }
                  var epixel = byte < bufferSize ? bytes[byte++] : 0;
                  if (pred[isOdd]) {
                    epixel *= sh;
                    if (pixel_base < pixelbase_compare && nonz[isOdd] > pixel_base)
                      epixel += nonz[isOdd] - pixel_base;
                    nonz[isOdd] = epixel;
                  } else {
                    pred[isOdd] = epixel;
                    if (epixel)
                      nonz[isOdd] = epixel;
                    else
                      epixel = nonz[isOdd];
                  }
                  result[idx + col++] = epixel - 15 <= spix_compare ? epixel - 15 & spix_compare : epixel + 2147483633 >> 31 & pixel_mask;
                }
              }
            }
          }
        } else if (RW2_Format == 5) {
          var blockSize = bitsPerSample == 12 ? 10 : 9;
          for (row = 0;row < rawHeight; row++) {
            for (col = 0;col < rawWidth; col += blockSize) {
              getDataRaw(0);
              if (bitsPerSample == 12) {
                result[idx++] = ((bytes[1] & 15) << 8) + bytes[0];
                result[idx++] = 16 * bytes[2] + (bytes[1] >> 4);
                result[idx++] = ((bytes[4] & 15) << 8) + bytes[3];
                result[idx++] = 16 * bytes[5] + (bytes[4] >> 4);
                result[idx++] = ((bytes[7] & 15) << 8) + bytes[6];
                result[idx++] = 16 * bytes[8] + (bytes[7] >> 4);
                result[idx++] = ((bytes[10] & 15) << 8) + bytes[9];
                result[idx++] = 16 * bytes[11] + (bytes[10] >> 4);
                result[idx++] = ((bytes[13] & 15) << 8) + bytes[12];
                result[idx++] = 16 * bytes[14] + (bytes[13] >> 4);
              } else if (bitsPerSample == 14) {
                result[idx++] = bytes[0] + ((bytes[1] & 63) << 8);
                result[idx++] = (bytes[1] >> 6) + 4 * bytes[2] + ((bytes[3] & 15) << 10);
                result[idx++] = (bytes[3] >> 4) + 16 * bytes[4] + ((bytes[5] & 3) << 12);
                result[idx++] = ((bytes[5] & 252) >> 2) + (bytes[6] << 6);
                result[idx++] = bytes[7] + ((bytes[8] & 63) << 8);
                result[idx++] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 15) << 10);
                result[idx++] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
                result[idx++] = ((bytes[12] & 252) >> 2) + (bytes[13] << 6);
                result[idx++] = bytes[14] + ((bytes[15] & 63) << 8);
              }
            }
          }
        } else if (RW2_Format == 4) {
          for (row = 0;row < rawHeight; row++) {
            for (col = 0;col < rawWidth; col++) {
              i2 = col % 14;
              isOdd = i2 & 1;
              if (i2 == 0)
                resetPredNonzeros();
              if (i2 % 3 == 2)
                sh = 4 >> 3 - getDataRaw(2);
              if (nonz[isOdd]) {
                j = getDataRaw(8);
                if (j != 0) {
                  pred[isOdd] -= 128 << sh;
                  if (pred[isOdd] < 0 || sh == 4)
                    pred[isOdd] &= ~(-1 << sh);
                  pred[isOdd] += j << sh;
                }
              } else {
                nonz[isOdd] = getDataRaw(8);
                if (nonz[isOdd] || i2 > 11)
                  pred[isOdd] = nonz[isOdd] << 4 | getDataRaw(4);
              }
              result[idx++] = pred[col & 1];
            }
          }
        } else
          throw RW2_Format;
      };
      UTIF2.decode._decodeVC5 = function() {
        var x = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], o, C, k, P = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1], V = 24576, ar = 16384, H = 8192, az = ar | H;
        function d(t) {
          var E = t[1], h = t[0][E >>> 3] >>> 7 - (E & 7) & 1;
          t[1]++;
          return h;
        }
        function ag(t, E) {
          if (o == null) {
            o = {};
            for (var h = 0;h < x.length; h += 4)
              o[x[h + 1]] = x.slice(h, h + 4);
          }
          var L = d(t), g = o[L];
          while (g == null) {
            L = L << 1 | d(t);
            g = o[L];
          }
          var n = g[3];
          if (n != 0)
            n = d(t) == 0 ? n : -n;
          E[0] = g[2];
          E[1] = n;
        }
        function m(t, E) {
          for (var h = 0;h < E; h++) {
            if ((t & 1) == 1)
              t++;
            t = t >>> 1;
          }
          return t;
        }
        function A(t, E) {
          return t >> E;
        }
        function O(t, E, h, L, g, n) {
          E[h] = A(A(11 * t[g] - 4 * t[g + n] + t[g + n + n] + 4, 3) + t[L], 1);
          E[h + n] = A(A(5 * t[g] + 4 * t[g + n] - t[g + n + n] + 4, 3) - t[L], 1);
        }
        function J(t, E, h, L, g, n) {
          var W = t[g - n] - t[g + n], j = t[g], $2 = t[L];
          E[h] = A(A(W + 4, 3) + j + $2, 1);
          E[h + n] = A(A(-W + 4, 3) + j - $2, 1);
        }
        function y(t, E, h, L, g, n) {
          E[h] = A(A(5 * t[g] + 4 * t[g - n] - t[g - n - n] + 4, 3) + t[L], 1);
          E[h + n] = A(A(11 * t[g] - 4 * t[g - n] + t[g - n - n] + 4, 3) - t[L], 1);
        }
        function q(t) {
          t = t < 0 ? 0 : t > 4095 ? 4095 : t;
          t = k[t] >>> 2;
          return t;
        }
        function av(t, E, h, L, g, n) {
          L = new Uint16Array(L.buffer);
          var W = Date.now(), j = UTIF2._binBE, $2 = E + h, r, u, X, I, ax, a3, R, ai, aa, ap, ah, ae, aD, al, i2, aE, T, B;
          E += 4;
          var a5 = n[0] == 1;
          while (E < $2) {
            var S = j.readShort(t, E), s = j.readUshort(t, E + 2);
            E += 4;
            if (S == 12)
              r = s;
            else if (S == 20)
              u = s;
            else if (S == 21)
              X = s;
            else if (S == 48)
              I = s;
            else if (S == 53)
              ax = s;
            else if (S == 35)
              a3 = s;
            else if (S == 62)
              R = s;
            else if (S == 101)
              ai = s;
            else if (S == 109)
              aa = s;
            else if (S == 84)
              ap = s;
            else if (S == 106)
              ah = s;
            else if (S == 107)
              ae = s;
            else if (S == 108)
              aD = s;
            else if (S == 102)
              al = s;
            else if (S == 104)
              i2 = s;
            else if (S == 105)
              aE = s;
            else {
              var F = S < 0 ? -S : S, D = F & 65280, _ = 0;
              if (F & az) {
                if (F & H) {
                  _ = s & 65535;
                  _ += (F & 255) << 16;
                } else {
                  _ = s & 65535;
                }
              }
              if ((F & V) == V) {
                if (T == null) {
                  T = [];
                  for (var M = 0;M < 4; M++)
                    T[M] = new Int16Array((u >>> 1) * (X >>> 1));
                  B = new Int16Array((u >>> 1) * (X >>> 1));
                  C = new Int16Array(1024);
                  for (var M = 0;M < 1024; M++) {
                    var aG = M - 512, p = Math.abs(aG), r = Math.floor(768 * p * p * p / (255 * 255 * 255)) + p;
                    C[M] = Math.sign(aG) * r;
                  }
                  k = new Uint16Array(4096);
                  var aA = (1 << 16) - 1;
                  for (var M = 0;M < 4096; M++) {
                    var at = M, a1 = aA * (Math.pow(113, at / 4095) - 1) / 112;
                    k[M] = Math.min(a1, aA);
                  }
                }
                var w = T[R], v = m(u, 1 + P[I]), N = m(X, 1 + P[I]);
                if (I == 0) {
                  for (var b = 0;b < N; b++)
                    for (var G = 0;G < v; G++) {
                      var c2 = E + (b * v + G) * 2;
                      w[b * (u >>> 1) + G] = t[c2] << 8 | t[c2 + 1];
                    }
                } else {
                  var a7 = [t, E * 8], a4 = [], ay = 0, aw = v * N, f = [0, 0], Q = 0, s = 0;
                  while (ay < aw) {
                    ag(a7, f);
                    Q = f[0];
                    s = f[1];
                    while (Q > 0) {
                      a4[ay++] = s;
                      Q--;
                    }
                  }
                  var l = (I - 1) % 3, aF = l != 1 ? v : 0, a2 = l != 0 ? N : 0;
                  for (var b = 0;b < N; b++) {
                    var af = (b + a2) * (u >>> 1) + aF, au = b * v;
                    for (var G = 0;G < v; G++)
                      w[af + G] = C[a4[au + G] + 512] * ax;
                  }
                  if (l == 2) {
                    var i2 = u >>> 1, an = v * 2, a9 = N * 2;
                    for (var b = 0;b < N; b++) {
                      for (var G = 0;G < an; G++) {
                        var M = b * 2 * i2 + G, a = b * i2 + G, e = N * i2 + a;
                        if (b == 0)
                          O(w, B, M, e, a, i2);
                        else if (b == N - 1)
                          y(w, B, M, e, a, i2);
                        else
                          J(w, B, M, e, a, i2);
                      }
                    }
                    var Z = w;
                    w = B;
                    B = Z;
                    for (var b = 0;b < a9; b++) {
                      for (var G = 0;G < v; G++) {
                        var M = b * i2 + 2 * G, a = b * i2 + G, e = v + a;
                        if (G == 0)
                          O(w, B, M, e, a, 1);
                        else if (G == v - 1)
                          y(w, B, M, e, a, 1);
                        else
                          J(w, B, M, e, a, 1);
                      }
                    }
                    var Z = w;
                    w = B;
                    B = Z;
                    var aC = [], aB = 2 - ~~((I - 1) / 3);
                    for (var K = 0;K < 3; K++)
                      aC[K] = aa >> 14 - K * 2 & 3;
                    var a6 = aC[aB];
                    if (a6 != 0)
                      for (var b = 0;b < a9; b++)
                        for (var G = 0;G < an; G++) {
                          var M = b * i2 + G;
                          w[M] = w[M] << a6;
                        }
                  }
                }
                if (I == 9 && R == 3) {
                  var a8 = T[0], ab = T[1], aq = T[2], as = T[3];
                  for (var b = 0;b < X; b += 2)
                    for (var G = 0;G < u; G += 2) {
                      var U = b * u + G, c2 = (b >>> 1) * (u >>> 1) + (G >>> 1), z = a8[c2], ao = ab[c2] - 2048, ak = aq[c2] - 2048, ad = as[c2] - 2048, aj = (ao << 1) + z, a0 = (ak << 1) + z, aH = z + ad, am = z - ad;
                      if (a5) {
                        L[U] = q(aH);
                        L[U + 1] = q(a0);
                        L[U + u] = q(aj);
                        L[U + u + 1] = q(am);
                      } else {
                        L[U] = q(aj);
                        L[U + 1] = q(aH);
                        L[U + u] = q(am);
                        L[U + u + 1] = q(a0);
                      }
                    }
                }
                E += _ * 4;
              } else if (F == 16388) {
                E += _ * 4;
              } else if (D == 8192 || D == 8448 || D == 9216) {
              } else
                throw F.toString(16);
            }
          }
          console.log(Date.now() - W);
        }
        return av;
      }();
      UTIF2.decode._decodeLogLuv32 = function(img, data2, off, len, tgt, toff) {
        var w = img.width, qw = w * 4;
        var io = 0, out = new Uint8Array(qw);
        while (io < len) {
          var oo = 0;
          while (oo < qw) {
            var c2 = data2[off + io];
            io++;
            if (c2 < 128) {
              for (var j = 0;j < c2; j++)
                out[oo + j] = data2[off + io + j];
              oo += c2;
              io += c2;
            } else {
              c2 = c2 - 126;
              for (var j = 0;j < c2; j++)
                out[oo + j] = data2[off + io];
              oo += c2;
              io++;
            }
          }
          for (var x = 0;x < w; x++) {
            tgt[toff + 0] = out[x];
            tgt[toff + 1] = out[x + w];
            tgt[toff + 2] = out[x + w * 2];
            tgt[toff + 4] = out[x + w * 3];
            toff += 6;
          }
        }
      };
      UTIF2.decode._ljpeg_diff = function(data2, prm, huff) {
        var getbithuff = UTIF2.decode._getbithuff;
        var len, diff;
        len = getbithuff(data2, prm, huff[0], huff);
        diff = getbithuff(data2, prm, len, 0);
        if ((diff & 1 << len - 1) == 0)
          diff -= (1 << len) - 1;
        return diff;
      };
      UTIF2.decode._decodeARW = function(img, inp, off, src_length, tgt, toff) {
        var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
        var bin = img.isLE ? UTIF2._binLE : UTIF2._binBE;
        var arw2 = raw_width * height == src_length || raw_width * height * 1.5 == src_length;
        if (!arw2) {
          height += 8;
          var prm = [off, 0, 0, 0];
          var huff = new Uint16Array(32770);
          var tab = [
            3857,
            3856,
            3599,
            3342,
            3085,
            2828,
            2571,
            2314,
            2057,
            1800,
            1543,
            1286,
            1029,
            772,
            771,
            768,
            514,
            513
          ];
          var i2, c2, n, col, row, sum = 0;
          var ljpeg_diff = UTIF2.decode._ljpeg_diff;
          huff[0] = 15;
          for (n = i2 = 0;i2 < 18; i2++) {
            var lim = 32768 >>> (tab[i2] >>> 8);
            for (var c2 = 0;c2 < lim; c2++)
              huff[++n] = tab[i2];
          }
          for (col = raw_width;col--; )
            for (row = 0;row < height + 1; row += 2) {
              if (row == height)
                row = 1;
              sum += ljpeg_diff(inp, prm, huff);
              if (row < height) {
                var clr = sum & 4095;
                UTIF2.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
              }
            }
          return;
        }
        if (raw_width * height * 1.5 == src_length) {
          for (var i2 = 0;i2 < src_length; i2 += 3) {
            var b0 = inp[off + i2 + 0], b1 = inp[off + i2 + 1], b2 = inp[off + i2 + 2];
            tgt[toff + i2] = b1 << 4 | b0 >>> 4;
            tgt[toff + i2 + 1] = b0 << 4 | b2 >>> 4;
            tgt[toff + i2 + 2] = b2 << 4 | b1 >>> 4;
          }
          return;
        }
        var pix = new Uint16Array(16);
        var row, col, val, max, min, imax, imin, sh, bit, i2, dp;
        var data2 = new Uint8Array(raw_width + 1);
        for (row = 0;row < height; row++) {
          for (var j = 0;j < raw_width; j++)
            data2[j] = inp[off++];
          for (dp = 0, col = 0;col < raw_width - 30; dp += 16) {
            max = 2047 & (val = bin.readUint(data2, dp));
            min = 2047 & val >>> 11;
            imax = 15 & val >>> 22;
            imin = 15 & val >>> 26;
            for (sh = 0;sh < 4 && 128 << sh <= max - min; sh++)
              ;
            for (bit = 30, i2 = 0;i2 < 16; i2++)
              if (i2 == imax)
                pix[i2] = max;
              else if (i2 == imin)
                pix[i2] = min;
              else {
                pix[i2] = ((bin.readUshort(data2, dp + (bit >> 3)) >>> (bit & 7) & 127) << sh) + min;
                if (pix[i2] > 2047)
                  pix[i2] = 2047;
                bit += 7;
              }
            for (i2 = 0;i2 < 16; i2++, col += 2) {
              var clr = pix[i2] << 1;
              UTIF2.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
            }
            col -= col & 1 ? 1 : 31;
          }
        }
      };
      UTIF2.decode._decodeNikon = function(img, imgs, data2, off, src_length, tgt, toff) {
        var nikon_tree = [
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            4,
            3,
            6,
            2,
            7,
            1,
            0,
            8,
            9,
            11,
            10,
            12
          ],
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            57,
            90,
            56,
            39,
            22,
            5,
            4,
            3,
            2,
            1,
            0,
            11,
            12,
            12
          ],
          [
            0,
            0,
            1,
            4,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            4,
            6,
            3,
            7,
            2,
            8,
            1,
            9,
            0,
            10,
            11,
            12
          ],
          [
            0,
            0,
            1,
            4,
            3,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            6,
            4,
            7,
            8,
            3,
            9,
            2,
            1,
            0,
            10,
            11,
            12,
            13,
            14
          ],
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            8,
            92,
            75,
            58,
            41,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            0,
            13,
            14
          ],
          [
            0,
            0,
            1,
            4,
            2,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            7,
            6,
            8,
            5,
            9,
            4,
            10,
            3,
            11,
            12,
            2,
            0,
            1,
            13,
            14
          ]
        ];
        var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
        var tree = 0, split = 0;
        var make_decoder = UTIF2.decode._make_decoder;
        var getbithuff = UTIF2.decode._getbithuff;
        var mn = imgs[0].exifIFD.makerNote, md = mn["t150"] ? mn["t150"] : mn["t140"], mdo = 0;
        var ver0 = md[mdo++], ver1 = md[mdo++];
        if (ver0 == 73 || ver1 == 88)
          mdo += 2110;
        if (ver0 == 70)
          tree = 2;
        if (tiff_bps == 14)
          tree += 3;
        var vpred = [[0, 0], [0, 0]], bin = img.isLE ? UTIF2._binLE : UTIF2._binBE;
        for (var i2 = 0;i2 < 2; i2++)
          for (var j = 0;j < 2; j++) {
            vpred[i2][j] = bin.readShort(md, mdo);
            mdo += 2;
          }
        var max = 1 << tiff_bps & 32767, step = 0;
        var csize = bin.readShort(md, mdo);
        mdo += 2;
        if (csize > 1)
          step = Math.floor(max / (csize - 1));
        if (ver0 == 68 && ver1 == 32 && step > 0)
          split = bin.readShort(md, 562);
        var i2;
        var row, col;
        var len, shl, diff;
        var min_v = 0;
        var hpred = [0, 0];
        var huff = make_decoder(nikon_tree[tree]);
        var prm = [off, 0, 0, 0];
        for (min_v = row = 0;row < height; row++) {
          if (split && row == split) {
            huff = make_decoder(nikon_tree[tree + 1]);
          }
          for (col = 0;col < raw_width; col++) {
            i2 = getbithuff(data2, prm, huff[0], huff);
            len = i2 & 15;
            shl = i2 >>> 4;
            diff = (getbithuff(data2, prm, len - shl, 0) << 1) + 1 << shl >>> 1;
            if ((diff & 1 << len - 1) == 0)
              diff -= (1 << len) - (shl == 0 ? 1 : 0);
            if (col < 2)
              hpred[col] = vpred[row & 1][col] += diff;
            else
              hpred[col & 1] += diff;
            var clr = Math.min(Math.max(hpred[col & 1], 0), (1 << tiff_bps) - 1);
            var bti = (row * raw_width + col) * tiff_bps;
            UTIF2.decode._putsF(tgt, bti, clr << 16 - tiff_bps);
          }
        }
      };
      UTIF2.decode._putsF = function(dt, pos, val) {
        val = val << 8 - (pos & 7);
        var o = pos >>> 3;
        dt[o] |= val >>> 16;
        dt[o + 1] |= val >>> 8;
        dt[o + 2] |= val;
      };
      UTIF2.decode._getbithuff = function(data2, prm, nbits, huff) {
        var zero_after_ff = 0;
        var get_byte = UTIF2.decode._get_byte;
        var c2;
        var off = prm[0], bitbuf = prm[1], vbits = prm[2], reset = prm[3];
        if (nbits == 0 || vbits < 0)
          return 0;
        while (!reset && vbits < nbits && (c2 = data2[off++]) != -1 && !(reset = zero_after_ff && c2 == 255 && data2[off++])) {
          bitbuf = (bitbuf << 8) + c2;
          vbits += 8;
        }
        c2 = bitbuf << 32 - vbits >>> 32 - nbits;
        if (huff) {
          vbits -= huff[c2 + 1] >>> 8;
          c2 = huff[c2 + 1] & 255;
        } else
          vbits -= nbits;
        if (vbits < 0)
          throw "e";
        prm[0] = off;
        prm[1] = bitbuf;
        prm[2] = vbits;
        prm[3] = reset;
        return c2;
      };
      UTIF2.decode._make_decoder = function(source) {
        var max, len, h, i2, j;
        var huff = [];
        for (max = 16;max != 0 && !source[max]; max--)
          ;
        var si = 17;
        huff[0] = max;
        for (h = len = 1;len <= max; len++)
          for (i2 = 0;i2 < source[len]; i2++, ++si)
            for (j = 0;j < 1 << max - len; j++)
              if (h <= 1 << max)
                huff[h++] = len << 8 | source[si];
        return huff;
      };
      UTIF2.decode._decodeNewJPEG = function(img, data2, off, len, tgt, toff) {
        len = Math.min(len, data2.length - off);
        var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
        if (tables) {
          var SOI = 216, EOI2 = 217, boff = 0;
          for (var i2 = 0;i2 < tlen - 1; i2++) {
            if (tables[i2] == 255 && tables[i2 + 1] == EOI2)
              break;
            buff[boff++] = tables[i2];
          }
          var byte1 = data2[off], byte2 = data2[off + 1];
          if (byte1 != 255 || byte2 != SOI) {
            buff[boff++] = byte1;
            buff[boff++] = byte2;
          }
          for (var i2 = 2;i2 < len; i2++)
            buff[boff++] = data2[off + i2];
        } else
          for (var i2 = 0;i2 < len; i2++)
            buff[i2] = data2[off + i2];
        if (img["t262"][0] == 32803 || img["t259"][0] == 7 && img["t262"][0] == 34892) {
          var bps = img["t258"][0];
          var out = UTIF2.LosslessJpegDecode(buff), olen = out.length;
          if (false) {
          } else if (bps == 16) {
            if (img.isLE)
              for (var i2 = 0;i2 < olen; i2++) {
                tgt[toff + (i2 << 1)] = out[i2] & 255;
                tgt[toff + (i2 << 1) + 1] = out[i2] >>> 8;
              }
            else
              for (var i2 = 0;i2 < olen; i2++) {
                tgt[toff + (i2 << 1)] = out[i2] >>> 8;
                tgt[toff + (i2 << 1) + 1] = out[i2] & 255;
              }
          } else if (bps == 14 || bps == 12 || bps == 10) {
            var rst = 16 - bps;
            for (var i2 = 0;i2 < olen; i2++)
              UTIF2.decode._putsF(tgt, i2 * bps, out[i2] << rst);
          } else if (bps == 8) {
            for (var i2 = 0;i2 < olen; i2++)
              tgt[toff + i2] = out[i2];
          } else
            throw new Error("unsupported bit depth " + bps);
        } else {
          var parser = new UTIF2.JpegDecoder;
          parser.parse(buff);
          var decoded = parser.getData({ width: parser.width, height: parser.height, forceRGB: true, isSourcePDF: false });
          for (var i2 = 0;i2 < decoded.length; i2++)
            tgt[toff + i2] = decoded[i2];
        }
        if (img["t262"][0] == 6)
          img["t262"][0] = 2;
      };
      UTIF2.decode._decodeOldJPEGInit = function(img, data2, off, len) {
        var SOI = 216, EOI2 = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS2 = 218;
        var joff = 0, soff = 0, tables, sosMarker2, isTiled = false, i2, j, k;
        var jpgIchgFmt = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
        var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
        var soffTag = img["t324"] || img["t273"] || jpgIchgFmt;
        var ycbcrss = img["t530"], ssx = 0, ssy = 0;
        var spp = img["t277"] ? img["t277"][0] : 1;
        var jpgresint = img["t515"];
        if (soffTag) {
          soff = soffTag[0];
          isTiled = soffTag.length > 1;
        }
        if (!isTiled) {
          if (data2[off] == 255 && data2[off + 1] == SOI)
            return { jpegOffset: off };
          if (jpgIchgFmt != null) {
            if (data2[off + jifoff] == 255 && data2[off + jifoff + 1] == SOI)
              joff = off + jifoff;
            else
              log("JPEGInterchangeFormat does not point to SOI");
            if (jpgIchgFmtLen == null)
              log("JPEGInterchangeFormatLength field is missing");
            else if (jifoff >= soff || jifoff + jiflen <= soff)
              log("JPEGInterchangeFormatLength field value is invalid");
            if (joff != null)
              return { jpegOffset: joff };
          }
        }
        if (ycbcrss != null) {
          ssx = ycbcrss[0];
          ssy = ycbcrss[1];
        }
        if (jpgIchgFmt != null) {
          if (jpgIchgFmtLen != null)
            if (jiflen >= 2 && jifoff + jiflen <= soff) {
              if (data2[off + jifoff + jiflen - 2] == 255 && data2[off + jifoff + jiflen - 1] == SOI)
                tables = new Uint8Array(jiflen - 2);
              else
                tables = new Uint8Array(jiflen);
              for (i2 = 0;i2 < tables.length; i2++)
                tables[i2] = data2[off + jifoff + i2];
              log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
            } else
              log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
        }
        if (tables == null) {
          var ooff = 0, out = [];
          out[ooff++] = 255;
          out[ooff++] = SOI;
          var qtables = img["t519"];
          if (qtables == null)
            throw new Error("JPEGQTables tag is missing");
          for (i2 = 0;i2 < qtables.length; i2++) {
            out[ooff++] = 255;
            out[ooff++] = DQT;
            out[ooff++] = 0;
            out[ooff++] = 67;
            out[ooff++] = i2;
            for (j = 0;j < 64; j++)
              out[ooff++] = data2[off + qtables[i2] + j];
          }
          for (k = 0;k < 2; k++) {
            var htables = img[k == 0 ? "t520" : "t521"];
            if (htables == null)
              throw new Error((k == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
            for (i2 = 0;i2 < htables.length; i2++) {
              out[ooff++] = 255;
              out[ooff++] = DHT;
              var nc = 19;
              for (j = 0;j < 16; j++)
                nc += data2[off + htables[i2] + j];
              out[ooff++] = nc >>> 8;
              out[ooff++] = nc & 255;
              out[ooff++] = i2 | k << 4;
              for (j = 0;j < 16; j++)
                out[ooff++] = data2[off + htables[i2] + j];
              for (j = 0;j < nc; j++)
                out[ooff++] = data2[off + htables[i2] + 16 + j];
            }
          }
          out[ooff++] = 255;
          out[ooff++] = SOF0;
          out[ooff++] = 0;
          out[ooff++] = 8 + 3 * spp;
          out[ooff++] = 8;
          out[ooff++] = img.height >>> 8 & 255;
          out[ooff++] = img.height & 255;
          out[ooff++] = img.width >>> 8 & 255;
          out[ooff++] = img.width & 255;
          out[ooff++] = spp;
          if (spp == 1) {
            out[ooff++] = 1;
            out[ooff++] = 17;
            out[ooff++] = 0;
          } else
            for (i2 = 0;i2 < 3; i2++) {
              out[ooff++] = i2 + 1;
              out[ooff++] = i2 != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
              out[ooff++] = i2;
            }
          if (jpgresint != null && jpgresint[0] != 0) {
            out[ooff++] = 255;
            out[ooff++] = DRI;
            out[ooff++] = 0;
            out[ooff++] = 4;
            out[ooff++] = jpgresint[0] >>> 8 & 255;
            out[ooff++] = jpgresint[0] & 255;
          }
          tables = new Uint8Array(out);
        }
        var sofpos = -1;
        i2 = 0;
        while (i2 < tables.length - 1) {
          if (tables[i2] == 255 && tables[i2 + 1] == SOF0) {
            sofpos = i2;
            break;
          }
          i2++;
        }
        if (sofpos == -1) {
          var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
          tmptab.set(tables);
          var tmpoff = tables.length;
          sofpos = tables.length;
          tables = tmptab;
          tables[tmpoff++] = 255;
          tables[tmpoff++] = SOF0;
          tables[tmpoff++] = 0;
          tables[tmpoff++] = 8 + 3 * spp;
          tables[tmpoff++] = 8;
          tables[tmpoff++] = img.height >>> 8 & 255;
          tables[tmpoff++] = img.height & 255;
          tables[tmpoff++] = img.width >>> 8 & 255;
          tables[tmpoff++] = img.width & 255;
          tables[tmpoff++] = spp;
          if (spp == 1) {
            tables[tmpoff++] = 1;
            tables[tmpoff++] = 17;
            tables[tmpoff++] = 0;
          } else
            for (i2 = 0;i2 < 3; i2++) {
              tables[tmpoff++] = i2 + 1;
              tables[tmpoff++] = i2 != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
              tables[tmpoff++] = i2;
            }
        }
        if (data2[soff] == 255 && data2[soff + 1] == SOS2) {
          var soslen = data2[soff + 2] << 8 | data2[soff + 3];
          sosMarker2 = new Uint8Array(soslen + 2);
          sosMarker2[0] = data2[soff];
          sosMarker2[1] = data2[soff + 1];
          sosMarker2[2] = data2[soff + 2];
          sosMarker2[3] = data2[soff + 3];
          for (i2 = 0;i2 < soslen - 2; i2++)
            sosMarker2[i2 + 4] = data2[soff + i2 + 4];
        } else {
          sosMarker2 = new Uint8Array(2 + 6 + 2 * spp);
          var sosoff = 0;
          sosMarker2[sosoff++] = 255;
          sosMarker2[sosoff++] = SOS2;
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 6 + 2 * spp;
          sosMarker2[sosoff++] = spp;
          if (spp == 1) {
            sosMarker2[sosoff++] = 1;
            sosMarker2[sosoff++] = 0;
          } else
            for (i2 = 0;i2 < 3; i2++) {
              sosMarker2[sosoff++] = i2 + 1;
              sosMarker2[sosoff++] = i2 << 4 | i2;
            }
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 63;
          sosMarker2[sosoff++] = 0;
        }
        return { jpegOffset: off, tables, sosMarker: sosMarker2, sofPosition: sofpos };
      };
      UTIF2.decode._decodeOldJPEG = function(img, data2, off, len, tgt, toff) {
        var i2, dlen, tlen, buff, buffoff;
        var jpegData = UTIF2.decode._decodeOldJPEGInit(img, data2, off, len);
        if (jpegData.jpegOffset != null) {
          dlen = off + len - jpegData.jpegOffset;
          buff = new Uint8Array(dlen);
          for (i2 = 0;i2 < dlen; i2++)
            buff[i2] = data2[jpegData.jpegOffset + i2];
        } else {
          tlen = jpegData.tables.length;
          buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
          buff.set(jpegData.tables);
          buffoff = tlen;
          buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;
          buff[jpegData.sofPosition + 6] = img.height & 255;
          buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;
          buff[jpegData.sofPosition + 8] = img.width & 255;
          if (data2[off] != 255 || data2[off + 1] != SOS) {
            buff.set(jpegData.sosMarker, buffoff);
            buffoff += sosMarker.length;
          }
          for (i2 = 0;i2 < len; i2++)
            buff[buffoff++] = data2[off + i2];
          buff[buffoff++] = 255;
          buff[buffoff++] = EOI;
        }
        var parser = new UTIF2.JpegDecoder;
        parser.parse(buff);
        var decoded = parser.getData({ width: parser.width, height: parser.height, forceRGB: true, isSourcePDF: false });
        for (var i2 = 0;i2 < decoded.length; i2++)
          tgt[toff + i2] = decoded[i2];
        if (img["t262"] && img["t262"][0] == 6)
          img["t262"][0] = 2;
      };
      UTIF2.decode._decodePackBits = function(data2, off, len, tgt, toff) {
        var sa = new Int8Array(data2.buffer), ta = new Int8Array(tgt.buffer), lim = off + len;
        while (off < lim) {
          var n = sa[off];
          off++;
          if (n >= 0 && n < 128)
            for (var i2 = 0;i2 < n + 1; i2++) {
              ta[toff] = sa[off];
              toff++;
              off++;
            }
          if (n >= -127 && n < 0) {
            for (var i2 = 0;i2 < -n + 1; i2++) {
              ta[toff] = sa[off];
              toff++;
            }
            off++;
          }
        }
        return toff;
      };
      UTIF2.decode._decodeThunder = function(data2, off, len, tgt, toff) {
        var d2 = [0, 1, 0, -1], d3 = [0, 1, 2, 3, 0, -3, -2, -1];
        var lim = off + len, qoff = toff * 2, px2 = 0;
        while (off < lim) {
          var b = data2[off], msk = b >>> 6, n = b & 63;
          off++;
          if (msk == 3) {
            px2 = n & 15;
            tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
            qoff++;
          }
          if (msk == 0)
            for (var i2 = 0;i2 < n; i2++) {
              tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
              qoff++;
            }
          if (msk == 2)
            for (var i2 = 0;i2 < 2; i2++) {
              var d = n >>> 3 * (1 - i2) & 7;
              if (d != 4) {
                px2 += d3[d];
                tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
                qoff++;
              }
            }
          if (msk == 1)
            for (var i2 = 0;i2 < 3; i2++) {
              var d = n >>> 2 * (2 - i2) & 3;
              if (d != 2) {
                px2 += d2[d];
                tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
                qoff++;
              }
            }
        }
      };
      UTIF2.decode._dmap = { "1": 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 };
      UTIF2.decode._lens = function() {
        var addKeys = function(lens, arr, i0, inc) {
          for (var i2 = 0;i2 < arr.length; i2++)
            lens[arr[i2]] = i0 + i2 * inc;
        };
        var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
        var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
        var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
        var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101";
        var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
        termW = termW.split(",");
        termB = termB.split(",");
        makeW = makeW.split(",");
        makeB = makeB.split(",");
        makeA = makeA.split(",");
        var lensW = {}, lensB = {};
        addKeys(lensW, termW, 0, 1);
        addKeys(lensW, makeW, 64, 64);
        addKeys(lensW, makeA, 1792, 64);
        addKeys(lensB, termB, 0, 1);
        addKeys(lensB, makeB, 64, 64);
        addKeys(lensB, makeA, 1792, 64);
        return [lensW, lensB];
      }();
      UTIF2.decode._decodeG4 = function(data2, off, slen, tgt, toff, w, fo) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i2 = 0;i2 < w; i2++)
          pline.push(0);
        pline = U._makeDiff(pline);
        var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
        var y = 0, mode = "", toRead = 0;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1)
            bit = data2[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data2[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (mode == "H") {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                a0 += len;
                clr = 1 - clr;
                len = 0;
                toRead--;
                if (toRead == 0)
                  mode = "";
              }
            }
          } else {
            if (wrd == "0001") {
              wrd = "";
              U._addNtimes(line, b2 - a0, clr);
              a0 = b2;
            }
            if (wrd == "001") {
              wrd = "";
              mode = "H";
              toRead = 2;
            }
            if (U._dmap[wrd] != null) {
              a1 = b1 + U._dmap[wrd];
              U._addNtimes(line, a1 - a0, clr);
              a0 = a1;
              wrd = "";
              clr = 1 - clr;
            }
          }
          if (line.length == w && mode == "") {
            U._writeBits(line, tgt, toff * 8 + y * bipl);
            clr = 0;
            y++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
      };
      UTIF2.decode._findDiff = function(line, x, clr) {
        for (var i2 = 0;i2 < line.length; i2 += 2)
          if (line[i2] >= x && line[i2 + 1] == clr)
            return line[i2];
      };
      UTIF2.decode._makeDiff = function(line) {
        var out = [];
        if (line[0] == 1)
          out.push(0, 1);
        for (var i2 = 1;i2 < line.length; i2++)
          if (line[i2 - 1] != line[i2])
            out.push(i2, line[i2]);
        out.push(line.length, 0, line.length, 1);
        return out;
      };
      UTIF2.decode._decodeG2 = function(data2, off, slen, tgt, toff, w, fo) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [];
        var clr = 0;
        var y = 0;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          var bit = 0;
          if (fo == 1)
            bit = data2[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data2[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          len = U._lens[clr][wrd];
          if (len != null) {
            U._addNtimes(line, len, clr);
            wrd = "";
            if (len < 64)
              clr = 1 - clr;
            if (line.length == w) {
              U._writeBits(line, tgt, toff * 8 + y * bipl);
              line = [];
              y++;
              clr = 0;
              if ((boff & 7) != 0)
                boff += 8 - (boff & 7);
              if (len >= 64)
                boff += 8;
            }
          }
        }
      };
      UTIF2.decode._decodeG3 = function(data2, off, slen, tgt, toff, w, fo, twoDim) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i2 = 0;i2 < w; i2++)
          line.push(0);
        var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
        var y = -1, mode = "", toRead = 0, is1D = true;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1)
            bit = data2[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data2[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (is1D) {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                clr = 1 - clr;
                len = 0;
              }
            }
          } else {
            if (mode == "H") {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  a0 += len;
                  clr = 1 - clr;
                  len = 0;
                  toRead--;
                  if (toRead == 0)
                    mode = "";
                }
              }
            } else {
              if (wrd == "0001") {
                wrd = "";
                U._addNtimes(line, b2 - a0, clr);
                a0 = b2;
              }
              if (wrd == "001") {
                wrd = "";
                mode = "H";
                toRead = 2;
              }
              if (U._dmap[wrd] != null) {
                a1 = b1 + U._dmap[wrd];
                U._addNtimes(line, a1 - a0, clr);
                a0 = a1;
                wrd = "";
                clr = 1 - clr;
              }
            }
          }
          if (wrd.endsWith("000000000001")) {
            if (y >= 0)
              U._writeBits(line, tgt, toff * 8 + y * bipl);
            if (twoDim) {
              if (fo == 1)
                is1D = (data2[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;
              if (fo == 2)
                is1D = (data2[boff >>> 3] >>> (boff & 7) & 1) == 1;
              boff++;
            }
            wrd = "";
            clr = 0;
            y++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
        if (line.length == w)
          U._writeBits(line, tgt, toff * 8 + y * bipl);
      };
      UTIF2.decode._addNtimes = function(arr, n, val) {
        for (var i2 = 0;i2 < n; i2++)
          arr.push(val);
      };
      UTIF2.decode._writeBits = function(bits, tgt, boff) {
        for (var i2 = 0;i2 < bits.length; i2++)
          tgt[boff + i2 >>> 3] |= bits[i2] << 7 - (boff + i2 & 7);
      };
      UTIF2.decode._decodeLZW = UTIF2.decode._decodeLZW = function() {
        var e, U, Z, u, K = 0, V = 0, g = 0, N = 0, O = function() {
          var S = e >>> 3, A = U[S] << 16 | U[S + 1] << 8 | U[S + 2], j = A >>> 24 - (e & 7) - V & (1 << V) - 1;
          e += V;
          return j;
        }, h = new Uint32Array(4096 * 4), w = 0, m = function(S) {
          if (S == w)
            return;
          w = S;
          g = 1 << S;
          N = g + 1;
          for (var A = 0;A < N + 1; A++) {
            h[4 * A] = h[4 * A + 3] = A;
            h[4 * A + 1] = 65535;
            h[4 * A + 2] = 1;
          }
        }, i2 = function(S) {
          V = S + 1;
          K = N + 1;
        }, D = function(S) {
          var A = S << 2, j = h[A + 2], a = u + j - 1;
          while (A != 65535) {
            Z[a--] = h[A];
            A = h[A + 1];
          }
          u += j;
        }, L = function(S, A) {
          var j = K << 2, a = S << 2;
          h[j] = h[(A << 2) + 3];
          h[j + 1] = a;
          h[j + 2] = h[a + 2] + 1;
          h[j + 3] = h[a + 3];
          K++;
          if (K + 1 == 1 << V && V != 12)
            V++;
        }, T = function(S, A, j, a, n, q) {
          e = A << 3;
          U = S;
          Z = a;
          u = n;
          var B = A + j << 3, _ = 0, t = 0;
          m(q);
          i2(q);
          while (e < B && (_ = O()) != N) {
            if (_ == g) {
              i2(q);
              _ = O();
              if (_ == N)
                break;
              D(_);
            } else {
              if (_ < K) {
                D(_);
                L(t, _);
              } else {
                L(t, t);
                D(K - 1);
              }
            }
            t = _;
          }
          return u;
        };
        return T;
      }();
      UTIF2.tags = {};
      UTIF2._types = function() {
        var main = new Array(250);
        main.fill(0);
        main = main.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var rest = { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 };
        return {
          basic: {
            main,
            rest
          },
          gps: {
            main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9],
            rest: { 18: 2, 29: 2 }
          }
        };
      }();
      UTIF2._readIFD = function(bin, data2, offset, ifds, depth, prm) {
        var cnt = bin.readUshort(data2, offset);
        offset += 2;
        var ifd = {};
        if (prm.debug)
          log("   ".repeat(depth), ifds.length - 1, ">>>----------------");
        for (var i2 = 0;i2 < cnt; i2++) {
          var tag = bin.readUshort(data2, offset);
          offset += 2;
          var type = bin.readUshort(data2, offset);
          offset += 2;
          var num = bin.readUint(data2, offset);
          offset += 4;
          var voff = bin.readUint(data2, offset);
          offset += 4;
          var arr = [];
          if (type == 1 || type == 7) {
            var no = num < 5 ? offset - 4 : voff;
            if (no + num > data2.buffer.byteLength)
              num = data2.buffer.byteLength - no;
            arr = new Uint8Array(data2.buffer, no, num);
          }
          if (type == 2) {
            var o0 = num < 5 ? offset - 4 : voff, c2 = data2[o0], len = Math.max(0, Math.min(num - 1, data2.length - o0));
            if (c2 < 128 || len == 0)
              arr.push(bin.readASCII(data2, o0, len));
            else
              arr = new Uint8Array(data2.buffer, o0, len);
          }
          if (type == 3) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readUshort(data2, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 4 || type == 13) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readUint(data2, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 5 || type == 10) {
            var ri = type == 5 ? bin.readUint : bin.readInt;
            for (var j = 0;j < num; j++)
              arr.push([ri(data2, voff + j * 8), ri(data2, voff + j * 8 + 4)]);
          }
          if (type == 8) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readShort(data2, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 9) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readInt(data2, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 11) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readFloat(data2, voff + j * 4));
          }
          if (type == 12) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readDouble(data2, voff + j * 8));
          }
          if (num != 0 && arr.length == 0) {
            log(tag, "unknown TIFF tag type: ", type, "num:", num);
            if (i2 == 0)
              return;
            continue;
          }
          if (prm.debug)
            log("   ".repeat(depth), tag, type, UTIF2.tags[tag], arr);
          ifd["t" + tag] = arr;
          if (tag == 330 && ifd["t272"] && ifd["t272"][0] == "DSLR-A100") {
          } else if (tag == 330 || tag == 34665 || tag == 34853 || tag == 50740 && bin.readUshort(data2, bin.readUint(arr, 0)) < 300 || tag == 61440) {
            var oarr = tag == 50740 ? [bin.readUint(arr, 0)] : arr;
            var subfd = [];
            for (var j = 0;j < oarr.length; j++)
              UTIF2._readIFD(bin, data2, oarr[j], subfd, depth + 1, prm);
            if (tag == 330)
              ifd.subIFD = subfd;
            if (tag == 34665)
              ifd.exifIFD = subfd[0];
            if (tag == 34853)
              ifd.gpsiIFD = subfd[0];
            if (tag == 50740)
              ifd.dngPrvt = subfd[0];
            if (tag == 61440)
              ifd.fujiIFD = subfd[0];
          }
          if (tag == 37500 && prm.parseMN) {
            var mn = arr;
            if (bin.readASCII(mn, 0, 5) == "Nikon")
              ifd.makerNote = UTIF2["decode"](mn.slice(10).buffer)[0];
            else if (bin.readASCII(mn, 0, 5) == "OLYMP" || bin.readASCII(mn, 0, 9) == "OM SYSTEM") {
              var inds = [8208, 8224, 8240, 8256, 8272];
              var subsub = [];
              UTIF2._readIFD(bin, mn, mn[1] == 77 ? 16 : mn[5] == 85 ? 12 : 8, subsub, depth + 1, prm);
              var obj = ifd.makerNote = subsub.pop();
              for (var j = 0;j < inds.length; j++) {
                var k = "t" + inds[j];
                if (obj[k] == null)
                  continue;
                UTIF2._readIFD(bin, mn, obj[k][0], subsub, depth + 1, prm);
                obj[k] = subsub.pop();
              }
              if (obj["t12288"]) {
                UTIF2._readIFD(bin, obj["t12288"], 0, subsub, depth + 1, prm);
                obj["t12288"] = subsub.pop();
              }
            } else if (bin.readUshort(data2, voff) < 300 && bin.readUshort(data2, voff + 4) <= 12) {
              var subsub = [];
              UTIF2._readIFD(bin, data2, voff, subsub, depth + 1, prm);
              ifd.makerNote = subsub[0];
            }
          }
        }
        ifds.push(ifd);
        if (prm.debug)
          log("   ".repeat(depth), "<<<---------------");
        return offset;
      };
      UTIF2._writeIFD = function(bin, types, data2, offset, ifd) {
        var keys = Object.keys(ifd), knum = keys.length;
        if (ifd["exifIFD"])
          knum--;
        if (ifd["gpsiIFD"])
          knum--;
        bin.writeUshort(data2, offset, knum);
        offset += 2;
        var eoff = offset + knum * 12 + 4;
        for (var ki = 0;ki < keys.length; ki++) {
          var key = keys[ki];
          if (key == "t34665" || key == "t34853")
            continue;
          if (key == "exifIFD")
            key = "t34665";
          if (key == "gpsiIFD")
            key = "t34853";
          var tag = parseInt(key.slice(1)), type = types.main[tag];
          if (type == null)
            type = types.rest[tag];
          if (type == null || type == 0)
            throw new Error("unknown type of tag: " + tag);
          var val = ifd[key];
          if (tag == 34665) {
            var outp = UTIF2._writeIFD(bin, types, data2, eoff, ifd["exifIFD"]);
            val = [eoff];
            eoff = outp[1];
          }
          if (tag == 34853) {
            var outp = UTIF2._writeIFD(bin, UTIF2._types.gps, data2, eoff, ifd["gpsiIFD"]);
            val = [eoff];
            eoff = outp[1];
          }
          if (type == 2)
            val = val[0] + "\0";
          var num = val.length;
          bin.writeUshort(data2, offset, tag);
          offset += 2;
          bin.writeUshort(data2, offset, type);
          offset += 2;
          bin.writeUint(data2, offset, num);
          offset += 4;
          var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num;
          var toff = offset;
          if (dlen > 4) {
            bin.writeUint(data2, offset, eoff);
            toff = eoff;
          }
          if (type == 1 || type == 7) {
            for (var i2 = 0;i2 < num; i2++)
              data2[toff + i2] = val[i2];
          } else if (type == 2) {
            bin.writeASCII(data2, toff, val);
          } else if (type == 3) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeUshort(data2, toff + 2 * i2, val[i2]);
          } else if (type == 4) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeUint(data2, toff + 4 * i2, val[i2]);
          } else if (type == 5 || type == 10) {
            var wr = type == 5 ? bin.writeUint : bin.writeInt;
            for (var i2 = 0;i2 < num; i2++) {
              var v = val[i2], nu = v[0], de = v[1];
              if (nu == null)
                throw "e";
              wr(data2, toff + 8 * i2, nu);
              wr(data2, toff + 8 * i2 + 4, de);
            }
          } else if (type == 9) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeInt(data2, toff + 4 * i2, val[i2]);
          } else if (type == 12) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeDouble(data2, toff + 8 * i2, val[i2]);
          } else
            throw type;
          if (dlen > 4) {
            dlen += dlen & 1;
            eoff += dlen;
          }
          offset += 4;
        }
        return [offset, eoff];
      };
      UTIF2.toRGBA8 = function(out, scl) {
        function gamma(x2) {
          return x2 < 0.0031308 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055;
        }
        var { width: w, height: h } = out, area = w * h, qarea = area * 4, data2 = out.data;
        var img = new Uint8Array(area * 4);
        var intp = out["t262"] ? out["t262"][0] : 2, bps = out["t258"] ? Math.min(32, out["t258"][0]) : 1;
        if (out["t262"] == null && bps == 1)
          intp = 0;
        var smpls = out["t277"] ? out["t277"][0] : out["t258"] ? out["t258"].length : [1, 1, 3, 1, 1, 4, 3][intp];
        var sfmt = out["t339"] ? out["t339"][0] : null;
        if (intp == 1 && bps == 32 && sfmt != 3)
          throw "e";
        var bpl = Math.ceil(smpls * bps * w / 8);
        if (false) {
        } else if (intp == 0) {
          scl = 1 / 256;
          for (var y = 0;y < h; y++) {
            var off = y * bpl, io = y * w;
            if (bps == 1)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px2 = data2[off + (i2 >> 3)] >> 7 - (i2 & 7) & 1;
                img[qi] = img[qi + 1] = img[qi + 2] = (1 - px2) * 255;
                img[qi + 3] = 255;
              }
            if (bps == 4)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px2 = data2[off + (i2 >> 1)] >> 4 - 4 * (i2 & 1) & 15;
                img[qi] = img[qi + 1] = img[qi + 2] = (15 - px2) * 17;
                img[qi + 3] = 255;
              }
            if (bps == 8)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px2 = data2[off + i2];
                img[qi] = img[qi + 1] = img[qi + 2] = 255 - px2;
                img[qi + 3] = 255;
              }
            if (bps == 16)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, o = off + 2 * i2, px2 = data2[o + 1] << 8 | data2[o];
                img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, 255 - ~~(px2 * scl));
                img[qi + 3] = 255;
              }
          }
        } else if (intp == 1) {
          if (scl == null)
            scl = 1 / 256;
          var f32 = (data2.length & 3) == 0 ? new Float32Array(data2.buffer) : null;
          for (var y = 0;y < h; y++) {
            var off = y * bpl, io = y * w;
            if (bps == 1)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px2 = data2[off + (i2 >> 3)] >> 7 - (i2 & 7) & 1;
                img[qi] = img[qi + 1] = img[qi + 2] = px2 * 255;
                img[qi + 3] = 255;
              }
            if (bps == 2)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px2 = data2[off + (i2 >> 2)] >> 6 - 2 * (i2 & 3) & 3;
                img[qi] = img[qi + 1] = img[qi + 2] = px2 * 85;
                img[qi + 3] = 255;
              }
            if (bps == 8)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px2 = data2[off + i2 * smpls];
                img[qi] = img[qi + 1] = img[qi + 2] = px2;
                img[qi + 3] = 255;
              }
            if (bps == 16)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, o = off + 2 * i2, px2 = data2[o + 1] << 8 | data2[o];
                img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, ~~(px2 * scl));
                img[qi + 3] = 255;
              }
            if (bps == 32)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, o = (off >>> 2) + i2, px2 = f32[o];
                img[qi] = img[qi + 1] = img[qi + 2] = ~~(0.5 + 255 * px2);
                img[qi + 3] = 255;
              }
          }
        } else if (intp == 2) {
          if (bps == 8) {
            if (smpls == 1)
              for (var i2 = 0;i2 < area; i2++) {
                img[4 * i2] = img[4 * i2 + 1] = img[4 * i2 + 2] = data2[i2];
                img[4 * i2 + 3] = 255;
              }
            if (smpls == 3)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 3;
                img[qi] = data2[ti];
                img[qi + 1] = data2[ti + 1];
                img[qi + 2] = data2[ti + 2];
                img[qi + 3] = 255;
              }
            if (smpls >= 4)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * smpls;
                img[qi] = data2[ti];
                img[qi + 1] = data2[ti + 1];
                img[qi + 2] = data2[ti + 2];
                img[qi + 3] = data2[ti + 3];
              }
          } else if (bps == 16) {
            if (smpls == 4)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 8 + 1;
                img[qi] = data2[ti];
                img[qi + 1] = data2[ti + 2];
                img[qi + 2] = data2[ti + 4];
                img[qi + 3] = data2[ti + 6];
              }
            if (smpls == 3)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 6 + 1;
                img[qi] = data2[ti];
                img[qi + 1] = data2[ti + 2];
                img[qi + 2] = data2[ti + 4];
                img[qi + 3] = 255;
              }
          } else if (bps == 32) {
            var ndt = new Float32Array(data2.buffer);
            var min = 0;
            for (var i2 = 0;i2 < ndt.length; i2++)
              min = Math.min(min, ndt[i2]);
            if (min < 0)
              for (var i2 = 0;i2 < data2.length; i2 += 4) {
                var t = data2[i2];
                data2[i2] = data2[i2 + 3];
                data2[i2 + 3] = t;
                t = data2[i2 + 1];
                data2[i2 + 1] = data2[i2 + 2];
                data2[i2 + 2] = t;
              }
            var pmap = [];
            for (var i2 = 0;i2 < 65536; i2++)
              pmap.push(gamma(i2 / 65535));
            for (var i2 = 0;i2 < ndt.length; i2++) {
              var cv = Math.max(0, Math.min(1, ndt[i2]));
              ndt[i2] = pmap[~~(0.5 + cv * 65535)];
            }
            if (smpls == 3)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 3;
                img[qi] = ~~(0.5 + ndt[ti] * 255);
                img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
                img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
                img[qi + 3] = 255;
              }
            else if (smpls == 4)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 4;
                img[qi] = ~~(0.5 + ndt[ti] * 255);
                img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
                img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
                img[qi + 3] = ~~(0.5 + ndt[ti + 3] * 255);
              }
            else
              throw smpls;
          } else
            throw bps;
        } else if (intp == 3) {
          var map = out["t320"];
          var cn = 1 << bps;
          var nexta = bps == 8 && smpls > 1 && out["t338"] && out["t338"][0] != 0;
          for (var y = 0;y < h; y++)
            for (var x = 0;x < w; x++) {
              var i2 = y * w + x;
              var qi = i2 << 2, mi = 0;
              var dof = y * bpl;
              if (false) {
              } else if (bps == 1)
                mi = data2[dof + (x >>> 3)] >>> 7 - (x & 7) & 1;
              else if (bps == 2)
                mi = data2[dof + (x >>> 2)] >>> 6 - 2 * (x & 3) & 3;
              else if (bps == 4)
                mi = data2[dof + (x >>> 1)] >>> 4 - 4 * (x & 1) & 15;
              else if (bps == 8)
                mi = data2[dof + x * smpls];
              else
                throw bps;
              img[qi] = map[mi] >> 8;
              img[qi + 1] = map[cn + mi] >> 8;
              img[qi + 2] = map[cn + cn + mi] >> 8;
              img[qi + 3] = nexta ? data2[dof + x * smpls + 1] : 255;
            }
        } else if (intp == 5) {
          var gotAlpha = smpls > 4 ? 1 : 0;
          for (var i2 = 0;i2 < area; i2++) {
            var qi = i2 << 2, si = i2 * smpls;
            if (window.UDOC) {
              var C = data2[si], M = data2[si + 1], Y = data2[si + 2], K = data2[si + 3];
              var c2 = UDOC.C.cmykToRgb([C * (1 / 255), M * (1 / 255), Y * (1 / 255), K * (1 / 255)]);
              img[qi] = ~~(0.5 + 255 * c2[0]);
              img[qi + 1] = ~~(0.5 + 255 * c2[1]);
              img[qi + 2] = ~~(0.5 + 255 * c2[2]);
            } else {
              var C = 255 - data2[si], M = 255 - data2[si + 1], Y = 255 - data2[si + 2], K = (255 - data2[si + 3]) * (1 / 255);
              img[qi] = ~~(C * K + 0.5);
              img[qi + 1] = ~~(M * K + 0.5);
              img[qi + 2] = ~~(Y * K + 0.5);
            }
            img[qi + 3] = 255 * (1 - gotAlpha) + data2[si + 4] * gotAlpha;
          }
        } else if (intp == 6 && out["t278"]) {
          var rps = out["t278"][0];
          for (var y = 0;y < h; y += rps) {
            var i2 = y * w, len = rps * w;
            for (var j = 0;j < len; j++) {
              var qi = 4 * (i2 + j), si = 3 * i2 + 4 * (j >>> 1);
              var Y = data2[si + (j & 1)], Cb = data2[si + 2] - 128, Cr = data2[si + 3] - 128;
              var r = Y + ((Cr >> 2) + (Cr >> 3) + (Cr >> 5));
              var g = Y - ((Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ((Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5));
              var b = Y + (Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6));
              img[qi] = Math.max(0, Math.min(255, r));
              img[qi + 1] = Math.max(0, Math.min(255, g));
              img[qi + 2] = Math.max(0, Math.min(255, b));
              img[qi + 3] = 255;
            }
          }
        } else if (intp == 32845) {
          for (var y = 0;y < h; y++)
            for (var x = 0;x < w; x++) {
              var si = (y * w + x) * 6, qi = (y * w + x) * 4;
              var L = data2[si + 1] << 8 | data2[si];
              var L = Math.pow(2, (L + 0.5) / 256 - 64);
              var u = (data2[si + 3] + 0.5) / 410;
              var v = (data2[si + 5] + 0.5) / 410;
              var sX = 9 * u / (6 * u - 16 * v + 12);
              var sY = 4 * v / (6 * u - 16 * v + 12);
              var bY = L;
              var X = sX * bY / sY, Y = bY, Z = (1 - sX - sY) * bY / sY;
              var r = 2.69 * X - 1.276 * Y - 0.414 * Z;
              var g = -1.022 * X + 1.978 * Y + 0.044 * Z;
              var b = 0.061 * X - 0.224 * Y + 1.163 * Z;
              img[qi] = gamma(Math.min(r, 1)) * 255;
              img[qi + 1] = gamma(Math.min(g, 1)) * 255;
              img[qi + 2] = gamma(Math.min(b, 1)) * 255;
              img[qi + 3] = 255;
            }
        } else
          log("Unknown Photometric interpretation: " + intp);
        return img;
      };
      UTIF2.replaceIMG = function(imgs) {
        if (imgs == null)
          imgs = document.getElementsByTagName("img");
        var sufs = ["tif", "tiff", "dng", "cr2", "nef"];
        for (var i2 = 0;i2 < imgs.length; i2++) {
          var img = imgs[i2], src = img.getAttribute("src");
          if (src == null)
            continue;
          var suff = src.split(".").pop().toLowerCase();
          if (sufs.indexOf(suff) == -1)
            continue;
          var xhr = new XMLHttpRequest;
          UTIF2._xhrs.push(xhr);
          UTIF2._imgs.push(img);
          xhr.open("GET", src);
          xhr.responseType = "arraybuffer";
          xhr.onload = UTIF2._imgLoaded;
          xhr.send();
        }
      };
      UTIF2._xhrs = [];
      UTIF2._imgs = [];
      UTIF2._imgLoaded = function(e) {
        var ind = UTIF2._xhrs.indexOf(e.target), img = UTIF2._imgs[ind];
        UTIF2._xhrs.splice(ind, 1);
        UTIF2._imgs.splice(ind, 1);
        img.setAttribute("src", UTIF2.bufferToURI(e.target.response));
      };
      UTIF2.bufferToURI = function(buff) {
        var ifds = UTIF2.decode(buff);
        var vsns = ifds, ma = 0, page = vsns[0];
        if (ifds[0].subIFD)
          vsns = vsns.concat(ifds[0].subIFD);
        for (var i2 = 0;i2 < vsns.length; i2++) {
          var img = vsns[i2];
          if (img["t258"] == null || img["t258"].length < 3)
            continue;
          var ar = img["t256"] * img["t257"];
          if (ar > ma) {
            ma = ar;
            page = img;
          }
        }
        UTIF2.decodeImage(buff, page, ifds);
        var rgba = UTIF2.toRGBA8(page), w = page.width, h = page.height;
        var cnv = document.createElement("canvas");
        cnv.width = w;
        cnv.height = h;
        var ctx = cnv.getContext("2d");
        var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer), w, h);
        ctx.putImageData(imgd, 0, 0);
        return cnv.toDataURL();
      };
      UTIF2._binBE = {
        nextZero: function(data2, o) {
          while (data2[o] != 0)
            o++;
          return o;
        },
        readUshort: function(buff, p) {
          return buff[p] << 8 | buff[p + 1];
        },
        readShort: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 1];
          a[1] = buff[p + 0];
          return UTIF2._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 3];
          a[1] = buff[p + 2];
          a[2] = buff[p + 1];
          a[3] = buff[p + 0];
          return UTIF2._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 3];
          a[1] = buff[p + 2];
          a[2] = buff[p + 1];
          a[3] = buff[p + 0];
          return UTIF2._binBE.ui32[0];
        },
        readASCII: function(buff, p, l) {
          var s = "";
          for (var i2 = 0;i2 < l; i2++)
            s += String.fromCharCode(buff[p + i2]);
          return s;
        },
        readFloat: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 4; i2++)
            a[i2] = buff[p + 3 - i2];
          return UTIF2._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 8; i2++)
            a[i2] = buff[p + 7 - i2];
          return UTIF2._binBE.fl64[0];
        },
        writeUshort: function(buff, p, n) {
          buff[p] = n >> 8 & 255;
          buff[p + 1] = n & 255;
        },
        writeInt: function(buff, p, n) {
          var a = UTIF2._binBE.ui8;
          UTIF2._binBE.i32[0] = n;
          buff[p + 3] = a[0];
          buff[p + 2] = a[1];
          buff[p + 1] = a[2];
          buff[p + 0] = a[3];
        },
        writeUint: function(buff, p, n) {
          buff[p] = n >> 24 & 255;
          buff[p + 1] = n >> 16 & 255;
          buff[p + 2] = n >> 8 & 255;
          buff[p + 3] = n >> 0 & 255;
        },
        writeASCII: function(buff, p, s) {
          for (var i2 = 0;i2 < s.length; i2++)
            buff[p + i2] = s.charCodeAt(i2);
        },
        writeDouble: function(buff, p, n) {
          UTIF2._binBE.fl64[0] = n;
          for (var i2 = 0;i2 < 8; i2++)
            buff[p + i2] = UTIF2._binBE.ui8[7 - i2];
        }
      };
      UTIF2._binBE.ui8 = new Uint8Array(8);
      UTIF2._binBE.i16 = new Int16Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.i32 = new Int32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.ui32 = new Uint32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.fl32 = new Float32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.fl64 = new Float64Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binLE = {
        nextZero: UTIF2._binBE.nextZero,
        readUshort: function(buff, p) {
          return buff[p + 1] << 8 | buff[p];
        },
        readShort: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          return UTIF2._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          a[2] = buff[p + 2];
          a[3] = buff[p + 3];
          return UTIF2._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          a[0] = buff[p + 0];
          a[1] = buff[p + 1];
          a[2] = buff[p + 2];
          a[3] = buff[p + 3];
          return UTIF2._binBE.ui32[0];
        },
        readASCII: UTIF2._binBE.readASCII,
        readFloat: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 4; i2++)
            a[i2] = buff[p + i2];
          return UTIF2._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 8; i2++)
            a[i2] = buff[p + i2];
          return UTIF2._binBE.fl64[0];
        },
        writeUshort: function(buff, p, n) {
          buff[p] = n & 255;
          buff[p + 1] = n >> 8 & 255;
        },
        writeInt: function(buff, p, n) {
          var a = UTIF2._binBE.ui8;
          UTIF2._binBE.i32[0] = n;
          buff[p + 0] = a[0];
          buff[p + 1] = a[1];
          buff[p + 2] = a[2];
          buff[p + 3] = a[3];
        },
        writeUint: function(buff, p, n) {
          buff[p] = n >>> 0 & 255;
          buff[p + 1] = n >>> 8 & 255;
          buff[p + 2] = n >>> 16 & 255;
          buff[p + 3] = n >>> 24 & 255;
        },
        writeASCII: UTIF2._binBE.writeASCII
      };
      UTIF2._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
        var xlim = Math.min(tw, w - xoff);
        var ylim = Math.min(th, h - yoff);
        for (var y = 0;y < ylim; y++) {
          var tof = (yoff + y) * w + xoff;
          var sof = y * tw;
          for (var x = 0;x < xlim; x++)
            b[tof + x] = tb[sof + x];
        }
      };
      UTIF2.LosslessJpegDecode = function() {
        var b, O;
        function l() {
          return b[O++];
        }
        function m() {
          return b[O++] << 8 | b[O++];
        }
        function a0(h) {
          var V = l(), I = [0, 0, 0, 255], f = [], G = 8;
          for (var w = 0;w < 16; w++)
            f[w] = l();
          for (var w = 0;w < 16; w++) {
            for (var x = 0;x < f[w]; x++) {
              var T = z(I, 0, w + 1, 1);
              I[T + 3] = l();
            }
          }
          var E = new Uint8Array(1 << G);
          h[V] = [new Uint8Array(I), E];
          for (var w = 0;w < 1 << G; w++) {
            var s = G, _ = w, Y = 0, F = 0;
            while (I[Y + 3] == 255 && s != 0) {
              F = _ >> --s & 1;
              Y = I[Y + F];
            }
            E[w] = Y;
          }
        }
        function z(h, V, I, f) {
          if (h[V + 3] != 255)
            return 0;
          if (I == 0)
            return V;
          for (var w = 0;w < 2; w++) {
            if (h[V + w] == 0) {
              h[V + w] = h.length;
              h.push(0, 0, f, 255);
            }
            var x = z(h, h[V + w], I - 1, f + 1);
            if (x != 0)
              return x;
          }
          return 0;
        }
        function i2(h) {
          var { b: V, f: I } = h;
          while (V < 25 && h.a < h.d) {
            var f = h.data[h.a++];
            if (f == 255 && !h.c)
              h.a++;
            I = I << 8 | f;
            V += 8;
          }
          if (V < 0)
            throw "e";
          h.b = V;
          h.f = I;
        }
        function H(h, V) {
          if (V.b < h)
            i2(V);
          return V.f >> (V.b -= h) & 65535 >> 16 - h;
        }
        function g(h, V) {
          var I = h[0], f = 0, w = 255, x = 0;
          if (V.b < 16)
            i2(V);
          var T = V.f >> V.b - 8 & 255;
          f = h[1][T];
          w = I[f + 3];
          V.b -= I[f + 2];
          while (w == 255) {
            x = V.f >> --V.b & 1;
            f = I[f + x];
            w = I[f + 3];
          }
          return w;
        }
        function P(h, V) {
          if (h < 32768 >> 16 - V)
            h += -(1 << V) + 1;
          return h;
        }
        function a2(h, V) {
          var I = g(h, V);
          if (I == 0)
            return 0;
          if (I == 16)
            return -32768;
          var f = H(I, V);
          return P(f, I);
        }
        function X(h, V, I, f, w, x) {
          var T = 0;
          for (var G = 0;G < x; G++) {
            var s = G * V;
            for (var _ = 0;_ < V; _ += w) {
              T++;
              for (var Y = 0;Y < w; Y++)
                h[s + _ + Y] = a2(f[Y], I);
            }
            if (I.e != 0 && T % I.e == 0 && G != 0) {
              var { a: F, data: t } = I;
              while (t[F] != 255 || !(208 <= t[F + 1] && t[F + 1] <= 215))
                F--;
              I.a = F + 2;
              I.f = 0;
              I.b = 0;
            }
          }
        }
        function o(h, V) {
          return P(H(h, V), h);
        }
        function a1(h, V, I, f, w) {
          var x = b.length - O;
          for (var T = 0;T < x; T += 4) {
            var G = b[O + T];
            b[O + T] = b[O + T + 3];
            b[O + T + 3] = G;
            var G = b[O + T + 1];
            b[O + T + 1] = b[O + T + 2];
            b[O + T + 2] = G;
          }
          for (var E = 0;E < w; E++) {
            var s = 32768, _ = 32768;
            for (var Y = 0;Y < V; Y += 2) {
              var F = g(f, I), t = g(f, I);
              if (F != 0)
                s += o(F, I);
              if (t != 0)
                _ += o(t, I);
              h[E * V + Y] = s & 65535;
              h[E * V + Y + 1] = _ & 65535;
            }
          }
        }
        function C(h) {
          b = h;
          O = 0;
          if (m() != 65496)
            throw "e";
          var V = [], I = 0, f = 0, w = 0, x = [], T = [], G = [], E = 0, s = 0, _ = 0;
          while (true) {
            var Y = m();
            if (Y == 65535) {
              O--;
              continue;
            }
            var F = m();
            if (Y == 65475) {
              f = l();
              s = m();
              _ = m();
              E = l();
              for (var t = 0;t < E; t++) {
                var a = l(), J = l(), r = l();
                if (r != 0)
                  throw "e";
                V[a] = [t, J >> 4, J & 15];
              }
            } else if (Y == 65476) {
              var a3 = O + F - 2;
              while (O < a3)
                a0(T);
            } else if (Y == 65498) {
              O++;
              for (var t = 0;t < E; t++) {
                var a5 = l(), v = V[a5];
                G[v[0]] = T[l() >>> 4];
                x[v[0]] = v.slice(1);
              }
              I = l();
              O += 2;
              break;
            } else if (Y == 65501) {
              w = m();
            } else {
              O += F - 2;
            }
          }
          var a4 = f > 8 ? Uint16Array : Uint8Array, $2 = new a4(s * _ * E), M = { b: 0, f: 0, c: I == 8, a: O, data: b, d: b.length, e: w };
          if (M.c)
            a1($2, _ * E, M, G[0], s);
          else {
            var c2 = [], p = 0, D = 0;
            for (var t = 0;t < E; t++) {
              var N = x[t], S = N[0], K = N[1];
              if (S > p)
                p = S;
              if (K > D)
                D = K;
              c2.push(S * K);
            }
            if (p != 1 || D != 1) {
              if (E != 3 || c2[1] != 1 || c2[2] != 1)
                throw "e";
              if (p != 2 || D != 1 && D != 2)
                throw "e";
              var u = [], Z = 0;
              for (var t = 0;t < E; t++) {
                for (var R = 0;R < c2[t]; R++)
                  u.push(G[t]);
                Z += c2[t];
              }
              var B = _ / p, e = s / D, d = B * e;
              X($2, B * Z, M, u, Z, e);
              j($2, I, B, e, Z - 2, Z, Z, f);
              var A = new Uint16Array(d * c2[0]);
              if (p == 2 && D == 2) {
                for (var t = 0;t < d; t++) {
                  A[4 * t] = $2[6 * t];
                  A[4 * t + 1] = $2[6 * t + 1];
                  A[4 * t + 2] = $2[6 * t + 2];
                  A[4 * t + 3] = $2[6 * t + 3];
                }
                j(A, I, B * 4, e, 0, 1, 1, f);
                for (var t = 0;t < d; t++) {
                  $2[6 * t] = A[4 * t];
                  $2[6 * t + 1] = A[4 * t + 1];
                  $2[6 * t + 2] = A[4 * t + 2];
                  $2[6 * t + 3] = A[4 * t + 3];
                }
              }
              if (p == 2 && D == 1) {
                for (var t = 0;t < d; t++) {
                  A[2 * t] = $2[4 * t];
                  A[2 * t + 1] = $2[4 * t + 1];
                }
                j(A, I, B * 2, e, 0, 1, 1, f);
                for (var t = 0;t < d; t++) {
                  $2[4 * t] = A[2 * t];
                  $2[4 * t + 1] = A[2 * t + 1];
                }
              }
              var n = $2.slice(0);
              for (var K = 0;K < s; K++) {
                if (D == 2)
                  for (var S = 0;S < _; S++) {
                    var q = (K * _ + S) * E, k = ((K >>> 1) * B + (S >>> 1)) * Z, y = (K & 1) * 2 + (S & 1);
                    $2[q] = n[k + y];
                    $2[q + 1] = n[k + 4];
                    $2[q + 2] = n[k + 5];
                  }
                else
                  for (var S = 0;S < _; S++) {
                    var q = (K * _ + S) * E, k = (K * B + (S >>> 1)) * Z, y = S & 1;
                    $2[q] = n[k + y];
                    $2[q + 1] = n[k + 2];
                    $2[q + 2] = n[k + 3];
                  }
              }
            } else {
              X($2, _ * E, M, G, E, s);
              if (w == 0)
                j($2, I, _, s, 0, E, E, f);
              else {
                var U = Math.floor(w / _);
                for (var K = 0;K < s; K += U) {
                  var L = $2.slice(K * _ * E, (K + U) * _ * E);
                  j(L, I, _, U, 0, E, E, f);
                  $2.set(L, K * _ * E);
                }
              }
            }
          }
          return $2;
        }
        function j(h, V, I, f, w, x, G, E) {
          var s = I * G;
          for (var _ = w;_ < x; _++)
            h[_] += 1 << E - 1;
          for (var Y = G;Y < s; Y += G)
            for (var _ = w;_ < x; _++)
              h[Y + _] += h[Y + _ - G];
          for (var F = 1;F < f; F++) {
            var t = F * s;
            for (var _ = w;_ < x; _++)
              h[t + _] += h[t + _ - s];
            for (var Y = G;Y < s; Y += G) {
              for (var _ = w;_ < x; _++) {
                var a = t + Y + _, J = a - s, r = h[a - G], Q = 0;
                if (V == 0)
                  Q = 0;
                else if (V == 1)
                  Q = r;
                else if (V == 2)
                  Q = h[J];
                else if (V == 3)
                  Q = h[J - G];
                else if (V == 4)
                  Q = r + (h[J] - h[J - G]);
                else if (V == 5)
                  Q = r + (h[J] - h[J - G] >>> 1);
                else if (V == 6)
                  Q = h[J] + (r - h[J - G] >>> 1);
                else if (V == 7)
                  Q = r + h[J] >>> 1;
                else
                  throw V;
                h[a] += Q;
              }
            }
          }
        }
        return C;
      }();
      (function() {
        var G = 0, F = 1, i2 = 2, b = 3, J = 4, N = 5, E = 6, s = 7, c2 = 8, T = 9, a3 = 10, f = 11, q = 12, M = 13, m = 14, x = 15, L = 16, $2 = 17, p = 18;
        function a5(t) {
          var Z = UTIF2._binBE.readUshort, u = { b: Z(t, 0), i: t[2], C: t[3], u: t[4], q: Z(t, 5), k: Z(t, 7), e: Z(t, 9), l: Z(t, 11), s: t[13], d: Z(t, 14) };
          if (u.b != 18771 || u.i > 1 || u.q < 6 || u.q % 6 || u.e < 768 || u.e % 24 || u.l != 768 || u.k < u.l || u.k % u.l || u.k - u.e >= u.l || u.s > 16 || u.s != u.k / u.l || u.s != Math.ceil(u.e / u.l) || u.d != u.q / 6 || u.u != 12 && u.u != 14 && u.u != 16 || u.C != 16 && u.C != 0) {
            throw "Invalid data";
          }
          if (u.i == 0) {
            throw "Not implemented. We need this file!";
          }
          u.h = u.C == 16;
          u.m = (u.h ? u.l * 2 / 3 : u.l >>> 1) | 0;
          u.A = u.m + 2;
          u.f = 64;
          u.g = (1 << u.u) - 1;
          u.n = 4 * u.u;
          return u;
        }
        function a7(t, Z) {
          var u = new Array(Z.s), e = 4 * Z.s, Q = 16 + e;
          if (e & 12)
            Q += 16 - (e & 12);
          for (var V = 0, O = 16;V < Z.s; O += 4) {
            var o = UTIF2._binBE.readUint(t, O);
            u[V] = t.slice(Q, Q + o);
            u[V].j = 0;
            u[V].a = 0;
            Q += o;
            V++;
          }
          if (Q != t.length)
            throw "Invalid data";
          return u;
        }
        function a6(t, Z) {
          for (var u = -Z[4], e = 0;u <= Z[4]; e++, u++) {
            t[e] = u <= -Z[3] ? -4 : u <= -Z[2] ? -3 : u <= -Z[1] ? -2 : u < -Z[0] ? -1 : u <= Z[0] ? 0 : u < Z[1] ? 1 : u < Z[2] ? 2 : u < Z[3] ? 3 : 4;
          }
        }
        function a1(t, Z, u) {
          var e = [Z, 3 * Z + 18, 5 * Z + 67, 7 * Z + 276, u];
          t.o = Z;
          t.w = (e[4] + 2 * Z) / (2 * Z + 1) + 1 | 0;
          t.v = Math.ceil(Math.log2(t.w));
          t.t = 9;
          a6(t.c, e);
        }
        function a2(t) {
          var Z = { c: new Int8Array(2 << t.u) };
          a1(Z, 0, t.g);
          return Z;
        }
        function D(t) {
          var Z = [[], [], []], u = Math.max(2, t.w + 32 >>> 6);
          for (var e = 0;e < 3; e++) {
            for (var Q = 0;Q < 41; Q++) {
              Z[e][Q] = [u, 1];
            }
          }
          return Z;
        }
        function a4(t) {
          for (var Z = -1, u = 0;!u; Z++) {
            u = t[t.j] >>> 7 - t.a & 1;
            t.a++;
            t.a &= 7;
            if (!t.a)
              t.j++;
          }
          return Z;
        }
        function K(t, Z) {
          var u = 0, e = 8 - t.a, Q = t.j, V = t.a;
          if (Z) {
            if (Z >= e) {
              do {
                u <<= e;
                Z -= e;
                u |= t[t.j] & (1 << e) - 1;
                t.j++;
                e = 8;
              } while (Z >= 8);
            }
            if (Z) {
              u <<= Z;
              e -= Z;
              u |= t[t.j] >>> e & (1 << Z) - 1;
            }
            t.a = 8 - e;
          }
          return u;
        }
        function a0(t, Z) {
          var u = 0;
          if (Z < t) {
            while (u <= 14 && Z << ++u < t)
              ;
          }
          return u;
        }
        function r(t, Z, u, e, Q, V, O, o) {
          if (o == null)
            o = 0;
          var X = V + 1, k = X % 2, j = 0, I = 0, a = 0, l, R, w = e[Q], S = e[Q - 1], H = e[Q - 2][X], g = S[X - 1], Y = S[X], P = S[X + 1], A = w[X - 1], v = w[X + 1], y = Math.abs, d, C, n, h;
          if (k) {
            d = y(P - Y);
            C = y(H - Y);
            n = y(g - Y);
          }
          if (k) {
            h = d > n && C < d ? H + g : d < n && C < n ? H + P : P + g;
            h = h + 2 * Y >>> 2;
            if (o) {
              w[X] = h;
              return;
            }
            l = Z.t * Z.c[t.g + Y - H] + Z.c[t.g + g - Y];
          } else {
            h = Y > g && Y > P || Y < g && Y < P ? v + A + 2 * Y >>> 2 : A + v >>> 1;
            l = Z.t * Z.c[t.g + Y - g] + Z.c[t.g + g - A];
          }
          R = y(l);
          var W = a4(u);
          if (W < t.n - Z.v - 1) {
            var z = a0(O[R][0], O[R][1]);
            a = K(u, z) + (W << z);
          } else {
            a = K(u, Z.v) + 1;
          }
          a = a & 1 ? -1 - (a >>> 1) : a >>> 1;
          O[R][0] += y(a);
          if (O[R][1] == t.f) {
            O[R][0] >>>= 1;
            O[R][1] >>>= 1;
          }
          O[R][1]++;
          h = l < 0 ? h - a : h + a;
          if (t.i) {
            if (h < 0)
              h += Z.w;
            else if (h > t.g)
              h -= Z.w;
          }
          w[X] = h >= 0 ? Math.min(h, t.g) : 0;
        }
        function U(t, Z, u) {
          var e = t[0].length;
          for (var Q = Z;Q <= u; Q++) {
            t[Q][0] = t[Q - 1][1];
            t[Q][e - 1] = t[Q - 1][e - 2];
          }
        }
        function B(t) {
          U(t, s, q);
          U(t, i2, J);
          U(t, x, $2);
        }
        function _(t, Z, u, e, Q, V, O, o, X, k, j, I, a) {
          var l = 0, R = 1, w = Q < M && Q > J;
          while (R < t.m) {
            if (l < t.m) {
              r(t, Z, u, e, Q, l, O[X], t.h && (w && k || !w && (j || (l & I) == a)));
              r(t, Z, u, e, V, l, O[X], t.h && (!w && k || w && (j || (l & I) == a)));
              l += 2;
            }
            if (l > 8) {
              r(t, Z, u, e, Q, R, o[X]);
              r(t, Z, u, e, V, R, o[X]);
              R += 2;
            }
          }
          B(e);
        }
        function a8(t, Z, u, e, Q, V) {
          _(t, Z, u, e, i2, s, Q, V, 0, 0, 1, 0, 8);
          _(t, Z, u, e, c2, x, Q, V, 1, 0, 1, 0, 8);
          _(t, Z, u, e, b, T, Q, V, 2, 1, 0, 3, 0);
          _(t, Z, u, e, a3, L, Q, V, 0, 0, 0, 3, 2);
          _(t, Z, u, e, J, f, Q, V, 1, 0, 0, 3, 2);
          _(t, Z, u, e, q, $2, Q, V, 2, 1, 0, 3, 0);
        }
        function a9(t, Z, u, e, Q, V) {
          var O = V.length, o = t.l;
          if (Q + 1 == t.s)
            o = t.e - Q * t.l;
          var X = 6 * t.e * e + Q * t.l;
          for (var k = 0;k < 6; k++) {
            for (var j = 0;j < o; j++) {
              var I = V[k % O][j % O], a;
              if (I == 0) {
                a = i2 + (k >>> 1);
              } else if (I == 2) {
                a = x + (k >>> 1);
              } else {
                a = s + k;
              }
              var l = t.h ? (j * 2 / 3 & 2147483646 | j % 3 & 1) + (j % 3 >>> 1) : j >>> 1;
              Z[X + j] = u[a][l + 1];
            }
            X += t.e;
          }
        }
        UTIF2._decompressRAF = function(t, Z) {
          var u = a5(t), e = a7(t, u), Q = a2(u), V = new Int16Array(u.e * u.q);
          if (Z == null) {
            Z = u.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]];
          }
          var O = [[G, b], [F, J], [N, f], [E, q], [M, L], [m, $2]], o = [];
          for (var X = 0;X < p; X++) {
            o[X] = new Uint16Array(u.A);
          }
          for (var k = 0;k < u.s; k++) {
            var j = D(Q), I = D(Q);
            for (var X = 0;X < p; X++) {
              for (var a = 0;a < u.A; a++) {
                o[X][a] = 0;
              }
            }
            for (var l = 0;l < u.d; l++) {
              a8(u, Q, e[k], o, j, I);
              for (var X = 0;X < 6; X++) {
                for (var a = 0;a < u.A; a++) {
                  o[O[X][0]][a] = o[O[X][1]][a];
                }
              }
              a9(u, V, o, l, k, Z);
              for (var X = i2;X < p; X++) {
                if ([N, E, M, m].indexOf(X) == -1) {
                  for (var a = 0;a < u.A; a++) {
                    o[X][a] = 0;
                  }
                }
              }
              B(o);
            }
          }
          return V;
        };
      })();
    })(UTIF, pako);
  })();
});

// node_modules/omggif/omggif.js
var require_omggif = __commonJS((exports) => {
  var GifWriter = function(buf, width, height, gopts) {
    var p = 0;
    var gopts = gopts === undefined ? {} : gopts;
    var loop_count = gopts.loop === undefined ? null : gopts.loop;
    var global_palette = gopts.palette === undefined ? null : gopts.palette;
    if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
      throw new Error("Width/Height invalid.");
    function check_palette_and_num_colors(palette2) {
      var num_colors = palette2.length;
      if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
        throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
      }
      return num_colors;
    }
    buf[p++] = 71;
    buf[p++] = 73;
    buf[p++] = 70;
    buf[p++] = 56;
    buf[p++] = 57;
    buf[p++] = 97;
    var gp_num_colors_pow2 = 0;
    var background = 0;
    if (global_palette !== null) {
      var gp_num_colors = check_palette_and_num_colors(global_palette);
      while (gp_num_colors >>= 1)
        ++gp_num_colors_pow2;
      gp_num_colors = 1 << gp_num_colors_pow2;
      --gp_num_colors_pow2;
      if (gopts.background !== undefined) {
        background = gopts.background;
        if (background >= gp_num_colors)
          throw new Error("Background index out of range.");
        if (background === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    buf[p++] = width & 255;
    buf[p++] = width >> 8 & 255;
    buf[p++] = height & 255;
    buf[p++] = height >> 8 & 255;
    buf[p++] = (global_palette !== null ? 128 : 0) | gp_num_colors_pow2;
    buf[p++] = background;
    buf[p++] = 0;
    if (global_palette !== null) {
      for (var i2 = 0, il = global_palette.length;i2 < il; ++i2) {
        var rgb = global_palette[i2];
        buf[p++] = rgb >> 16 & 255;
        buf[p++] = rgb >> 8 & 255;
        buf[p++] = rgb & 255;
      }
    }
    if (loop_count !== null) {
      if (loop_count < 0 || loop_count > 65535)
        throw new Error("Loop count invalid.");
      buf[p++] = 33;
      buf[p++] = 255;
      buf[p++] = 11;
      buf[p++] = 78;
      buf[p++] = 69;
      buf[p++] = 84;
      buf[p++] = 83;
      buf[p++] = 67;
      buf[p++] = 65;
      buf[p++] = 80;
      buf[p++] = 69;
      buf[p++] = 50;
      buf[p++] = 46;
      buf[p++] = 48;
      buf[p++] = 3;
      buf[p++] = 1;
      buf[p++] = loop_count & 255;
      buf[p++] = loop_count >> 8 & 255;
      buf[p++] = 0;
    }
    var ended = false;
    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
      if (ended === true) {
        --p;
        ended = false;
      }
      opts = opts === undefined ? {} : opts;
      if (x < 0 || y < 0 || x > 65535 || y > 65535)
        throw new Error("x/y invalid.");
      if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
        throw new Error("Width/Height invalid.");
      if (indexed_pixels.length < w * h)
        throw new Error("Not enough pixels for the frame size.");
      var using_local_palette = true;
      var palette2 = opts.palette;
      if (palette2 === undefined || palette2 === null) {
        using_local_palette = false;
        palette2 = global_palette;
      }
      if (palette2 === undefined || palette2 === null)
        throw new Error("Must supply either a local or global palette.");
      var num_colors = check_palette_and_num_colors(palette2);
      var min_code_size = 0;
      while (num_colors >>= 1)
        ++min_code_size;
      num_colors = 1 << min_code_size;
      var delay = opts.delay === undefined ? 0 : opts.delay;
      var disposal = opts.disposal === undefined ? 0 : opts.disposal;
      if (disposal < 0 || disposal > 3)
        throw new Error("Disposal out of range.");
      var use_transparency = false;
      var transparent_index = 0;
      if (opts.transparent !== undefined && opts.transparent !== null) {
        use_transparency = true;
        transparent_index = opts.transparent;
        if (transparent_index < 0 || transparent_index >= num_colors)
          throw new Error("Transparent color index.");
      }
      if (disposal !== 0 || use_transparency || delay !== 0) {
        buf[p++] = 33;
        buf[p++] = 249;
        buf[p++] = 4;
        buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
        buf[p++] = delay & 255;
        buf[p++] = delay >> 8 & 255;
        buf[p++] = transparent_index;
        buf[p++] = 0;
      }
      buf[p++] = 44;
      buf[p++] = x & 255;
      buf[p++] = x >> 8 & 255;
      buf[p++] = y & 255;
      buf[p++] = y >> 8 & 255;
      buf[p++] = w & 255;
      buf[p++] = w >> 8 & 255;
      buf[p++] = h & 255;
      buf[p++] = h >> 8 & 255;
      buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
      if (using_local_palette === true) {
        for (var i3 = 0, il2 = palette2.length;i3 < il2; ++i3) {
          var rgb2 = palette2[i3];
          buf[p++] = rgb2 >> 16 & 255;
          buf[p++] = rgb2 >> 8 & 255;
          buf[p++] = rgb2 & 255;
        }
      }
      p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
      return p;
    };
    this.end = function() {
      if (ended === false) {
        buf[p++] = 59;
        ended = true;
      }
      return p;
    };
    this.getOutputBuffer = function() {
      return buf;
    };
    this.setOutputBuffer = function(v) {
      buf = v;
    };
    this.getOutputBufferPosition = function() {
      return p;
    };
    this.setOutputBufferPosition = function(v) {
      p = v;
    };
  };
  var GifWriterOutputLZWCodeStream = function(buf, p, min_code_size, index_stream) {
    buf[p++] = min_code_size;
    var cur_subblock = p++;
    var clear_code = 1 << min_code_size;
    var code_mask = clear_code - 1;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var cur_shift = 0;
    var cur = 0;
    function emit_bytes_to_buffer(bit_block_size) {
      while (cur_shift >= bit_block_size) {
        buf[p++] = cur & 255;
        cur >>= 8;
        cur_shift -= 8;
        if (p === cur_subblock + 256) {
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }
    }
    function emit_code(c2) {
      cur |= c2 << cur_shift;
      cur_shift += cur_code_size;
      emit_bytes_to_buffer(8);
    }
    var ib_code = index_stream[0] & code_mask;
    var code_table = {};
    emit_code(clear_code);
    for (var i2 = 1, il = index_stream.length;i2 < il; ++i2) {
      var k = index_stream[i2] & code_mask;
      var cur_key = ib_code << 8 | k;
      var cur_code = code_table[cur_key];
      if (cur_code === undefined) {
        cur |= ib_code << cur_shift;
        cur_shift += cur_code_size;
        while (cur_shift >= 8) {
          buf[p++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
        if (next_code === 4096) {
          emit_code(clear_code);
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_table = {};
        } else {
          if (next_code >= 1 << cur_code_size)
            ++cur_code_size;
          code_table[cur_key] = next_code++;
        }
        ib_code = k;
      } else {
        ib_code = cur_code;
      }
    }
    emit_code(ib_code);
    emit_code(eoi_code);
    emit_bytes_to_buffer(1);
    if (cur_subblock + 1 === p) {
      buf[cur_subblock] = 0;
    } else {
      buf[cur_subblock] = p - cur_subblock - 1;
      buf[p++] = 0;
    }
    return p;
  };
  var GifReader = function(buf) {
    var p = 0;
    if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
      throw new Error("Invalid GIF 87a/89a header.");
    }
    var width = buf[p++] | buf[p++] << 8;
    var height = buf[p++] | buf[p++] << 8;
    var pf0 = buf[p++];
    var global_palette_flag = pf0 >> 7;
    var num_global_colors_pow2 = pf0 & 7;
    var num_global_colors = 1 << num_global_colors_pow2 + 1;
    var background = buf[p++];
    buf[p++];
    var global_palette_offset = null;
    var global_palette_size = null;
    if (global_palette_flag) {
      global_palette_offset = p;
      global_palette_size = num_global_colors;
      p += num_global_colors * 3;
    }
    var no_eof = true;
    var frames = [];
    var delay = 0;
    var transparent_index = null;
    var disposal = 0;
    var loop_count = null;
    this.width = width;
    this.height = height;
    while (no_eof && p < buf.length) {
      switch (buf[p++]) {
        case 33:
          switch (buf[p++]) {
            case 255:
              if (buf[p] !== 11 || buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                p += 14;
                loop_count = buf[p++] | buf[p++] << 8;
                p++;
              } else {
                p += 12;
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p += block_size;
                }
              }
              break;
            case 249:
              if (buf[p++] !== 4 || buf[p + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var pf1 = buf[p++];
              delay = buf[p++] | buf[p++] << 8;
              transparent_index = buf[p++];
              if ((pf1 & 1) === 0)
                transparent_index = null;
              disposal = pf1 >> 2 & 7;
              p++;
              break;
            case 254:
              while (true) {
                var block_size = buf[p++];
                if (!(block_size >= 0))
                  throw Error("Invalid block size");
                if (block_size === 0)
                  break;
                p += block_size;
              }
              break;
            default:
              throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
          }
          break;
        case 44:
          var x = buf[p++] | buf[p++] << 8;
          var y = buf[p++] | buf[p++] << 8;
          var w = buf[p++] | buf[p++] << 8;
          var h = buf[p++] | buf[p++] << 8;
          var pf2 = buf[p++];
          var local_palette_flag = pf2 >> 7;
          var interlace_flag = pf2 >> 6 & 1;
          var num_local_colors_pow2 = pf2 & 7;
          var num_local_colors = 1 << num_local_colors_pow2 + 1;
          var palette_offset = global_palette_offset;
          var palette_size = global_palette_size;
          var has_local_palette = false;
          if (local_palette_flag) {
            var has_local_palette = true;
            palette_offset = p;
            palette_size = num_local_colors;
            p += num_local_colors * 3;
          }
          var data_offset = p;
          p++;
          while (true) {
            var block_size = buf[p++];
            if (!(block_size >= 0))
              throw Error("Invalid block size");
            if (block_size === 0)
              break;
            p += block_size;
          }
          frames.push({
            x,
            y,
            width: w,
            height: h,
            has_local_palette,
            palette_offset,
            palette_size,
            data_offset,
            data_length: p - data_offset,
            transparent_index,
            interlaced: !!interlace_flag,
            delay,
            disposal
          });
          break;
        case 59:
          no_eof = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
          break;
      }
    }
    this.numFrames = function() {
      return frames.length;
    };
    this.loopCount = function() {
      return loop_count;
    };
    this.frameInfo = function(frame_num) {
      if (frame_num < 0 || frame_num >= frames.length)
        throw new Error("Frame index out of range.");
      return frames[frame_num];
    };
    this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i2 = 0, il = index_stream.length;i2 < il; ++i2) {
        var index = index_stream[i2];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = b;
          pixels[op++] = g;
          pixels[op++] = r;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
    this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i2 = 0, il = index_stream.length;i2 < il; ++i2) {
        var index = index_stream[i2];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = r;
          pixels[op++] = g;
          pixels[op++] = b;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
  };
  var GifReaderLZWOutputIndexStream = function(code_stream, p, output, output_length) {
    var min_code_size = code_stream[p++];
    var clear_code = 1 << min_code_size;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var code_mask = (1 << cur_code_size) - 1;
    var cur_shift = 0;
    var cur = 0;
    var op = 0;
    var subblock_size = code_stream[p++];
    var code_table = new Int32Array(4096);
    var prev_code = null;
    while (true) {
      while (cur_shift < 16) {
        if (subblock_size === 0)
          break;
        cur |= code_stream[p++] << cur_shift;
        cur_shift += 8;
        if (subblock_size === 1) {
          subblock_size = code_stream[p++];
        } else {
          --subblock_size;
        }
      }
      if (cur_shift < cur_code_size)
        break;
      var code = cur & code_mask;
      cur >>= cur_code_size;
      cur_shift -= cur_code_size;
      if (code === clear_code) {
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_mask = (1 << cur_code_size) - 1;
        prev_code = null;
        continue;
      } else if (code === eoi_code) {
        break;
      }
      var chase_code = code < next_code ? code : prev_code;
      var chase_length = 0;
      var chase = chase_code;
      while (chase > clear_code) {
        chase = code_table[chase] >> 8;
        ++chase_length;
      }
      var k = chase;
      var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
      if (op_end > output_length) {
        console.log("Warning, gif stream longer than expected.");
        return;
      }
      output[op++] = k;
      op += chase_length;
      var b = op;
      if (chase_code !== code)
        output[op++] = k;
      chase = chase_code;
      while (chase_length--) {
        chase = code_table[chase];
        output[--b] = chase & 255;
        chase >>= 8;
      }
      if (prev_code !== null && next_code < 4096) {
        code_table[next_code++] = prev_code << 8 | k;
        if (next_code >= code_mask + 1 && cur_code_size < 12) {
          ++cur_code_size;
          code_mask = code_mask << 1 | 1;
        }
      }
      prev_code = code;
    }
    if (op !== output_length) {
      console.log("Warning, gif stream shorter than expected.");
    }
    return output;
  };
  try {
    exports.GifWriter = GifWriter;
    exports.GifReader = GifReader;
  } catch (e) {
  }
});

// node_modules/gifwrap/src/bitmapimage.js
var require_bitmapimage = __commonJS((exports, module) => {
  class BitmapImage {
    constructor(...args) {
      if (args.length === 0) {
        throw new Error("constructor requires parameters");
      }
      const firstArg = args[0];
      if (firstArg !== null && typeof firstArg === "object") {
        if (firstArg instanceof BitmapImage) {
          const sourceBitmap = firstArg.bitmap;
          this.bitmap = {
            width: sourceBitmap.width,
            height: sourceBitmap.height,
            data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
          };
          sourceBitmap.data.copy(this.bitmap.data);
        } else if (firstArg.width && firstArg.height && firstArg.data) {
          this.bitmap = firstArg;
        } else {
          throw new Error("unrecognized constructor parameters");
        }
      } else if (typeof firstArg === "number" && typeof args[1] === "number") {
        const width = firstArg;
        const height = args[1];
        const thirdArg = args[2];
        this.bitmap = { width, height };
        if (Buffer.isBuffer(thirdArg)) {
          this.bitmap.data = thirdArg;
        } else {
          this.bitmap.data = new Buffer(width * height * 4);
          if (typeof thirdArg === "number") {
            this.fillRGBA(thirdArg);
          }
        }
      } else {
        throw new Error("unrecognized constructor parameters");
      }
    }
    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
      if (fromX + fromWidth > this.bitmap.width) {
        throw new Error("copy exceeds width of source bitmap");
      }
      if (toX + fromWidth > toImage.bitmap.width) {
        throw new Error("copy exceeds width of target bitmap");
      }
      if (fromY + fromHeight > this.bitmap.height) {
        throw new Error("copy exceeds height of source bitmap");
      }
      if (toY + fromHeight > toImage.bitmap.height) {
        throw new Erro("copy exceeds height of target bitmap");
      }
      const sourceBuf = this.bitmap.data;
      const targetBuf = toImage.bitmap.data;
      const sourceByteWidth = this.bitmap.width * 4;
      const targetByteWidth = toImage.bitmap.width * 4;
      const copyByteWidth = fromWidth * 4;
      let si = fromY * sourceByteWidth + fromX * 4;
      let ti = toY * targetByteWidth + toX * 4;
      while (--fromHeight >= 0) {
        sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
        si += sourceByteWidth;
        ti += targetByteWidth;
      }
      return this;
    }
    fillRGBA(rgba) {
      const buf = this.bitmap.data;
      const bufByteWidth = this.bitmap.height * 4;
      let bi = 0;
      while (bi < bufByteWidth) {
        buf.writeUInt32BE(rgba, bi);
        bi += 4;
      }
      while (bi < buf.length) {
        buf.copy(buf, bi, 0, bufByteWidth);
        bi += bufByteWidth;
      }
      return this;
    }
    getRGBA(x, y) {
      const bi = (y * this.bitmap.width + x) * 4;
      return this.bitmap.data.readUInt32BE(bi);
    }
    getRGBASet() {
      const rgbaSet = new Set;
      const buf = this.bitmap.data;
      for (let bi = 0;bi < buf.length; bi += 4) {
        rgbaSet.add(buf.readUInt32BE(bi, true));
      }
      return rgbaSet;
    }
    greyscale() {
      const buf = this.bitmap.data;
      this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
        const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
        buf[idx] = grey;
        buf[idx + 1] = grey;
        buf[idx + 2] = grey;
      });
      return this;
    }
    reframe(xOffset, yOffset, width, height, fillRGBA) {
      const cropX = xOffset < 0 ? 0 : xOffset;
      const cropY = yOffset < 0 ? 0 : yOffset;
      const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
      const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
      const newX = xOffset < 0 ? -xOffset : 0;
      const newY = yOffset < 0 ? -yOffset : 0;
      let image2;
      if (fillRGBA === undefined) {
        if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
          throw new GifError(`fillRGBA required for this reframing`);
        }
        image2 = new BitmapImage(width, height);
      } else {
        image2 = new BitmapImage(width, height, fillRGBA);
      }
      this.blit(image2, newX, newY, cropX, cropY, cropWidth, cropHeight);
      this.bitmap = image2.bitmap;
      return this;
    }
    scale(factor) {
      if (factor === 1) {
        return;
      }
      if (!Number.isInteger(factor) || factor < 1) {
        throw new Error("the scale must be an integer >= 1");
      }
      const sourceWidth = this.bitmap.width;
      const sourceHeight = this.bitmap.height;
      const destByteWidth = sourceWidth * factor * 4;
      const sourceBuf = this.bitmap.data;
      const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
      let sourceIndex = 0;
      let priorDestRowIndex;
      let destIndex = 0;
      for (let y = 0;y < sourceHeight; ++y) {
        priorDestRowIndex = destIndex;
        for (let x = 0;x < sourceWidth; ++x) {
          const color = sourceBuf.readUInt32BE(sourceIndex, true);
          for (let cx = 0;cx < factor; ++cx) {
            destBuf.writeUInt32BE(color, destIndex);
            destIndex += 4;
          }
          sourceIndex += 4;
        }
        for (let cy = 1;cy < factor; ++cy) {
          destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
          destIndex += destByteWidth;
          priorDestRowIndex += destByteWidth;
        }
      }
      this.bitmap = {
        width: sourceWidth * factor,
        height: sourceHeight * factor,
        data: destBuf
      };
      return this;
    }
    scanAllCoords(scanHandler) {
      const width = this.bitmap.width;
      const bufferLength = this.bitmap.data.length;
      let x = 0;
      let y = 0;
      for (let bi = 0;bi < bufferLength; bi += 4) {
        scanHandler(x, y, bi);
        if (++x === width) {
          x = 0;
          ++y;
        }
      }
    }
    scanAllIndexes(scanHandler) {
      const bufferLength = this.bitmap.data.length;
      for (let bi = 0;bi < bufferLength; bi += 4) {
        scanHandler(bi);
      }
    }
  }
  module.exports = BitmapImage;
});

// node_modules/gifwrap/src/gif.js
var require_gif = __commonJS((exports) => {
  class Gif {
    constructor(buffer, frames, spec) {
      this.width = spec.width;
      this.height = spec.height;
      this.loops = spec.loops;
      this.usesTransparency = spec.usesTransparency;
      this.colorScope = spec.colorScope;
      this.frames = frames;
      this.buffer = buffer;
    }
  }
  Gif.GlobalColorsPreferred = 0;
  Gif.GlobalColorsOnly = 1;
  Gif.LocalColorsOnly = 2;

  class GifError2 extends Error {
    constructor(messageOrError) {
      super(messageOrError);
      if (messageOrError instanceof Error) {
        this.stack = "Gif" + messageOrError.stack;
      }
    }
  }
  exports.Gif = Gif;
  exports.GifError = GifError2;
});

// node_modules/image-q/dist/cjs/image-q.cjs
var require_image_q = __commonJS((exports, module) => {
  var correctGamma = function(n) {
    return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
  };
  var rgb2xyz = function(r, g, b) {
    r = correctGamma(r / 255);
    g = correctGamma(g / 255);
    b = correctGamma(b / 255);
    return {
      x: r * 0.4124 + g * 0.3576 + b * 0.1805,
      y: r * 0.2126 + g * 0.7152 + b * 0.0722,
      z: r * 0.0193 + g * 0.1192 + b * 0.9505
    };
  };
  var degrees2radians = function(n) {
    return n * (Math.PI / 180);
  };
  var max3 = function(a, b, c2) {
    let m = a;
    if (m < b)
      m = b;
    if (m < c2)
      m = c2;
    return m;
  };
  var min3 = function(a, b, c2) {
    let m = a;
    if (m > b)
      m = b;
    if (m > c2)
      m = c2;
    return m;
  };
  var intInRange = function(value2, low, high) {
    if (value2 > high)
      value2 = high;
    if (value2 < low)
      value2 = low;
    return value2 | 0;
  };
  var inRange0to255Rounded = function(n) {
    n = Math.round(n);
    if (n > 255)
      n = 255;
    else if (n < 0)
      n = 0;
    return n;
  };
  var inRange0to255 = function(n) {
    if (n > 255)
      n = 255;
    else if (n < 0)
      n = 0;
    return n;
  };
  var stableSort = function(arrayToSort, callback) {
    const type = typeof arrayToSort[0];
    let sorted;
    if (type === "number" || type === "string") {
      const ord = Object.create(null);
      for (let i2 = 0, l = arrayToSort.length;i2 < l; i2++) {
        const val = arrayToSort[i2];
        if (ord[val] || ord[val] === 0)
          continue;
        ord[val] = i2;
      }
      sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);
    } else {
      const ord2 = arrayToSort.slice(0);
      sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));
    }
    return sorted;
  };
  var rgb2hsl = function(r, g, b) {
    const min = min3(r, g, b);
    const max = max3(r, g, b);
    const delta = max - min;
    const l = (min + max) / 510;
    let s = 0;
    if (l > 0 && l < 1)
      s = delta / (l < 0.5 ? max + min : 510 - max - min);
    let h = 0;
    if (delta > 0) {
      if (max === r) {
        h = (g - b) / delta;
      } else if (max === g) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h *= 60;
      if (h < 0)
        h += 360;
    }
    return { h, s, l };
  };
  var pivot = function(n) {
    return n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
  };
  var xyz2lab = function(x2, y2, z) {
    x2 = pivot(x2 / refX);
    y2 = pivot(y2 / refY);
    z = pivot(z / refZ);
    if (116 * y2 - 16 < 0)
      throw new Error("xxx");
    return {
      L: Math.max(0, 116 * y2 - 16),
      a: 500 * (x2 - y2),
      b: 200 * (y2 - z)
    };
  };
  var rgb2lab = function(r, g, b) {
    const xyz = rgb2xyz(r, g, b);
    return xyz2lab(xyz.x, xyz.y, xyz.z);
  };
  var pivot2 = function(n) {
    return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
  };
  var lab2xyz = function(L, a, b) {
    const y2 = (L + 16) / 116;
    const x2 = a / 500 + y2;
    const z = y2 - b / 200;
    return {
      x: refX2 * pivot2(x2),
      y: refY2 * pivot2(y2),
      z: refZ2 * pivot2(z)
    };
  };
  var correctGamma2 = function(n) {
    return n > 0.0031308 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
  };
  var xyz2rgb = function(x2, y2, z) {
    const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
    const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
    const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
    return {
      r: inRange0to255Rounded(r * 255),
      g: inRange0to255Rounded(g * 255),
      b: inRange0to255Rounded(b * 255)
    };
  };
  var lab2rgb = function(L, a, b) {
    const xyz = lab2xyz(L, a, b);
    return xyz2rgb(xyz.x, xyz.y, xyz.z);
  };
  var hueGroup = function(hue, segmentsNumber) {
    const maxHue = 360;
    const seg = maxHue / segmentsNumber;
    const half = seg / 2;
    for (let i2 = 1, mid = seg - half;i2 < segmentsNumber; i2++, mid += seg) {
      if (hue >= mid && hue < mid + seg)
        return i2;
    }
    return 0;
  };
  var createArray1D = function(dimension1) {
    const a = [];
    for (let k = 0;k < dimension1; k++) {
      a[k] = 0;
    }
    return a;
  };
  var createArray4D = function(dimension1, dimension2, dimension3, dimension4) {
    const a = new Array(dimension1);
    for (let i2 = 0;i2 < dimension1; i2++) {
      a[i2] = new Array(dimension2);
      for (let j = 0;j < dimension2; j++) {
        a[i2][j] = new Array(dimension3);
        for (let k = 0;k < dimension3; k++) {
          a[i2][j][k] = new Array(dimension4);
          for (let l = 0;l < dimension4; l++) {
            a[i2][j][k][l] = 0;
          }
        }
      }
    }
    return a;
  };
  var createArray3D = function(dimension1, dimension2, dimension3) {
    const a = new Array(dimension1);
    for (let i2 = 0;i2 < dimension1; i2++) {
      a[i2] = new Array(dimension2);
      for (let j = 0;j < dimension2; j++) {
        a[i2][j] = new Array(dimension3);
        for (let k = 0;k < dimension3; k++) {
          a[i2][j][k] = 0;
        }
      }
    }
    return a;
  };
  var fillArray3D = function(a, dimension1, dimension2, dimension3, value2) {
    for (let i2 = 0;i2 < dimension1; i2++) {
      a[i2] = [];
      for (let j = 0;j < dimension2; j++) {
        a[i2][j] = [];
        for (let k = 0;k < dimension3; k++) {
          a[i2][j][k] = value2;
        }
      }
    }
  };
  var fillArray1D = function(a, dimension1, value2) {
    for (let i2 = 0;i2 < dimension1; i2++) {
      a[i2] = value2;
    }
  };
  function* hilbertCurve(width, height, callback) {
    const maxBound = Math.max(width, height);
    const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
    const tracker = new ProgressTracker(width * height, 99);
    const data2 = {
      width,
      height,
      level,
      callback,
      tracker,
      index: 0,
      x: 0,
      y: 0
    };
    yield* walkHilbert(data2, 1);
    visit(data2, 0);
  }
  function* walkHilbert(data2, direction) {
    if (data2.level < 1)
      return;
    if (data2.tracker.shouldNotify(data2.index)) {
      yield { progress: data2.tracker.progress };
    }
    data2.level--;
    switch (direction) {
      case 2:
        yield* walkHilbert(data2, 1);
        visit(data2, 3);
        yield* walkHilbert(data2, 2);
        visit(data2, 4);
        yield* walkHilbert(data2, 2);
        visit(data2, 2);
        yield* walkHilbert(data2, 4);
        break;
      case 3:
        yield* walkHilbert(data2, 4);
        visit(data2, 2);
        yield* walkHilbert(data2, 3);
        visit(data2, 1);
        yield* walkHilbert(data2, 3);
        visit(data2, 3);
        yield* walkHilbert(data2, 1);
        break;
      case 1:
        yield* walkHilbert(data2, 2);
        visit(data2, 4);
        yield* walkHilbert(data2, 1);
        visit(data2, 3);
        yield* walkHilbert(data2, 1);
        visit(data2, 1);
        yield* walkHilbert(data2, 3);
        break;
      case 4:
        yield* walkHilbert(data2, 3);
        visit(data2, 1);
        yield* walkHilbert(data2, 4);
        visit(data2, 2);
        yield* walkHilbert(data2, 4);
        visit(data2, 4);
        yield* walkHilbert(data2, 2);
        break;
      default:
        break;
    }
    data2.level++;
  }
  var visit = function(data2, direction) {
    if (data2.x >= 0 && data2.x < data2.width && data2.y >= 0 && data2.y < data2.height) {
      data2.callback(data2.x, data2.y);
      data2.index++;
    }
    switch (direction) {
      case 2:
        data2.x--;
        break;
      case 3:
        data2.x++;
        break;
      case 1:
        data2.y--;
        break;
      case 4:
        data2.y++;
        break;
    }
  };
  var ssim = function(image1, image2) {
    if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
      throw new Error("Images have different sizes!");
    }
    const bitsPerComponent = 8;
    const L = (1 << bitsPerComponent) - 1;
    const c1 = (K1 * L) ** 2;
    const c2 = (K2 * L) ** 2;
    let numWindows = 0;
    let mssim = 0;
    iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
      let sigxy = 0;
      let sigsqx = 0;
      let sigsqy = 0;
      for (let i2 = 0;i2 < lumaValues1.length; i2++) {
        sigsqx += (lumaValues1[i2] - averageLumaValue1) ** 2;
        sigsqy += (lumaValues2[i2] - averageLumaValue2) ** 2;
        sigxy += (lumaValues1[i2] - averageLumaValue1) * (lumaValues2[i2] - averageLumaValue2);
      }
      const numPixelsInWin = lumaValues1.length - 1;
      sigsqx /= numPixelsInWin;
      sigsqy /= numPixelsInWin;
      sigxy /= numPixelsInWin;
      const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
      const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);
      const ssim2 = numerator / denominator;
      mssim += ssim2;
      numWindows++;
    });
    return mssim / numWindows;
  };
  var iterate = function(image1, image2, callback) {
    const windowSize = 8;
    const width = image1.getWidth();
    const height = image1.getHeight();
    for (let y2 = 0;y2 < height; y2 += windowSize) {
      for (let x2 = 0;x2 < width; x2 += windowSize) {
        const windowWidth = Math.min(windowSize, width - x2);
        const windowHeight = Math.min(windowSize, height - y2);
        const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
        const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
        const averageLuma1 = calculateAverageLuma(lumaValues1);
        const averageLuma2 = calculateAverageLuma(lumaValues2);
        callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
      }
    }
  };
  var calculateLumaValuesForWindow = function(image2, x2, y2, width, height) {
    const pointArray = image2.getPointArray();
    const lumaValues = [];
    let counter = 0;
    for (let j = y2;j < y2 + height; j++) {
      const offset = j * image2.getWidth();
      for (let i2 = x2;i2 < x2 + width; i2++) {
        const point = pointArray[offset + i2];
        lumaValues[counter] = point.r * 0.2126 + point.g * 0.7152 + point.b * 0.0722;
        counter++;
      }
    }
    return lumaValues;
  };
  var calculateAverageLuma = function(lumaValues) {
    let sumLuma = 0;
    for (const luma of lumaValues) {
      sumLuma += luma;
    }
    return sumLuma / lumaValues.length;
  };
  var buildPaletteSync = function(images, {
    colorDistanceFormula,
    paletteQuantization,
    colors
  } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
    images.forEach((image2) => paletteQuantizer.sample(image2));
    return paletteQuantizer.quantizeSync();
  };
  async function buildPalette(images, {
    colorDistanceFormula,
    paletteQuantization,
    colors,
    onProgress
  } = {}) {
    return new Promise((resolve2, reject2) => {
      const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
      const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
      images.forEach((image2) => paletteQuantizer.sample(image2));
      let palette2;
      const iterator = paletteQuantizer.quantize();
      const next = () => {
        try {
          const result = iterator.next();
          if (result.done) {
            resolve2(palette2);
          } else {
            if (result.value.palette)
              palette2 = result.value.palette;
            if (onProgress)
              onProgress(result.value.progress);
            setImmediateImpl(next);
          }
        } catch (error) {
          reject2(error);
        }
      };
      setImmediateImpl(next);
    });
  }
  var applyPaletteSync = function(image2, palette2, { colorDistanceFormula, imageQuantization } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
    return imageQuantizer.quantizeSync(image2, palette2);
  };
  async function applyPalette(image2, palette2, {
    colorDistanceFormula,
    imageQuantization,
    onProgress
  } = {}) {
    return new Promise((resolve2, reject2) => {
      const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
      const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
      let outPointContainer;
      const iterator = imageQuantizer.quantize(image2, palette2);
      const next = () => {
        try {
          const result = iterator.next();
          if (result.done) {
            resolve2(outPointContainer);
          } else {
            if (result.value.pointContainer) {
              outPointContainer = result.value.pointContainer;
            }
            if (onProgress)
              onProgress(result.value.progress);
            setImmediateImpl(next);
          }
        } catch (error) {
          reject2(error);
        }
      };
      setImmediateImpl(next);
    });
  }
  var colorDistanceFormulaToColorDistance = function(colorDistanceFormula = "euclidean-bt709") {
    switch (colorDistanceFormula) {
      case "cie94-graphic-arts":
        return new CIE94GraphicArts;
      case "cie94-textiles":
        return new CIE94Textiles;
      case "ciede2000":
        return new CIEDE2000;
      case "color-metric":
        return new CMetric;
      case "euclidean":
        return new Euclidean;
      case "euclidean-bt709":
        return new EuclideanBT709;
      case "euclidean-bt709-noalpha":
        return new EuclideanBT709NoAlpha;
      case "manhattan":
        return new Manhattan;
      case "manhattan-bt709":
        return new ManhattanBT709;
      case "manhattan-nommyde":
        return new ManhattanNommyde;
      case "pngquant":
        return new PNGQuant;
      default:
        throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
    }
  };
  var imageQuantizationToImageQuantizer = function(distanceCalculator, imageQuantization = "floyd-steinberg") {
    switch (imageQuantization) {
      case "nearest":
        return new NearestColor(distanceCalculator);
      case "riemersma":
        return new ErrorDiffusionRiemersma(distanceCalculator);
      case "floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 0);
      case "false-floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 1);
      case "stucki":
        return new ErrorDiffusionArray(distanceCalculator, 2);
      case "atkinson":
        return new ErrorDiffusionArray(distanceCalculator, 3);
      case "jarvis":
        return new ErrorDiffusionArray(distanceCalculator, 4);
      case "burkes":
        return new ErrorDiffusionArray(distanceCalculator, 5);
      case "sierra":
        return new ErrorDiffusionArray(distanceCalculator, 6);
      case "two-sierra":
        return new ErrorDiffusionArray(distanceCalculator, 7);
      case "sierra-lite":
        return new ErrorDiffusionArray(distanceCalculator, 8);
      default:
        throw new Error(`Unknown imageQuantization ${imageQuantization}`);
    }
  };
  var paletteQuantizationToPaletteQuantizer = function(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
    switch (paletteQuantization) {
      case "neuquant":
        return new NeuQuant(distanceCalculator, colors);
      case "rgbquant":
        return new RGBQuant(distanceCalculator, colors);
      case "wuquant":
        return new WuQuant(distanceCalculator, colors);
      case "neuquant-float":
        return new NeuQuantFloat(distanceCalculator, colors);
      default:
        throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
    }
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value2) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
  var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
  var __export2 = (target, all) => {
    for (var name2 in all)
      __defProp2(target, name2, { get: all[name2], enumerable: true });
  };
  var __reExport = (target, module2, copyDefault, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames2(module2))
        if (!__hasOwnProp2.call(target, key) && (copyDefault || key !== "default"))
          __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
    }
    return target;
  };
  var __toCommonJS = ((cache) => {
    return (module2, temp) => {
      return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? new WeakMap : 0);
  var __publicField = (obj, key, value2) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
    return value2;
  };
  var src_exports = {};
  __export2(src_exports, {
    applyPalette: () => applyPalette,
    applyPaletteSync: () => applyPaletteSync,
    buildPalette: () => buildPalette,
    buildPaletteSync: () => buildPaletteSync,
    constants: () => constants_exports,
    conversion: () => conversion_exports,
    distance: () => distance_exports,
    image: () => image_exports,
    palette: () => palette_exports,
    quality: () => quality_exports,
    utils: () => utils_exports
  });
  var constants_exports = {};
  __export2(constants_exports, {
    bt709: () => bt709_exports
  });
  var bt709_exports = {};
  __export2(bt709_exports, {
    Y: () => Y,
    x: () => x,
    y: () => y
  });
  var Y = ((Y2) => {
    Y2[Y2["RED"] = 0.2126] = "RED";
    Y2[Y2["GREEN"] = 0.7152] = "GREEN";
    Y2[Y2["BLUE"] = 0.0722] = "BLUE";
    Y2[Y2["WHITE"] = 1] = "WHITE";
    return Y2;
  })(Y || {});
  var x = ((x2) => {
    x2[x2["RED"] = 0.64] = "RED";
    x2[x2["GREEN"] = 0.3] = "GREEN";
    x2[x2["BLUE"] = 0.15] = "BLUE";
    x2[x2["WHITE"] = 0.3127] = "WHITE";
    return x2;
  })(x || {});
  var y = ((y2) => {
    y2[y2["RED"] = 0.33] = "RED";
    y2[y2["GREEN"] = 0.6] = "GREEN";
    y2[y2["BLUE"] = 0.06] = "BLUE";
    y2[y2["WHITE"] = 0.329] = "WHITE";
    return y2;
  })(y || {});
  var conversion_exports = {};
  __export2(conversion_exports, {
    lab2rgb: () => lab2rgb,
    lab2xyz: () => lab2xyz,
    rgb2hsl: () => rgb2hsl,
    rgb2lab: () => rgb2lab,
    rgb2xyz: () => rgb2xyz,
    xyz2lab: () => xyz2lab,
    xyz2rgb: () => xyz2rgb
  });
  var arithmetic_exports = {};
  __export2(arithmetic_exports, {
    degrees2radians: () => degrees2radians,
    inRange0to255: () => inRange0to255,
    inRange0to255Rounded: () => inRange0to255Rounded,
    intInRange: () => intInRange,
    max3: () => max3,
    min3: () => min3,
    stableSort: () => stableSort
  });
  var refX = 0.95047;
  var refY = 1;
  var refZ = 1.08883;
  var refX2 = 0.95047;
  var refY2 = 1;
  var refZ2 = 1.08883;
  var distance_exports = {};
  __export2(distance_exports, {
    AbstractDistanceCalculator: () => AbstractDistanceCalculator,
    AbstractEuclidean: () => AbstractEuclidean,
    AbstractManhattan: () => AbstractManhattan,
    CIE94GraphicArts: () => CIE94GraphicArts,
    CIE94Textiles: () => CIE94Textiles,
    CIEDE2000: () => CIEDE2000,
    CMetric: () => CMetric,
    Euclidean: () => Euclidean,
    EuclideanBT709: () => EuclideanBT709,
    EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
    Manhattan: () => Manhattan,
    ManhattanBT709: () => ManhattanBT709,
    ManhattanNommyde: () => ManhattanNommyde,
    PNGQuant: () => PNGQuant
  });
  var AbstractDistanceCalculator = class {
    constructor() {
      __publicField(this, "_maxDistance");
      __publicField(this, "_whitePoint");
      this._setDefaults();
      this.setWhitePoint(255, 255, 255, 255);
    }
    setWhitePoint(r, g, b, a) {
      this._whitePoint = {
        r: r > 0 ? 255 / r : 0,
        g: g > 0 ? 255 / g : 0,
        b: b > 0 ? 255 / b : 0,
        a: a > 0 ? 255 / a : 0
      };
      this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
    }
    calculateNormalized(colorA, colorB) {
      return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
    }
  };
  var AbstractCIE94 = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
      const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
      const dL = lab1.L - lab2.L;
      const dA = lab1.a - lab2.a;
      const dB = lab1.b - lab2.b;
      const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
      const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
      const dC = c1 - c2;
      let deltaH = dA * dA + dB * dB - dC * dC;
      deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
      const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
      return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
    }
  };
  var CIE94Textiles = class extends AbstractCIE94 {
    _setDefaults() {
      this._Kl = 2;
      this._K1 = 0.048;
      this._K2 = 0.014;
      this._kA = 0.25 * 50 / 255;
    }
  };
  var CIE94GraphicArts = class extends AbstractCIE94 {
    _setDefaults() {
      this._Kl = 1;
      this._K1 = 0.045;
      this._K2 = 0.015;
      this._kA = 0.25 * 100 / 255;
    }
  };
  var _CIEDE2000 = class extends AbstractDistanceCalculator {
    _setDefaults() {
    }
    static _calculatehp(b, ap) {
      const hp = Math.atan2(b, ap);
      if (hp >= 0)
        return hp;
      return hp + _CIEDE2000._deg360InRad;
    }
    static _calculateRT(ahp, aCp) {
      const aCp_to_7 = aCp ** 7;
      const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
      const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
      return -Math.sin(2 * delta_theta) * R_C;
    }
    static _calculateT(ahp) {
      return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
    }
    static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
      const hpSum = h1p + h2p;
      if (C1pC2p === 0)
        return hpSum;
      if (h_bar <= _CIEDE2000._deg180InRad)
        return hpSum / 2;
      if (hpSum < _CIEDE2000._deg360InRad) {
        return (hpSum + _CIEDE2000._deg360InRad) / 2;
      }
      return (hpSum - _CIEDE2000._deg360InRad) / 2;
    }
    static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
      let dhp;
      if (C1pC2p === 0) {
        dhp = 0;
      } else if (h_bar <= _CIEDE2000._deg180InRad) {
        dhp = h2p - h1p;
      } else if (h2p <= h1p) {
        dhp = h2p - h1p + _CIEDE2000._deg360InRad;
      } else {
        dhp = h2p - h1p - _CIEDE2000._deg360InRad;
      }
      return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
    }
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
      const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
      const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
      const dE2 = this.calculateRawInLab(lab1, lab2);
      return Math.sqrt(dE2 + dA * dA);
    }
    calculateRawInLab(Lab1, Lab2) {
      const L1 = Lab1.L;
      const a1 = Lab1.a;
      const b1 = Lab1.b;
      const L2 = Lab2.L;
      const a2 = Lab2.a;
      const b2 = Lab2.b;
      const C1 = Math.sqrt(a1 * a1 + b1 * b1);
      const C2 = Math.sqrt(a2 * a2 + b2 * b2);
      const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
      const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
      const a1p = (1 + G) * a1;
      const a2p = (1 + G) * a2;
      const C1p = Math.sqrt(a1p * a1p + b1 * b1);
      const C2p = Math.sqrt(a2p * a2p + b2 * b2);
      const C1pC2p = C1p * C2p;
      const h1p = _CIEDE2000._calculatehp(b1, a1p);
      const h2p = _CIEDE2000._calculatehp(b2, a2p);
      const h_bar = Math.abs(h1p - h2p);
      const dLp = L2 - L1;
      const dCp = C2p - C1p;
      const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
      const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
      const T = _CIEDE2000._calculateT(ahp);
      const aCp = (C1p + C2p) / 2;
      const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
      const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
      const S_C = 1 + 0.045 * aCp;
      const S_H = 1 + 0.015 * T * aCp;
      const R_T = _CIEDE2000._calculateRT(ahp, aCp);
      const dLpSL = dLp / S_L;
      const dCpSC = dCp / S_C;
      const dHpSH = dHp / S_H;
      return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
    }
  };
  var CIEDE2000 = _CIEDE2000;
  __publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
  __publicField(CIEDE2000, "_pow25to7", 25 ** 7);
  __publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
  __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
  __publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
  __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
  __publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
  __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
  __publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
  var CMetric = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const rmean = (r1 + r2) / 2 * this._whitePoint.r;
      const r = (r1 - r2) * this._whitePoint.r;
      const g = (g1 - g2) * this._whitePoint.g;
      const b = (b1 - b2) * this._whitePoint.b;
      const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
      const dA = (a2 - a1) * this._whitePoint.a;
      return Math.sqrt(dE + dA * dA);
    }
    _setDefaults() {
    }
  };
  var AbstractEuclidean = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const dR = r2 - r1;
      const dG = g2 - g1;
      const dB = b2 - b1;
      const dA = a2 - a1;
      return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
    }
  };
  var Euclidean = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 1;
      this._kG = 1;
      this._kB = 1;
      this._kA = 1;
    }
  };
  var EuclideanBT709 = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 0.2126;
      this._kG = 0.7152;
      this._kB = 0.0722;
      this._kA = 1;
    }
  };
  var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 0.2126;
      this._kG = 0.7152;
      this._kB = 0.0722;
      this._kA = 0;
    }
  };
  var AbstractManhattan = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      let dR = r2 - r1;
      let dG = g2 - g1;
      let dB = b2 - b1;
      let dA = a2 - a1;
      if (dR < 0)
        dR = 0 - dR;
      if (dG < 0)
        dG = 0 - dG;
      if (dB < 0)
        dB = 0 - dB;
      if (dA < 0)
        dA = 0 - dA;
      return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
    }
  };
  var Manhattan = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 1;
      this._kG = 1;
      this._kB = 1;
      this._kA = 1;
    }
  };
  var ManhattanNommyde = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 0.4984;
      this._kG = 0.8625;
      this._kB = 0.2979;
      this._kA = 1;
    }
  };
  var ManhattanBT709 = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 0.2126;
      this._kG = 0.7152;
      this._kB = 0.0722;
      this._kA = 1;
    }
  };
  var PNGQuant = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const alphas = (a2 - a1) * this._whitePoint.a;
      return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
    }
    _colordifferenceCh(x2, y2, alphas) {
      const black = x2 - y2;
      const white = black + alphas;
      return black * black + white * white;
    }
    _setDefaults() {
    }
  };
  var palette_exports = {};
  __export2(palette_exports, {
    AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
    ColorHistogram: () => ColorHistogram,
    NeuQuant: () => NeuQuant,
    NeuQuantFloat: () => NeuQuantFloat,
    RGBQuant: () => RGBQuant,
    WuColorCube: () => WuColorCube,
    WuQuant: () => WuQuant
  });
  var AbstractPaletteQuantizer = class {
    quantizeSync() {
      for (const value2 of this.quantize()) {
        if (value2.palette) {
          return value2.palette;
        }
      }
      throw new Error("unreachable");
    }
  };
  var Point = class {
    constructor() {
      __publicField(this, "r");
      __publicField(this, "g");
      __publicField(this, "b");
      __publicField(this, "a");
      __publicField(this, "uint32");
      __publicField(this, "rgba");
      this.uint32 = -1 >>> 0;
      this.r = this.g = this.b = this.a = 0;
      this.rgba = new Array(4);
      this.rgba[0] = 0;
      this.rgba[1] = 0;
      this.rgba[2] = 0;
      this.rgba[3] = 0;
    }
    static createByQuadruplet(quadruplet) {
      const point = new Point;
      point.r = quadruplet[0] | 0;
      point.g = quadruplet[1] | 0;
      point.b = quadruplet[2] | 0;
      point.a = quadruplet[3] | 0;
      point._loadUINT32();
      point._loadQuadruplet();
      return point;
    }
    static createByRGBA(red, green, blue, alpha) {
      const point = new Point;
      point.r = red | 0;
      point.g = green | 0;
      point.b = blue | 0;
      point.a = alpha | 0;
      point._loadUINT32();
      point._loadQuadruplet();
      return point;
    }
    static createByUint32(uint32) {
      const point = new Point;
      point.uint32 = uint32 >>> 0;
      point._loadRGBA();
      point._loadQuadruplet();
      return point;
    }
    from(point) {
      this.r = point.r;
      this.g = point.g;
      this.b = point.b;
      this.a = point.a;
      this.uint32 = point.uint32;
      this.rgba[0] = point.r;
      this.rgba[1] = point.g;
      this.rgba[2] = point.b;
      this.rgba[3] = point.a;
    }
    getLuminosity(useAlphaChannel) {
      let r = this.r;
      let g = this.g;
      let b = this.b;
      if (useAlphaChannel) {
        r = Math.min(255, 255 - this.a + this.a * r / 255);
        g = Math.min(255, 255 - this.a + this.a * g / 255);
        b = Math.min(255, 255 - this.a + this.a * b / 255);
      }
      return r * 0.2126 + g * 0.7152 + b * 0.0722;
    }
    _loadUINT32() {
      this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
    }
    _loadRGBA() {
      this.r = this.uint32 & 255;
      this.g = this.uint32 >>> 8 & 255;
      this.b = this.uint32 >>> 16 & 255;
      this.a = this.uint32 >>> 24 & 255;
    }
    _loadQuadruplet() {
      this.rgba[0] = this.r;
      this.rgba[1] = this.g;
      this.rgba[2] = this.b;
      this.rgba[3] = this.a;
    }
  };
  var PointContainer = class {
    constructor() {
      __publicField(this, "_pointArray");
      __publicField(this, "_width");
      __publicField(this, "_height");
      this._width = 0;
      this._height = 0;
      this._pointArray = [];
    }
    getWidth() {
      return this._width;
    }
    getHeight() {
      return this._height;
    }
    setWidth(width) {
      this._width = width;
    }
    setHeight(height) {
      this._height = height;
    }
    getPointArray() {
      return this._pointArray;
    }
    clone() {
      const clone2 = new PointContainer;
      clone2._width = this._width;
      clone2._height = this._height;
      for (let i2 = 0, l = this._pointArray.length;i2 < l; i2++) {
        clone2._pointArray[i2] = Point.createByUint32(this._pointArray[i2].uint32 | 0);
      }
      return clone2;
    }
    toUint32Array() {
      const l = this._pointArray.length;
      const uint32Array = new Uint32Array(l);
      for (let i2 = 0;i2 < l; i2++) {
        uint32Array[i2] = this._pointArray[i2].uint32;
      }
      return uint32Array;
    }
    toUint8Array() {
      return new Uint8Array(this.toUint32Array().buffer);
    }
    static fromHTMLImageElement(img) {
      const width = img.naturalWidth;
      const height = img.naturalHeight;
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
      return PointContainer.fromHTMLCanvasElement(canvas);
    }
    static fromHTMLCanvasElement(canvas) {
      const width = canvas.width;
      const height = canvas.height;
      const ctx = canvas.getContext("2d");
      const imgData = ctx.getImageData(0, 0, width, height);
      return PointContainer.fromImageData(imgData);
    }
    static fromImageData(imageData) {
      const width = imageData.width;
      const height = imageData.height;
      return PointContainer.fromUint8Array(imageData.data, width, height);
    }
    static fromUint8Array(uint8Array, width, height) {
      switch (Object.prototype.toString.call(uint8Array)) {
        case "[object Uint8ClampedArray]":
        case "[object Uint8Array]":
          break;
        default:
          uint8Array = new Uint8Array(uint8Array);
      }
      const uint32Array = new Uint32Array(uint8Array.buffer);
      return PointContainer.fromUint32Array(uint32Array, width, height);
    }
    static fromUint32Array(uint32Array, width, height) {
      const container = new PointContainer;
      container._width = width;
      container._height = height;
      for (let i2 = 0, l = uint32Array.length;i2 < l; i2++) {
        container._pointArray[i2] = Point.createByUint32(uint32Array[i2] | 0);
      }
      return container;
    }
    static fromBuffer(buffer, width, height) {
      const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
      return PointContainer.fromUint32Array(uint32Array, width, height);
    }
  };
  var hueGroups = 10;
  var Palette = class {
    constructor() {
      __publicField(this, "_pointContainer");
      __publicField(this, "_pointArray", []);
      __publicField(this, "_i32idx", {});
      this._pointContainer = new PointContainer;
      this._pointContainer.setHeight(1);
      this._pointArray = this._pointContainer.getPointArray();
    }
    add(color) {
      this._pointArray.push(color);
      this._pointContainer.setWidth(this._pointArray.length);
    }
    has(color) {
      for (let i2 = this._pointArray.length - 1;i2 >= 0; i2--) {
        if (color.uint32 === this._pointArray[i2].uint32)
          return true;
      }
      return false;
    }
    getNearestColor(colorDistanceCalculator, color) {
      return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
    }
    getPointContainer() {
      return this._pointContainer;
    }
    _nearestPointFromCache(key) {
      return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
    }
    _getNearestIndex(colorDistanceCalculator, point) {
      let idx = this._nearestPointFromCache("" + point.uint32);
      if (idx >= 0)
        return idx;
      let minimalDistance = Number.MAX_VALUE;
      idx = 0;
      for (let i2 = 0, l = this._pointArray.length;i2 < l; i2++) {
        const p = this._pointArray[i2];
        const distance2 = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
        if (distance2 < minimalDistance) {
          minimalDistance = distance2;
          idx = i2;
        }
      }
      this._i32idx[point.uint32] = idx;
      return idx;
    }
    sort() {
      this._i32idx = {};
      this._pointArray.sort((a, b) => {
        const hslA = rgb2hsl(a.r, a.g, a.b);
        const hslB = rgb2hsl(b.r, b.g, b.b);
        const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
        const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
        const hueDiff = hueB - hueA;
        if (hueDiff)
          return -hueDiff;
        const lA = a.getLuminosity(true);
        const lB = b.getLuminosity(true);
        if (lB - lA !== 0)
          return lB - lA;
        const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
        if (satDiff)
          return -satDiff;
        return 0;
      });
    }
  };
  var utils_exports = {};
  __export2(utils_exports, {
    HueStatistics: () => HueStatistics,
    Palette: () => Palette,
    Point: () => Point,
    PointContainer: () => PointContainer,
    ProgressTracker: () => ProgressTracker,
    arithmetic: () => arithmetic_exports
  });
  var HueGroup = class {
    constructor() {
      __publicField(this, "num", 0);
      __publicField(this, "cols", []);
    }
  };
  var HueStatistics = class {
    constructor(numGroups, minCols) {
      __publicField(this, "_numGroups");
      __publicField(this, "_minCols");
      __publicField(this, "_stats");
      __publicField(this, "_groupsFull");
      this._numGroups = numGroups;
      this._minCols = minCols;
      this._stats = [];
      for (let i2 = 0;i2 <= numGroups; i2++) {
        this._stats[i2] = new HueGroup;
      }
      this._groupsFull = 0;
    }
    check(i32) {
      if (this._groupsFull === this._numGroups + 1) {
        this.check = () => {
        };
      }
      const r = i32 & 255;
      const g = i32 >>> 8 & 255;
      const b = i32 >>> 16 & 255;
      const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
      const gr = this._stats[hg];
      const min = this._minCols;
      gr.num++;
      if (gr.num > min) {
        return;
      }
      if (gr.num === min) {
        this._groupsFull++;
      }
      if (gr.num <= min) {
        this._stats[hg].cols.push(i32);
      }
    }
    injectIntoDictionary(histG) {
      for (let i2 = 0;i2 <= this._numGroups; i2++) {
        if (this._stats[i2].num <= this._minCols) {
          this._stats[i2].cols.forEach((col) => {
            if (!histG[col]) {
              histG[col] = 1;
            } else {
              histG[col]++;
            }
          });
        }
      }
    }
    injectIntoArray(histG) {
      for (let i2 = 0;i2 <= this._numGroups; i2++) {
        if (this._stats[i2].num <= this._minCols) {
          this._stats[i2].cols.forEach((col) => {
            if (histG.indexOf(col) === -1) {
              histG.push(col);
            }
          });
        }
      }
    }
  };
  var _ProgressTracker = class {
    constructor(valueRange, progressRange) {
      __publicField(this, "progress");
      __publicField(this, "_step");
      __publicField(this, "_range");
      __publicField(this, "_last");
      __publicField(this, "_progressRange");
      this._range = valueRange;
      this._progressRange = progressRange;
      this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
      this._last = -this._step;
      this.progress = 0;
    }
    shouldNotify(current) {
      if (current - this._last >= this._step) {
        this._last = current;
        this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
        return true;
      }
      return false;
    }
  };
  var ProgressTracker = _ProgressTracker;
  __publicField(ProgressTracker, "steps", 100);
  var networkBiasShift = 3;
  var Neuron = class {
    constructor(defaultValue) {
      __publicField(this, "r");
      __publicField(this, "g");
      __publicField(this, "b");
      __publicField(this, "a");
      this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
      return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
    }
    subtract(r, g, b, a) {
      this.r -= r | 0;
      this.g -= g | 0;
      this.b -= b | 0;
      this.a -= a | 0;
    }
  };
  var _NeuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
      super();
      __publicField(this, "_pointArray");
      __publicField(this, "_networkSize");
      __publicField(this, "_network");
      __publicField(this, "_sampleFactor");
      __publicField(this, "_radPower");
      __publicField(this, "_freq");
      __publicField(this, "_bias");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._pointArray = [];
      this._sampleFactor = 1;
      this._networkSize = colors;
      this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
    }
    sample(pointContainer) {
      this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    *quantize() {
      this._init();
      yield* this._learn();
      yield {
        palette: this._buildPalette(),
        progress: 100
      };
    }
    _init() {
      this._freq = [];
      this._bias = [];
      this._radPower = [];
      this._network = [];
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        this._network[i2] = new Neuron((i2 << networkBiasShift + 8) / this._networkSize | 0);
        this._freq[i2] = _NeuQuant._initialBias / this._networkSize | 0;
        this._bias[i2] = 0;
      }
    }
    *_learn() {
      let sampleFactor = this._sampleFactor;
      const pointsNumber = this._pointArray.length;
      if (pointsNumber < _NeuQuant._minpicturebytes)
        sampleFactor = 1;
      const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
      const pointsToSample = pointsNumber / sampleFactor | 0;
      let delta = pointsToSample / _NeuQuant._nCycles | 0;
      let alpha = _NeuQuant._initAlpha;
      let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
      let rad = radius >> _NeuQuant._radiusBiasShift;
      if (rad <= 1)
        rad = 0;
      for (let i2 = 0;i2 < rad; i2++) {
        this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuant._radBias / (rad * rad)) >>> 0;
      }
      let step;
      if (pointsNumber < _NeuQuant._minpicturebytes) {
        step = 1;
      } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
        step = _NeuQuant._prime1;
      } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
        step = _NeuQuant._prime2;
      } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
        step = _NeuQuant._prime3;
      } else {
        step = _NeuQuant._prime4;
      }
      const tracker = new ProgressTracker(pointsToSample, 99);
      for (let i2 = 0, pointIndex = 0;i2 < pointsToSample; ) {
        if (tracker.shouldNotify(i2)) {
          yield {
            progress: tracker.progress
          };
        }
        const point = this._pointArray[pointIndex];
        const b = point.b << networkBiasShift;
        const g = point.g << networkBiasShift;
        const r = point.r << networkBiasShift;
        const a = point.a << networkBiasShift;
        const neuronIndex = this._contest(b, g, r, a);
        this._alterSingle(alpha, neuronIndex, b, g, r, a);
        if (rad !== 0)
          this._alterNeighbour(rad, neuronIndex, b, g, r, a);
        pointIndex += step;
        if (pointIndex >= pointsNumber)
          pointIndex -= pointsNumber;
        i2++;
        if (delta === 0)
          delta = 1;
        if (i2 % delta === 0) {
          alpha -= alpha / alphadec | 0;
          radius -= radius / _NeuQuant._radiusDecrease | 0;
          rad = radius >> _NeuQuant._radiusBiasShift;
          if (rad <= 1)
            rad = 0;
          for (let j = 0;j < rad; j++) {
            this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
          }
        }
      }
    }
    _buildPalette() {
      const palette2 = new Palette;
      this._network.forEach((neuron) => {
        palette2.add(neuron.toPoint());
      });
      palette2.sort();
      return palette2;
    }
    _alterNeighbour(rad, i2, b, g, r, al) {
      let lo = i2 - rad;
      if (lo < -1)
        lo = -1;
      let hi = i2 + rad;
      if (hi > this._networkSize)
        hi = this._networkSize;
      let j = i2 + 1;
      let k = i2 - 1;
      let m = 1;
      while (j < hi || k > lo) {
        const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
        if (j < hi) {
          const p = this._network[j++];
          p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
        }
        if (k > lo) {
          const p = this._network[k--];
          p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
        }
      }
    }
    _alterSingle(alpha, i2, b, g, r, a) {
      alpha /= _NeuQuant._initAlpha;
      const n = this._network[i2];
      n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    _contest(b, g, r, a) {
      const multiplier = 255 * 4 << networkBiasShift;
      let bestd = ~(1 << 31);
      let bestbiasd = bestd;
      let bestpos = -1;
      let bestbiaspos = bestpos;
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        const n = this._network[i2];
        const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
        if (dist < bestd) {
          bestd = dist;
          bestpos = i2;
        }
        const biasdist = dist - (this._bias[i2] >> _NeuQuant._initialBiasShift - networkBiasShift);
        if (biasdist < bestbiasd) {
          bestbiasd = biasdist;
          bestbiaspos = i2;
        }
        const betafreq = this._freq[i2] >> _NeuQuant._betaShift;
        this._freq[i2] -= betafreq;
        this._bias[i2] += betafreq << _NeuQuant._gammaShift;
      }
      this._freq[bestpos] += _NeuQuant._beta;
      this._bias[bestpos] -= _NeuQuant._betaGamma;
      return bestbiaspos;
    }
  };
  var NeuQuant = _NeuQuant;
  __publicField(NeuQuant, "_prime1", 499);
  __publicField(NeuQuant, "_prime2", 491);
  __publicField(NeuQuant, "_prime3", 487);
  __publicField(NeuQuant, "_prime4", 503);
  __publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
  __publicField(NeuQuant, "_nCycles", 100);
  __publicField(NeuQuant, "_initialBiasShift", 16);
  __publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
  __publicField(NeuQuant, "_gammaShift", 10);
  __publicField(NeuQuant, "_betaShift", 10);
  __publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
  __publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
  __publicField(NeuQuant, "_radiusBiasShift", 6);
  __publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
  __publicField(NeuQuant, "_radiusDecrease", 30);
  __publicField(NeuQuant, "_alphaBiasShift", 10);
  __publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
  __publicField(NeuQuant, "_radBiasShift", 8);
  __publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
  __publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
  __publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
  var networkBiasShift2 = 3;
  var NeuronFloat = class {
    constructor(defaultValue) {
      __publicField(this, "r");
      __publicField(this, "g");
      __publicField(this, "b");
      __publicField(this, "a");
      this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
      return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
    }
    subtract(r, g, b, a) {
      this.r -= r;
      this.g -= g;
      this.b -= b;
      this.a -= a;
    }
  };
  var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
      super();
      __publicField(this, "_pointArray");
      __publicField(this, "_networkSize");
      __publicField(this, "_network");
      __publicField(this, "_sampleFactor");
      __publicField(this, "_radPower");
      __publicField(this, "_freq");
      __publicField(this, "_bias");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._pointArray = [];
      this._sampleFactor = 1;
      this._networkSize = colors;
      this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
    }
    sample(pointContainer) {
      this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    *quantize() {
      this._init();
      yield* this._learn();
      yield {
        palette: this._buildPalette(),
        progress: 100
      };
    }
    _init() {
      this._freq = [];
      this._bias = [];
      this._radPower = [];
      this._network = [];
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        this._network[i2] = new NeuronFloat((i2 << networkBiasShift2 + 8) / this._networkSize);
        this._freq[i2] = _NeuQuantFloat._initialBias / this._networkSize;
        this._bias[i2] = 0;
      }
    }
    *_learn() {
      let sampleFactor = this._sampleFactor;
      const pointsNumber = this._pointArray.length;
      if (pointsNumber < _NeuQuantFloat._minpicturebytes)
        sampleFactor = 1;
      const alphadec = 30 + (sampleFactor - 1) / 3;
      const pointsToSample = pointsNumber / sampleFactor;
      let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
      let alpha = _NeuQuantFloat._initAlpha;
      let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
      let rad = radius >> _NeuQuantFloat._radiusBiasShift;
      if (rad <= 1)
        rad = 0;
      for (let i2 = 0;i2 < rad; i2++) {
        this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuantFloat._radBias / (rad * rad));
      }
      let step;
      if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
        step = 1;
      } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
        step = _NeuQuantFloat._prime1;
      } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
        step = _NeuQuantFloat._prime2;
      } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
        step = _NeuQuantFloat._prime3;
      } else {
        step = _NeuQuantFloat._prime4;
      }
      const tracker = new ProgressTracker(pointsToSample, 99);
      for (let i2 = 0, pointIndex = 0;i2 < pointsToSample; ) {
        if (tracker.shouldNotify(i2)) {
          yield {
            progress: tracker.progress
          };
        }
        const point = this._pointArray[pointIndex];
        const b = point.b << networkBiasShift2;
        const g = point.g << networkBiasShift2;
        const r = point.r << networkBiasShift2;
        const a = point.a << networkBiasShift2;
        const neuronIndex = this._contest(b, g, r, a);
        this._alterSingle(alpha, neuronIndex, b, g, r, a);
        if (rad !== 0)
          this._alterNeighbour(rad, neuronIndex, b, g, r, a);
        pointIndex += step;
        if (pointIndex >= pointsNumber)
          pointIndex -= pointsNumber;
        i2++;
        if (delta === 0)
          delta = 1;
        if (i2 % delta === 0) {
          alpha -= alpha / alphadec;
          radius -= radius / _NeuQuantFloat._radiusDecrease;
          rad = radius >> _NeuQuantFloat._radiusBiasShift;
          if (rad <= 1)
            rad = 0;
          for (let j = 0;j < rad; j++) {
            this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
          }
        }
      }
    }
    _buildPalette() {
      const palette2 = new Palette;
      this._network.forEach((neuron) => {
        palette2.add(neuron.toPoint());
      });
      palette2.sort();
      return palette2;
    }
    _alterNeighbour(rad, i2, b, g, r, al) {
      let lo = i2 - rad;
      if (lo < -1)
        lo = -1;
      let hi = i2 + rad;
      if (hi > this._networkSize)
        hi = this._networkSize;
      let j = i2 + 1;
      let k = i2 - 1;
      let m = 1;
      while (j < hi || k > lo) {
        const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
        if (j < hi) {
          const p = this._network[j++];
          p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
        }
        if (k > lo) {
          const p = this._network[k--];
          p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
        }
      }
    }
    _alterSingle(alpha, i2, b, g, r, a) {
      alpha /= _NeuQuantFloat._initAlpha;
      const n = this._network[i2];
      n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    _contest(b, g, r, al) {
      const multiplier = 255 * 4 << networkBiasShift2;
      let bestd = ~(1 << 31);
      let bestbiasd = bestd;
      let bestpos = -1;
      let bestbiaspos = bestpos;
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        const n = this._network[i2];
        const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
        if (dist < bestd) {
          bestd = dist;
          bestpos = i2;
        }
        const biasdist = dist - (this._bias[i2] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
        if (biasdist < bestbiasd) {
          bestbiasd = biasdist;
          bestbiaspos = i2;
        }
        const betafreq = this._freq[i2] >> _NeuQuantFloat._betaShift;
        this._freq[i2] -= betafreq;
        this._bias[i2] += betafreq << _NeuQuantFloat._gammaShift;
      }
      this._freq[bestpos] += _NeuQuantFloat._beta;
      this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
      return bestbiaspos;
    }
  };
  var NeuQuantFloat = _NeuQuantFloat;
  __publicField(NeuQuantFloat, "_prime1", 499);
  __publicField(NeuQuantFloat, "_prime2", 491);
  __publicField(NeuQuantFloat, "_prime3", 487);
  __publicField(NeuQuantFloat, "_prime4", 503);
  __publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
  __publicField(NeuQuantFloat, "_nCycles", 100);
  __publicField(NeuQuantFloat, "_initialBiasShift", 16);
  __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
  __publicField(NeuQuantFloat, "_gammaShift", 10);
  __publicField(NeuQuantFloat, "_betaShift", 10);
  __publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
  __publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
  __publicField(NeuQuantFloat, "_radiusBiasShift", 6);
  __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
  __publicField(NeuQuantFloat, "_radiusDecrease", 30);
  __publicField(NeuQuantFloat, "_alphaBiasShift", 10);
  __publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
  __publicField(NeuQuantFloat, "_radBiasShift", 8);
  __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
  __publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
  __publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
  var _ColorHistogram = class {
    constructor(method, colors) {
      __publicField(this, "_method");
      __publicField(this, "_hueStats");
      __publicField(this, "_histogram");
      __publicField(this, "_initColors");
      __publicField(this, "_minHueCols");
      this._method = method;
      this._minHueCols = colors << 2;
      this._initColors = colors << 2;
      this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
      this._histogram = Object.create(null);
    }
    sample(pointContainer) {
      switch (this._method) {
        case 1:
          this._colorStats1D(pointContainer);
          break;
        case 2:
          this._colorStats2D(pointContainer);
          break;
      }
    }
    getImportanceSortedColorsIDXI32() {
      const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
      if (sorted.length === 0) {
        return [];
      }
      let idxi32;
      switch (this._method) {
        case 1:
          const initialColorsLimit = Math.min(sorted.length, this._initColors);
          const last = sorted[initialColorsLimit - 1];
          const freq = this._histogram[last];
          idxi32 = sorted.slice(0, initialColorsLimit);
          let pos = initialColorsLimit;
          const len = sorted.length;
          while (pos < len && this._histogram[sorted[pos]] === freq) {
            idxi32.push(sorted[pos++]);
          }
          this._hueStats.injectIntoArray(idxi32);
          break;
        case 2:
          idxi32 = sorted;
          break;
        default:
          throw new Error("Incorrect method");
      }
      return idxi32.map((v) => +v);
    }
    _colorStats1D(pointContainer) {
      const histG = this._histogram;
      const pointArray = pointContainer.getPointArray();
      const len = pointArray.length;
      for (let i2 = 0;i2 < len; i2++) {
        const col = pointArray[i2].uint32;
        this._hueStats.check(col);
        if (col in histG) {
          histG[col]++;
        } else {
          histG[col] = 1;
        }
      }
    }
    _colorStats2D(pointContainer) {
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const pointArray = pointContainer.getPointArray();
      const boxW = _ColorHistogram._boxSize[0];
      const boxH = _ColorHistogram._boxSize[1];
      const area = boxW * boxH;
      const boxes = this._makeBoxes(width, height, boxW, boxH);
      const histG = this._histogram;
      boxes.forEach((box) => {
        let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
        if (effc < 2)
          effc = 2;
        const histL = {};
        this._iterateBox(box, width, (i2) => {
          const col = pointArray[i2].uint32;
          this._hueStats.check(col);
          if (col in histG) {
            histG[col]++;
          } else if (col in histL) {
            if (++histL[col] >= effc) {
              histG[col] = histL[col];
            }
          } else {
            histL[col] = 1;
          }
        });
      });
      this._hueStats.injectIntoDictionary(histG);
    }
    _iterateBox(bbox, wid, fn) {
      const b = bbox;
      const i0 = b.y * wid + b.x;
      const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
      const incr = wid - b.w + 1;
      let cnt = 0;
      let i2 = i0;
      do {
        fn.call(this, i2);
        i2 += ++cnt % b.w === 0 ? incr : 1;
      } while (i2 <= i1);
    }
    _makeBoxes(width, height, stepX, stepY) {
      const wrem = width % stepX;
      const hrem = height % stepY;
      const xend = width - wrem;
      const yend = height - hrem;
      const boxesArray = [];
      for (let y2 = 0;y2 < height; y2 += stepY) {
        for (let x2 = 0;x2 < width; x2 += stepX) {
          boxesArray.push({
            x: x2,
            y: y2,
            w: x2 === xend ? wrem : stepX,
            h: y2 === yend ? hrem : stepY
          });
        }
      }
      return boxesArray;
    }
  };
  var ColorHistogram = _ColorHistogram;
  __publicField(ColorHistogram, "_boxSize", [64, 64]);
  __publicField(ColorHistogram, "_boxPixels", 2);
  __publicField(ColorHistogram, "_hueGroups", 10);
  var RemovedColor = class {
    constructor(index, color, distance2) {
      __publicField(this, "index");
      __publicField(this, "color");
      __publicField(this, "distance");
      this.index = index;
      this.color = color;
      this.distance = distance2;
    }
  };
  var RGBQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, method = 2) {
      super();
      __publicField(this, "_colors");
      __publicField(this, "_initialDistance");
      __publicField(this, "_distanceIncrement");
      __publicField(this, "_histogram");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._colors = colors;
      this._histogram = new ColorHistogram(method, colors);
      this._initialDistance = 0.01;
      this._distanceIncrement = 0.005;
    }
    sample(image2) {
      this._histogram.sample(image2);
    }
    *quantize() {
      const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
      if (idxi32.length === 0) {
        throw new Error("No colors in image");
      }
      yield* this._buildPalette(idxi32);
    }
    *_buildPalette(idxi32) {
      const palette2 = new Palette;
      const colorArray = palette2.getPointContainer().getPointArray();
      const usageArray = new Array(idxi32.length);
      for (let i2 = 0;i2 < idxi32.length; i2++) {
        colorArray.push(Point.createByUint32(idxi32[i2]));
        usageArray[i2] = 1;
      }
      const len = colorArray.length;
      const memDist = [];
      let palLen = len;
      let thold = this._initialDistance;
      const tracker = new ProgressTracker(palLen - this._colors, 99);
      while (palLen > this._colors) {
        memDist.length = 0;
        for (let i2 = 0;i2 < len; i2++) {
          if (tracker.shouldNotify(len - palLen)) {
            yield {
              progress: tracker.progress
            };
          }
          if (usageArray[i2] === 0)
            continue;
          const pxi = colorArray[i2];
          for (let j = i2 + 1;j < len; j++) {
            if (usageArray[j] === 0)
              continue;
            const pxj = colorArray[j];
            const dist = this._distance.calculateNormalized(pxi, pxj);
            if (dist < thold) {
              memDist.push(new RemovedColor(j, pxj, dist));
              usageArray[j] = 0;
              palLen--;
            }
          }
        }
        thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
      }
      if (palLen < this._colors) {
        stableSort(memDist, (a, b) => b.distance - a.distance);
        let k = 0;
        while (palLen < this._colors && k < memDist.length) {
          const removedColor = memDist[k];
          usageArray[removedColor.index] = 1;
          palLen++;
          k++;
        }
      }
      let colors = colorArray.length;
      for (let colorIndex = colors - 1;colorIndex >= 0; colorIndex--) {
        if (usageArray[colorIndex] === 0) {
          if (colorIndex !== colors - 1) {
            colorArray[colorIndex] = colorArray[colors - 1];
          }
          --colors;
        }
      }
      colorArray.length = colors;
      palette2.sort();
      yield {
        palette: palette2,
        progress: 100
      };
    }
  };
  var WuColorCube = class {
    constructor() {
      __publicField(this, "redMinimum");
      __publicField(this, "redMaximum");
      __publicField(this, "greenMinimum");
      __publicField(this, "greenMaximum");
      __publicField(this, "blueMinimum");
      __publicField(this, "blueMaximum");
      __publicField(this, "volume");
      __publicField(this, "alphaMinimum");
      __publicField(this, "alphaMaximum");
    }
  };
  var _WuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
      super();
      __publicField(this, "_reds");
      __publicField(this, "_greens");
      __publicField(this, "_blues");
      __publicField(this, "_alphas");
      __publicField(this, "_sums");
      __publicField(this, "_weights");
      __publicField(this, "_momentsRed");
      __publicField(this, "_momentsGreen");
      __publicField(this, "_momentsBlue");
      __publicField(this, "_momentsAlpha");
      __publicField(this, "_moments");
      __publicField(this, "_table");
      __publicField(this, "_pixels");
      __publicField(this, "_cubes");
      __publicField(this, "_colors");
      __publicField(this, "_significantBitsPerChannel");
      __publicField(this, "_maxSideIndex");
      __publicField(this, "_alphaMaxSideIndex");
      __publicField(this, "_sideSize");
      __publicField(this, "_alphaSideSize");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._setQuality(significantBitsPerChannel);
      this._initialize(colors);
    }
    sample(image2) {
      const pointArray = image2.getPointArray();
      for (let i2 = 0, l = pointArray.length;i2 < l; i2++) {
        this._addColor(pointArray[i2]);
      }
      this._pixels = this._pixels.concat(pointArray);
    }
    *quantize() {
      yield* this._preparePalette();
      const palette2 = new Palette;
      for (let paletteIndex = 0;paletteIndex < this._colors; paletteIndex++) {
        if (this._sums[paletteIndex] > 0) {
          const sum = this._sums[paletteIndex];
          const r = this._reds[paletteIndex] / sum;
          const g = this._greens[paletteIndex] / sum;
          const b = this._blues[paletteIndex] / sum;
          const a = this._alphas[paletteIndex] / sum;
          const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
          palette2.add(color);
        }
      }
      palette2.sort();
      yield {
        palette: palette2,
        progress: 100
      };
    }
    *_preparePalette() {
      yield* this._calculateMoments();
      let next = 0;
      const volumeVariance = createArray1D(this._colors);
      for (let cubeIndex = 1;cubeIndex < this._colors; ++cubeIndex) {
        if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
          volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
          volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
        } else {
          volumeVariance[next] = 0;
          cubeIndex--;
        }
        next = 0;
        let temp = volumeVariance[0];
        for (let index = 1;index <= cubeIndex; ++index) {
          if (volumeVariance[index] > temp) {
            temp = volumeVariance[index];
            next = index;
          }
        }
        if (temp <= 0) {
          this._colors = cubeIndex + 1;
          break;
        }
      }
      const lookupRed = [];
      const lookupGreen = [];
      const lookupBlue = [];
      const lookupAlpha = [];
      for (let k = 0;k < this._colors; ++k) {
        const weight = _WuQuant._volume(this._cubes[k], this._weights);
        if (weight > 0) {
          lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
          lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
          lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
          lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
        } else {
          lookupRed[k] = 0;
          lookupGreen[k] = 0;
          lookupBlue[k] = 0;
          lookupAlpha[k] = 0;
        }
      }
      this._reds = createArray1D(this._colors + 1);
      this._greens = createArray1D(this._colors + 1);
      this._blues = createArray1D(this._colors + 1);
      this._alphas = createArray1D(this._colors + 1);
      this._sums = createArray1D(this._colors + 1);
      for (let index = 0, l = this._pixels.length;index < l; index++) {
        const color = this._pixels[index];
        const match = -1;
        let bestMatch = match;
        let bestDistance = Number.MAX_VALUE;
        for (let lookup = 0;lookup < this._colors; lookup++) {
          const foundRed = lookupRed[lookup];
          const foundGreen = lookupGreen[lookup];
          const foundBlue = lookupBlue[lookup];
          const foundAlpha = lookupAlpha[lookup];
          const distance2 = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
          if (distance2 < bestDistance) {
            bestDistance = distance2;
            bestMatch = lookup;
          }
        }
        this._reds[bestMatch] += color.r;
        this._greens[bestMatch] += color.g;
        this._blues[bestMatch] += color.b;
        this._alphas[bestMatch] += color.a;
        this._sums[bestMatch]++;
      }
    }
    _addColor(color) {
      const bitsToRemove = 8 - this._significantBitsPerChannel;
      const indexRed = (color.r >> bitsToRemove) + 1;
      const indexGreen = (color.g >> bitsToRemove) + 1;
      const indexBlue = (color.b >> bitsToRemove) + 1;
      const indexAlpha = (color.a >> bitsToRemove) + 1;
      this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
      this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
      this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
      this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
      this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
      this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
    }
    *_calculateMoments() {
      const area = [];
      const areaRed = [];
      const areaGreen = [];
      const areaBlue = [];
      const areaAlpha = [];
      const area2 = [];
      const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      let trackerProgress = 0;
      const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
      for (let alphaIndex = 1;alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
        fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
        for (let redIndex = 1;redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
          if (tracker.shouldNotify(trackerProgress)) {
            yield {
              progress: tracker.progress
            };
          }
          fillArray1D(area, this._sideSize, 0);
          fillArray1D(areaRed, this._sideSize, 0);
          fillArray1D(areaGreen, this._sideSize, 0);
          fillArray1D(areaBlue, this._sideSize, 0);
          fillArray1D(areaAlpha, this._sideSize, 0);
          fillArray1D(area2, this._sideSize, 0);
          for (let greenIndex = 1;greenIndex <= this._maxSideIndex; ++greenIndex) {
            let line = 0;
            let lineRed = 0;
            let lineGreen = 0;
            let lineBlue = 0;
            let lineAlpha = 0;
            let line2 = 0;
            for (let blueIndex = 1;blueIndex <= this._maxSideIndex; ++blueIndex) {
              line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
              lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
              lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
              lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
              lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
              line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
              area[blueIndex] += line;
              areaRed[blueIndex] += lineRed;
              areaGreen[blueIndex] += lineGreen;
              areaBlue[blueIndex] += lineBlue;
              areaAlpha[blueIndex] += lineAlpha;
              area2[blueIndex] += line2;
              xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
              xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
              xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
              xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
              xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
              xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
              this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
              this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
              this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
              this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
              this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
              this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
            }
          }
        }
      }
    }
    static _volumeFloat(cube, moment) {
      return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
    }
    static _volume(cube, moment) {
      return _WuQuant._volumeFloat(cube, moment) | 0;
    }
    static _top(cube, direction, position, moment) {
      let result;
      switch (direction) {
        case _WuQuant._alpha:
          result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
          break;
        case _WuQuant._red:
          result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
          break;
        case _WuQuant._green:
          result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
          break;
        case _WuQuant._blue:
          result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
          break;
        default:
          throw new Error("impossible");
      }
      return result | 0;
    }
    static _bottom(cube, direction, moment) {
      switch (direction) {
        case _WuQuant._alpha:
          return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        case _WuQuant._red:
          return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        case _WuQuant._green:
          return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        case _WuQuant._blue:
          return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        default:
          return 0;
      }
    }
    _calculateVariance(cube) {
      const volumeRed = _WuQuant._volume(cube, this._momentsRed);
      const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
      const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
      const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
      const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
      const volumeWeight = _WuQuant._volume(cube, this._weights);
      const distance2 = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
      return volumeMoment - distance2 / volumeWeight;
    }
    _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
      const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
      const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
      const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
      const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
      const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
      let result = 0;
      let cutPosition = -1;
      for (let position = first;position < last; ++position) {
        let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
        let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
        let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
        let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
        let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
        if (halfWeight !== 0) {
          let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
          let temp = halfDistance / halfWeight;
          halfRed = wholeRed - halfRed;
          halfGreen = wholeGreen - halfGreen;
          halfBlue = wholeBlue - halfBlue;
          halfAlpha = wholeAlpha - halfAlpha;
          halfWeight = wholeWeight - halfWeight;
          if (halfWeight !== 0) {
            halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
            temp += halfDistance / halfWeight;
            if (temp > result) {
              result = temp;
              cutPosition = position;
            }
          }
        }
      }
      return { max: result, position: cutPosition };
    }
    _cut(first, second) {
      let direction;
      const wholeRed = _WuQuant._volume(first, this._momentsRed);
      const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
      const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
      const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
      const wholeWeight = _WuQuant._volume(first, this._weights);
      const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
        direction = _WuQuant._alpha;
        if (alpha.position < 0)
          return false;
      } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
        direction = _WuQuant._red;
      } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
        direction = _WuQuant._green;
      } else {
        direction = _WuQuant._blue;
      }
      second.redMaximum = first.redMaximum;
      second.greenMaximum = first.greenMaximum;
      second.blueMaximum = first.blueMaximum;
      second.alphaMaximum = first.alphaMaximum;
      switch (direction) {
        case _WuQuant._red:
          second.redMinimum = first.redMaximum = red.position;
          second.greenMinimum = first.greenMinimum;
          second.blueMinimum = first.blueMinimum;
          second.alphaMinimum = first.alphaMinimum;
          break;
        case _WuQuant._green:
          second.greenMinimum = first.greenMaximum = green.position;
          second.redMinimum = first.redMinimum;
          second.blueMinimum = first.blueMinimum;
          second.alphaMinimum = first.alphaMinimum;
          break;
        case _WuQuant._blue:
          second.blueMinimum = first.blueMaximum = blue.position;
          second.redMinimum = first.redMinimum;
          second.greenMinimum = first.greenMinimum;
          second.alphaMinimum = first.alphaMinimum;
          break;
        case _WuQuant._alpha:
          second.alphaMinimum = first.alphaMaximum = alpha.position;
          second.blueMinimum = first.blueMinimum;
          second.redMinimum = first.redMinimum;
          second.greenMinimum = first.greenMinimum;
          break;
      }
      first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
      second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
      return true;
    }
    _initialize(colors) {
      this._colors = colors;
      this._cubes = [];
      for (let cubeIndex = 0;cubeIndex < colors; cubeIndex++) {
        this._cubes[cubeIndex] = new WuColorCube;
      }
      this._cubes[0].redMinimum = 0;
      this._cubes[0].greenMinimum = 0;
      this._cubes[0].blueMinimum = 0;
      this._cubes[0].alphaMinimum = 0;
      this._cubes[0].redMaximum = this._maxSideIndex;
      this._cubes[0].greenMaximum = this._maxSideIndex;
      this._cubes[0].blueMaximum = this._maxSideIndex;
      this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
      this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._table = [];
      for (let tableIndex = 0;tableIndex < 256; ++tableIndex) {
        this._table[tableIndex] = tableIndex * tableIndex;
      }
      this._pixels = [];
    }
    _setQuality(significantBitsPerChannel = 5) {
      this._significantBitsPerChannel = significantBitsPerChannel;
      this._maxSideIndex = 1 << this._significantBitsPerChannel;
      this._alphaMaxSideIndex = this._maxSideIndex;
      this._sideSize = this._maxSideIndex + 1;
      this._alphaSideSize = this._alphaMaxSideIndex + 1;
    }
  };
  var WuQuant = _WuQuant;
  __publicField(WuQuant, "_alpha", 3);
  __publicField(WuQuant, "_red", 2);
  __publicField(WuQuant, "_green", 1);
  __publicField(WuQuant, "_blue", 0);
  var image_exports = {};
  __export2(image_exports, {
    AbstractImageQuantizer: () => AbstractImageQuantizer,
    ErrorDiffusionArray: () => ErrorDiffusionArray,
    ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
    ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
    NearestColor: () => NearestColor
  });
  var AbstractImageQuantizer = class {
    quantizeSync(pointContainer, palette2) {
      for (const value2 of this.quantize(pointContainer, palette2)) {
        if (value2.pointContainer) {
          return value2.pointContainer;
        }
      }
      throw new Error("unreachable");
    }
  };
  var NearestColor = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator) {
      super();
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
    }
    *quantize(pointContainer, palette2) {
      const pointArray = pointContainer.getPointArray();
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const tracker = new ProgressTracker(height, 99);
      for (let y2 = 0;y2 < height; y2++) {
        if (tracker.shouldNotify(y2)) {
          yield {
            progress: tracker.progress
          };
        }
        for (let x2 = 0, idx = y2 * width;x2 < width; x2++, idx++) {
          const point = pointArray[idx];
          point.from(palette2.getNearestColor(this._distance, point));
        }
      }
      yield {
        pointContainer,
        progress: 100
      };
    }
  };
  var ErrorDiffusionArrayKernel = ((ErrorDiffusionArrayKernel2) => {
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
    return ErrorDiffusionArrayKernel2;
  })(ErrorDiffusionArrayKernel || {});
  var ErrorDiffusionArray = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
      super();
      __publicField(this, "_minColorDistance");
      __publicField(this, "_serpentine");
      __publicField(this, "_kernel");
      __publicField(this, "_calculateErrorLikeGIMP");
      __publicField(this, "_distance");
      this._setKernel(kernel);
      this._distance = colorDistanceCalculator;
      this._minColorDistance = minimumColorDistanceToDither;
      this._serpentine = serpentine;
      this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
    }
    *quantize(pointContainer, palette2) {
      const pointArray = pointContainer.getPointArray();
      const originalPoint = new Point;
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const errorLines = [];
      let dir = 1;
      let maxErrorLines = 1;
      for (const kernel of this._kernel) {
        const kernelErrorLines = kernel[2] + 1;
        if (maxErrorLines < kernelErrorLines)
          maxErrorLines = kernelErrorLines;
      }
      for (let i2 = 0;i2 < maxErrorLines; i2++) {
        this._fillErrorLine(errorLines[i2] = [], width);
      }
      const tracker = new ProgressTracker(height, 99);
      for (let y2 = 0;y2 < height; y2++) {
        if (tracker.shouldNotify(y2)) {
          yield {
            progress: tracker.progress
          };
        }
        if (this._serpentine)
          dir *= -1;
        const lni = y2 * width;
        const xStart = dir === 1 ? 0 : width - 1;
        const xEnd = dir === 1 ? width : -1;
        this._fillErrorLine(errorLines[0], width);
        errorLines.push(errorLines.shift());
        const errorLine = errorLines[0];
        for (let x2 = xStart, idx = lni + xStart;x2 !== xEnd; x2 += dir, idx += dir) {
          const point = pointArray[idx];
          const error = errorLine[x2];
          originalPoint.from(point);
          const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
          const palettePoint = palette2.getNearestColor(this._distance, correctedPoint);
          point.from(palettePoint);
          if (this._minColorDistance) {
            const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
            if (dist < this._minColorDistance)
              continue;
          }
          let er;
          let eg;
          let eb;
          let ea;
          if (this._calculateErrorLikeGIMP) {
            er = correctedPoint.r - palettePoint.r;
            eg = correctedPoint.g - palettePoint.g;
            eb = correctedPoint.b - palettePoint.b;
            ea = correctedPoint.a - palettePoint.a;
          } else {
            er = originalPoint.r - palettePoint.r;
            eg = originalPoint.g - palettePoint.g;
            eb = originalPoint.b - palettePoint.b;
            ea = originalPoint.a - palettePoint.a;
          }
          const dStart = dir === 1 ? 0 : this._kernel.length - 1;
          const dEnd = dir === 1 ? this._kernel.length : -1;
          for (let i2 = dStart;i2 !== dEnd; i2 += dir) {
            const x1 = this._kernel[i2][1] * dir;
            const y1 = this._kernel[i2][2];
            if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
              const d = this._kernel[i2][0];
              const e = errorLines[y1][x1 + x2];
              e[0] += er * d;
              e[1] += eg * d;
              e[2] += eb * d;
              e[3] += ea * d;
            }
          }
        }
      }
      yield {
        pointContainer,
        progress: 100
      };
    }
    _fillErrorLine(errorLine, width) {
      if (errorLine.length > width) {
        errorLine.length = width;
      }
      const l = errorLine.length;
      for (let i2 = 0;i2 < l; i2++) {
        const error = errorLine[i2];
        error[0] = error[1] = error[2] = error[3] = 0;
      }
      for (let i2 = l;i2 < width; i2++) {
        errorLine[i2] = [0, 0, 0, 0];
      }
    }
    _setKernel(kernel) {
      switch (kernel) {
        case 0:
          this._kernel = [
            [7 / 16, 1, 0],
            [3 / 16, -1, 1],
            [5 / 16, 0, 1],
            [1 / 16, 1, 1]
          ];
          break;
        case 1:
          this._kernel = [
            [3 / 8, 1, 0],
            [3 / 8, 0, 1],
            [2 / 8, 1, 1]
          ];
          break;
        case 2:
          this._kernel = [
            [8 / 42, 1, 0],
            [4 / 42, 2, 0],
            [2 / 42, -2, 1],
            [4 / 42, -1, 1],
            [8 / 42, 0, 1],
            [4 / 42, 1, 1],
            [2 / 42, 2, 1],
            [1 / 42, -2, 2],
            [2 / 42, -1, 2],
            [4 / 42, 0, 2],
            [2 / 42, 1, 2],
            [1 / 42, 2, 2]
          ];
          break;
        case 3:
          this._kernel = [
            [1 / 8, 1, 0],
            [1 / 8, 2, 0],
            [1 / 8, -1, 1],
            [1 / 8, 0, 1],
            [1 / 8, 1, 1],
            [1 / 8, 0, 2]
          ];
          break;
        case 4:
          this._kernel = [
            [7 / 48, 1, 0],
            [5 / 48, 2, 0],
            [3 / 48, -2, 1],
            [5 / 48, -1, 1],
            [7 / 48, 0, 1],
            [5 / 48, 1, 1],
            [3 / 48, 2, 1],
            [1 / 48, -2, 2],
            [3 / 48, -1, 2],
            [5 / 48, 0, 2],
            [3 / 48, 1, 2],
            [1 / 48, 2, 2]
          ];
          break;
        case 5:
          this._kernel = [
            [8 / 32, 1, 0],
            [4 / 32, 2, 0],
            [2 / 32, -2, 1],
            [4 / 32, -1, 1],
            [8 / 32, 0, 1],
            [4 / 32, 1, 1],
            [2 / 32, 2, 1]
          ];
          break;
        case 6:
          this._kernel = [
            [5 / 32, 1, 0],
            [3 / 32, 2, 0],
            [2 / 32, -2, 1],
            [4 / 32, -1, 1],
            [5 / 32, 0, 1],
            [4 / 32, 1, 1],
            [2 / 32, 2, 1],
            [2 / 32, -1, 2],
            [3 / 32, 0, 2],
            [2 / 32, 1, 2]
          ];
          break;
        case 7:
          this._kernel = [
            [4 / 16, 1, 0],
            [3 / 16, 2, 0],
            [1 / 16, -2, 1],
            [2 / 16, -1, 1],
            [3 / 16, 0, 1],
            [2 / 16, 1, 1],
            [1 / 16, 2, 1]
          ];
          break;
        case 8:
          this._kernel = [
            [2 / 4, 1, 0],
            [1 / 4, -1, 1],
            [1 / 4, 0, 1]
          ];
          break;
        default:
          throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
      }
    }
  };
  var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
      super();
      __publicField(this, "_distance");
      __publicField(this, "_weights");
      __publicField(this, "_errorQueueSize");
      this._distance = colorDistanceCalculator;
      this._errorQueueSize = errorQueueSize;
      this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
    }
    *quantize(pointContainer, palette2) {
      const pointArray = pointContainer.getPointArray();
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const errorQueue = [];
      let head = 0;
      for (let i2 = 0;i2 < this._errorQueueSize; i2++) {
        errorQueue[i2] = { r: 0, g: 0, b: 0, a: 0 };
      }
      yield* hilbertCurve(width, height, (x2, y2) => {
        const p = pointArray[x2 + y2 * width];
        let { r, g, b, a } = p;
        for (let i2 = 0;i2 < this._errorQueueSize; i2++) {
          const weight = this._weights[i2];
          const e = errorQueue[(i2 + head) % this._errorQueueSize];
          r += e.r * weight;
          g += e.g * weight;
          b += e.b * weight;
          a += e.a * weight;
        }
        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));
        const quantizedPoint = palette2.getNearestColor(this._distance, correctedPoint);
        head = (head + 1) % this._errorQueueSize;
        const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
        errorQueue[tail].r = p.r - quantizedPoint.r;
        errorQueue[tail].g = p.g - quantizedPoint.g;
        errorQueue[tail].b = p.b - quantizedPoint.b;
        errorQueue[tail].a = p.a - quantizedPoint.a;
        p.from(quantizedPoint);
      });
      yield {
        pointContainer,
        progress: 100
      };
    }
    static _createWeights(errorPropagation, errorQueueSize) {
      const weights = [];
      const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
      for (let i2 = 0, next = 1;i2 < errorQueueSize; i2++) {
        weights[i2] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
        next *= multiplier;
      }
      return weights;
    }
  };
  var quality_exports = {};
  __export2(quality_exports, {
    ssim: () => ssim
  });
  var K1 = 0.01;
  var K2 = 0.03;
  var setImmediateImpl = typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? undefined : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
  module.exports = __toCommonJS(src_exports);
});

// node_modules/gifwrap/src/gifframe.js
var require_gifframe = __commonJS((exports) => {
  var BitmapImage = require_bitmapimage();
  var { GifError: GifError2 } = require_gif();

  class GifFrame extends BitmapImage {
    constructor(...args) {
      super(...args);
      if (args[0] instanceof GifFrame) {
        const source = args[0];
        this.xOffset = source.xOffset;
        this.yOffset = source.yOffset;
        this.disposalMethod = source.disposalMethod;
        this.delayCentisecs = source.delayCentisecs;
        this.interlaced = source.interlaced;
      } else {
        const lastArg = args[args.length - 1];
        let options = {};
        if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage)) {
          options = lastArg;
        }
        this.xOffset = options.xOffset || 0;
        this.yOffset = options.yOffset || 0;
        this.disposalMethod = options.disposalMethod !== undefined ? options.disposalMethod : GifFrame.DisposeToBackgroundColor;
        this.delayCentisecs = options.delayCentisecs || 8;
        this.interlaced = options.interlaced || false;
      }
    }
    getPalette() {
      const colorSet = new Set;
      const buf = this.bitmap.data;
      let i2 = 0;
      let usesTransparency = false;
      while (i2 < buf.length) {
        if (buf[i2 + 3] === 0) {
          usesTransparency = true;
        } else {
          const color = buf.readUInt32BE(i2, true) >> 8 & 16777215;
          colorSet.add(color);
        }
        i2 += 4;
      }
      const colors = new Array(colorSet.size);
      const iter = colorSet.values();
      for (i2 = 0;i2 < colors.length; ++i2) {
        colors[i2] = iter.next().value;
      }
      colors.sort((a, b) => a - b);
      let indexCount = colors.length;
      if (usesTransparency) {
        ++indexCount;
      }
      return { colors, usesTransparency, indexCount };
    }
  }
  GifFrame.DisposeToAnything = 0;
  GifFrame.DisposeNothing = 1;
  GifFrame.DisposeToBackgroundColor = 2;
  GifFrame.DisposeToPrevious = 3;
  exports.GifFrame = GifFrame;
});

// node_modules/gifwrap/src/gifutil.js
var require_gifutil = __commonJS((exports) => {
  var _quantize = function(imageOrImages, method, maxColorIndexes, modifier, dither) {
    const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
    const ditherAlgs = [
      "FloydSteinberg",
      "FalseFloydSteinberg",
      "Stucki",
      "Atkinson",
      "Jarvis",
      "Burkes",
      "Sierra",
      "TwoSierra",
      "SierraLite"
    ];
    if (dither) {
      if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
        throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
      }
      if (dither.serpentine === undefined) {
        dither.serpentine = true;
      }
      if (dither.minimumColorDistanceToDither === undefined) {
        dither.minimumColorDistanceToDither = 0;
      }
      if (dither.calculateErrorLikeGIMP === undefined) {
        dither.calculateErrorLikeGIMP = false;
      }
    }
    const distCalculator = new ImageQ.distance.Euclidean;
    const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
    let imageMaker;
    if (dither) {
      imageMaker = new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP);
    } else {
      imageMaker = new ImageQ.image.NearestColor(distCalculator);
    }
    const inputContainers = [];
    images.forEach((image2) => {
      const imageBuf = image2.bitmap.data;
      const inputBuf = new ArrayBuffer(imageBuf.length);
      const inputArray = new Uint32Array(inputBuf);
      for (let bi = 0, ai = 0;bi < imageBuf.length; bi += 4, ++ai) {
        inputArray[ai] = imageBuf.readUInt32LE(bi, true);
      }
      const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image2.bitmap.width, image2.bitmap.height);
      quantizer.sample(inputContainer);
      inputContainers.push(inputContainer);
    });
    const limitedPalette = quantizer.quantizeSync();
    for (let i2 = 0;i2 < images.length; ++i2) {
      const imageBuf = images[i2].bitmap.data;
      const outputContainer = imageMaker.quantizeSync(inputContainers[i2], limitedPalette);
      const outputArray = outputContainer.toUint32Array();
      for (let bi = 0, ai = 0;bi < imageBuf.length; bi += 4, ++ai) {
        imageBuf.writeUInt32LE(outputArray[ai], bi);
      }
    }
  };
  var _readBinary = function(path2) {
    return new Promise((resolve2, reject2) => {
      fs2.readFile(path2, (err, buffer) => {
        if (err) {
          return reject2(err);
        }
        return resolve2(buffer);
      });
    });
  };
  var _writeBinary = function(path2, buffer) {
    return new Promise((resolve2, reject2) => {
      fs2.writeFile(path2, buffer, (err) => {
        if (err) {
          return reject2(err);
        }
        return resolve2();
      });
    });
  };
  var fs2 = import.meta.require("fs");
  var ImageQ = require_image_q();
  var BitmapImage = require_bitmapimage();
  var { GifFrame } = require_gifframe();
  var { GifError: GifError2 } = require_gif();
  var { GifCodec } = require_gifcodec();
  var INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
  var defaultCodec = new GifCodec;
  exports.cloneFrames = function(frames) {
    let clones = [];
    frames.forEach((frame) => {
      clones.push(new GifFrame(frame));
    });
    return clones;
  };
  exports.getColorInfo = function(frames, maxGlobalIndex) {
    let usesTransparency = false;
    const palettes = [];
    for (let i2 = 0;i2 < frames.length; ++i2) {
      let palette2 = frames[i2].getPalette();
      if (palette2.usesTransparency) {
        usesTransparency = true;
      }
      if (palette2.indexCount > 256) {
        throw new GifError2(`Frame ${i2} uses more than 256 color indexes`);
      }
      palettes.push(palette2);
    }
    if (maxGlobalIndex === 0) {
      return { usesTransparency, palettes };
    }
    const globalColorSet = new Set;
    palettes.forEach((palette2) => {
      palette2.colors.forEach((color) => {
        globalColorSet.add(color);
      });
    });
    let indexCount = globalColorSet.size;
    if (usesTransparency) {
      ++indexCount;
    }
    if (maxGlobalIndex && indexCount > maxGlobalIndex) {
      return { usesTransparency, palettes };
    }
    const colors = new Array(globalColorSet.size);
    const iter = globalColorSet.values();
    for (let i2 = 0;i2 < colors.length; ++i2) {
      colors[i2] = iter.next().value;
    }
    colors.sort((a, b) => a - b);
    return { colors, indexCount, usesTransparency, palettes };
  };
  exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
    return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
  };
  exports.getMaxDimensions = function(frames) {
    let maxWidth = 0, maxHeight = 0;
    frames.forEach((frame) => {
      const width = frame.xOffset + frame.bitmap.width;
      if (width > maxWidth) {
        maxWidth = width;
      }
      const height = frame.yOffset + frame.bitmap.height;
      if (height > maxHeight) {
        maxHeight = height;
      }
    });
    return { maxWidth, maxHeight };
  };
  exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
  };
  exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    histogram = histogram || "min-pop";
    let histogramID;
    switch (histogram) {
      case "min-pop":
        histogramID = 2;
        break;
      case "top-pop":
        histogramID = 1;
        break;
      default:
        throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
    }
    _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
  };
  exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    significantBits = significantBits || 5;
    if (significantBits < 1 || significantBits > 8) {
      throw new Error("Invalid quantization quality");
    }
    _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
  };
  exports.read = function(source, decoder) {
    decoder = decoder || defaultCodec;
    if (Buffer.isBuffer(source)) {
      return decoder.decodeGif(source);
    }
    return _readBinary(source).then((buffer) => {
      return decoder.decodeGif(buffer);
    });
  };
  exports.shareAsJimp = function(jimp, bitmapImageToShare) {
    const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
    jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
    return jimpImage;
  };
  exports.write = function(path2, frames, spec, encoder) {
    encoder = encoder || defaultCodec;
    const matches = path2.match(/\.[a-zA-Z]+$/);
    if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
      throw new Error(`GIF '${path2}' has an unexpected suffix`);
    }
    return encoder.encodeGif(frames, spec).then((gif) => {
      return _writeBinary(path2, gif.buffer).then(() => {
        return gif;
      });
    });
  };
});

// node_modules/gifwrap/src/gifcodec.js
var require_gifcodec = __commonJS((exports) => {
  var GifUtil = function() {
    const data2 = require_gifutil();
    GifUtil = function() {
      return data2;
    };
    return data2;
  };
  var _colorLookupLinear = function(colors, color) {
    const index = colors.indexOf(color);
    return index === -1 ? null : index;
  };
  var _colorLookupBinary = function(colors, color) {
    var lo = 0, hi = colors.length - 1, mid;
    while (lo <= hi) {
      mid = Math.floor((lo + hi) / 2);
      if (colors[mid] > color)
        hi = mid - 1;
      else if (colors[mid] < color)
        lo = mid + 1;
      else
        return mid;
    }
    return null;
  };
  var _encodeGlobal = function(frames, spec, bufferSizeEst, globalPalette) {
    const extendedGlobalPalette = {
      colors: globalPalette.colors.slice(),
      usesTransparency: globalPalette.usesTransparency
    };
    _extendPaletteToPowerOf2(extendedGlobalPalette);
    const options = {
      palette: extendedGlobalPalette.colors,
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
    } catch (err) {
      throw new GifError2(err);
    }
    for (let i2 = 0;i2 < frames.length; ++i2) {
      buffer = _writeFrame(gifWriter, i2, frames[i2], globalPalette, false);
    }
    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
  };
  var _encodeLocal = function(frames, spec, bufferSizeEst, localPalettes) {
    const options = {
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
    } catch (err) {
      throw new GifError2(err);
    }
    for (let i2 = 0;i2 < frames.length; ++i2) {
      buffer = _writeFrame(gifWriter, i2, frames[i2], localPalettes[i2], true);
    }
    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
  };
  var _extendPaletteToPowerOf2 = function(palette2) {
    const colors = palette2.colors;
    if (palette2.usesTransparency) {
      colors.push(0);
    }
    const colorCount = colors.length;
    let powerOf2 = 2;
    while (colorCount > powerOf2) {
      powerOf2 <<= 1;
    }
    colors.length = powerOf2;
    colors.fill(0, colorCount);
  };
  var _getFrameSizeEst = function(frame, pixelBitWidth) {
    let byteLength = frame.bitmap.width * frame.bitmap.height;
    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
    byteLength += Math.ceil(byteLength / 255);
    return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
  };
  var _getIndexedImage = function(frameIndex, frame, palette2) {
    const colors = palette2.colors;
    const colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary;
    const colorBuffer = frame.bitmap.data;
    const indexBuffer = new Buffer(colorBuffer.length / 4);
    let transparentIndex = colors.length;
    let i2 = 0, j = 0;
    while (i2 < colorBuffer.length) {
      if (colorBuffer[i2 + 3] !== 0) {
        const color = colorBuffer.readUInt32BE(i2, true) >> 8 & 16777215;
        indexBuffer[j] = colorToIndexFunc(colors, color);
      } else {
        indexBuffer[j] = transparentIndex;
      }
      i2 += 4;
      ++j;
    }
    if (palette2.usesTransparency) {
      if (transparentIndex === 256) {
        throw new GifError2(`Frame ${frameIndex} already has 256 colors` + `and so can't use transparency`);
      }
    } else {
      transparentIndex = null;
    }
    return { buffer: indexBuffer, transparentIndex };
  };
  var _getPixelBitWidth = function(palette2) {
    let indexCount = palette2.indexCount;
    let pixelBitWidth = 0;
    --indexCount;
    while (indexCount) {
      ++pixelBitWidth;
      indexCount >>= 1;
    }
    return pixelBitWidth > 0 ? pixelBitWidth : 1;
  };
  var _writeFrame = function(gifWriter, frameIndex, frame, palette2, isLocalPalette) {
    if (frame.interlaced) {
      throw new GifError2("writing interlaced GIFs is not supported");
    }
    const frameInfo = _getIndexedImage(frameIndex, frame, palette2);
    const options = {
      delay: frame.delayCentisecs,
      disposal: frame.disposalMethod,
      transparent: frameInfo.transparentIndex
    };
    if (isLocalPalette) {
      _extendPaletteToPowerOf2(palette2);
      options.palette = palette2.colors;
    }
    try {
      let buffer = gifWriter.getOutputBuffer();
      let startOfFrame = gifWriter.getOutputBufferPosition();
      let endOfFrame;
      let tryAgain = true;
      while (tryAgain) {
        endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);
        tryAgain = false;
        if (endOfFrame >= buffer.length - 1) {
          const biggerBuffer = new Buffer(buffer.length * 1.5);
          buffer.copy(biggerBuffer);
          gifWriter.setOutputBuffer(biggerBuffer);
          gifWriter.setOutputBufferPosition(startOfFrame);
          buffer = biggerBuffer;
          tryAgain = true;
        }
      }
      return buffer;
    } catch (err) {
      throw new GifError2(err);
    }
  };
  var Omggif = require_omggif();
  var { Gif, GifError: GifError2 } = require_gif();
  var { GifFrame } = require_gifframe();
  var PER_GIF_OVERHEAD = 200;
  var PER_FRAME_OVERHEAD = 100;

  class GifCodec {
    constructor(options = {}) {
      this._transparentRGB = null;
      if (typeof options.transparentRGB === "number" && options.transparentRGB !== 0) {
        this._transparentRGBA = options.transparentRGB * 256;
      }
      this._testInitialBufferSize = 0;
    }
    decodeGif(buffer) {
      try {
        let reader;
        try {
          reader = new Omggif.GifReader(buffer);
        } catch (err) {
          throw new GifError2(err);
        }
        const frameCount = reader.numFrames();
        const frames = [];
        const spec = {
          width: reader.width,
          height: reader.height,
          loops: reader.loopCount()
        };
        spec.usesTransparency = false;
        for (let i2 = 0;i2 < frameCount; ++i2) {
          const frameInfo = this._decodeFrame(reader, i2, spec.usesTransparency);
          frames.push(frameInfo.frame);
          if (frameInfo.usesTransparency) {
            spec.usesTransparency = true;
          }
        }
        return Promise.resolve(new Gif(buffer, frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    encodeGif(frames, spec = {}) {
      try {
        if (frames === null || frames.length === 0) {
          throw new GifError2("there are no frames");
        }
        const dims = GifUtil().getMaxDimensions(frames);
        spec = Object.assign({}, spec);
        spec.width = dims.maxWidth;
        spec.height = dims.maxHeight;
        if (spec.loops === undefined) {
          spec.loops = 0;
        }
        spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;
        return Promise.resolve(this._encodeGif(frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
      let info, buffer;
      try {
        info = reader.frameInfo(frameIndex);
        buffer = new Buffer(reader.width * reader.height * 4);
        reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
        if (info.width !== reader.width || info.height !== reader.height) {
          if (info.y) {
            buffer = buffer.slice(info.y * reader.width * 4);
          }
          if (reader.width > info.width) {
            for (let ii = 0;ii < info.height; ++ii) {
              buffer.copy(buffer, ii * info.width * 4, (info.x + ii * reader.width) * 4, (info.x + ii * reader.width) * 4 + info.width * 4);
            }
          }
          buffer = buffer.slice(0, info.width * info.height * 4);
        }
      } catch (err) {
        throw new GifError2(err);
      }
      let usesTransparency = false;
      if (this._transparentRGBA === null) {
        if (!alreadyUsedTransparency) {
          for (let i2 = 3;i2 < buffer.length; i2 += 4) {
            if (buffer[i2] === 0) {
              usesTransparency = true;
              i2 = buffer.length;
            }
          }
        }
      } else {
        for (let i2 = 3;i2 < buffer.length; i2 += 4) {
          if (buffer[i2] === 0) {
            buffer.writeUInt32BE(this._transparentRGBA, i2 - 3);
            usesTransparency = true;
          }
        }
      }
      const frame = new GifFrame(info.width, info.height, buffer, {
        xOffset: info.x,
        yOffset: info.y,
        disposalMethod: info.disposal,
        interlaced: info.interlaced,
        delayCentisecs: info.delay
      });
      return { frame, usesTransparency };
    }
    _encodeGif(frames, spec) {
      let colorInfo;
      if (spec.colorScope === Gif.LocalColorsOnly) {
        colorInfo = GifUtil().getColorInfo(frames, 0);
      } else {
        colorInfo = GifUtil().getColorInfo(frames, 256);
        if (!colorInfo.colors) {
          if (spec.colorScope === Gif.GlobalColorsOnly) {
            throw new GifError2("Too many color indexes for global color table");
          }
          spec.colorScope = Gif.LocalColorsOnly;
        }
      }
      spec.usesTransparency = colorInfo.usesTransparency;
      const localPalettes = colorInfo.palettes;
      if (spec.colorScope === Gif.LocalColorsOnly) {
        const localSizeEst = 2000;
        return _encodeLocal(frames, spec, localSizeEst, localPalettes);
      }
      const globalSizeEst = 2000;
      return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
    }
    _getSizeEstimateGlobal(globalPalette, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
      const pixelBitWidth = _getPixelBitWidth(globalPalette);
      frames.forEach((frame) => {
        sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
      });
      return sizeEst;
    }
    _getSizeEstimateLocal(palettes, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD;
      for (let i2 = 0;i2 < frames.length; ++i2) {
        const palette2 = palettes[i2];
        const pixelBitWidth = _getPixelBitWidth(palette2);
        sizeEst += _getFrameSizeEst(frames[i2], pixelBitWidth);
      }
      return sizeEst;
    }
  }
  exports.GifCodec = GifCodec;
});

// node_modules/gifwrap/src/index.js
var require_src = __commonJS((exports, module) => {
  var BitmapImage = require_bitmapimage();
  var { Gif, GifError: GifError2 } = require_gif();
  var { GifCodec } = require_gifcodec();
  var { GifFrame } = require_gifframe();
  var GifUtil = require_gifutil();
  module.exports = {
    BitmapImage,
    Gif,
    GifCodec,
    GifFrame,
    GifUtil,
    GifError: GifError2
  };
});

// node_modules/phin/lib/phin.compiled.js
var require_phin_compiled = __commonJS((exports, module) => {
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var url = import.meta.require("url");
  var qs = import.meta.require("querystring");
  var zlib = import.meta.require("zlib");
  var util = import.meta.require("util");
  var phin = function phin(opts, cb) {
    if (typeof opts !== "string") {
      if (!opts.hasOwnProperty("url")) {
        throw new Error("Missing url option from options for request method.");
      }
    }
    var addr = (typeof opts === "undefined" ? "undefined" : _typeof2(opts)) === "object" ? url.parse(opts.url) : url.parse(opts);
    var options = { hostname: addr.hostname, port: addr.port || (addr.protocol.toLowerCase() === "http:" ? 80 : 443), path: addr.path, method: "GET", headers: {}, auth: addr.auth || null, parse: "none", stream: false };
    if ((typeof opts === "undefined" ? "undefined" : _typeof2(opts)) === "object") {
      options = Object.assign(options, opts);
    }
    options.port = Number(options.port);
    if (options.hasOwnProperty("timeout"))
      delete options.timeout;
    if (options.compressed === true) {
      options.headers["accept-encoding"] = "gzip, deflate";
    }
    if (opts.hasOwnProperty("form")) {
      if (_typeof2(opts.form) !== "object") {
        throw new Error("phin \'form\' option must be of type Object if present.");
      }
      var formDataString = qs.stringify(opts.form);
      options.headers["Content-Type"] = "application/x-www-form-urlencoded";
      options.headers["Content-Length"] = Buffer.byteLength(formDataString);
      opts.data = formDataString;
    }
    var req = undefined;
    var resHandler = function resHandler(res) {
      var stream2 = res;
      if (options.compressed === true) {
        if (res.headers["content-encoding"] === "gzip") {
          stream2 = res.pipe(zlib.createGunzip());
        } else if (res.headers["content-encoding"] === "deflate") {
          stream2 = res.pipe(zlib.createInflate());
        }
      }
      if (options.stream === true) {
        res.stream = stream2;
        if (cb)
          cb(null, res);
      } else {
        res.body = new Buffer([]);
        stream2.on("data", function(chunk) {
          res.body = Buffer.concat([res.body, chunk]);
        });
        stream2.on("end", function() {
          if (cb) {
            if (options.parse === "json") {
              try {
                res.body = JSON.parse(res.body.toString());
              } catch (err) {
                cb("Invalid JSON received.", res);
                return;
              }
            }
            cb(null, res);
          }
        });
      }
    };
    switch (addr.protocol.toLowerCase()) {
      case "http:":
        req = http.request(options, resHandler);
        break;
      case "https:":
        req = https.request(options, resHandler);
        break;
      default:
        if (cb)
          cb(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
        return;
    }
    if (typeof opts.timeout === "number") {
      req.setTimeout(opts.timeout, function() {
        req.abort();
        if (cb)
          cb(new Error("Timeout has been reached."), null);
        cb = null;
      });
    }
    req.on("error", function(err) {
      if (cb)
        cb(err, null);
    });
    if (opts.hasOwnProperty("data")) {
      var postData = opts.data;
      if (!(opts.data instanceof Buffer) && _typeof2(opts.data) === "object") {
        var contentType = options.headers["content-type"] || options.headers["Content-Type"];
        if (contentType === "application/x-www-form-urlencoded") {
          postData = qs.stringify(opts.data);
        } else {
          try {
            postData = JSON.stringify(opts.data);
          } catch (err) {
            if (cb)
              cb(new Error("Couldn\'t stringify object. (Likely due to a circular reference.)"), null);
          }
        }
      }
      req.write(postData);
    }
    req.end();
  };
  phin.promisified = function(opts, http2) {
    return new Promise(function(resolve2, reject2) {
      phin(opts, function(err, res) {
        if (err) {
          reject2(err);
        } else {
          resolve2(res);
        }
      }, http2);
    });
  };
  if (util.promisify) {
    phin[util.promisify.custom] = phin.promisified;
  }
  module.exports = phin;
});

// node_modules/parse-bmfont-ascii/index.js
var require_parse_bmfont_ascii = __commonJS((exports, module) => {
  var splitLine = function(line, idx) {
    line = line.replace(/\t+/g, " ").trim();
    if (!line)
      return null;
    var space = line.indexOf(" ");
    if (space === -1)
      throw new Error("no named row at line " + idx);
    var key = line.substring(0, space);
    line = line.substring(space + 1);
    line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, "");
    line = line.split("=");
    line = line.map(function(str) {
      return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
    });
    var data2 = [];
    for (var i2 = 0;i2 < line.length; i2++) {
      var dt = line[i2];
      if (i2 === 0) {
        data2.push({
          key: dt[0],
          data: ""
        });
      } else if (i2 === line.length - 1) {
        data2[data2.length - 1].data = parseData(dt[0]);
      } else {
        data2[data2.length - 1].data = parseData(dt[0]);
        data2.push({
          key: dt[1],
          data: ""
        });
      }
    }
    var out = {
      key,
      data: {}
    };
    data2.forEach(function(v) {
      out.data[v.key] = v.data;
    });
    return out;
  };
  var parseData = function(data2) {
    if (!data2 || data2.length === 0)
      return "";
    if (data2.indexOf('"') === 0 || data2.indexOf("'") === 0)
      return data2.substring(1, data2.length - 1);
    if (data2.indexOf(",") !== -1)
      return parseIntList(data2);
    return parseInt(data2, 10);
  };
  var parseIntList = function(data2) {
    return data2.split(",").map(function(val) {
      return parseInt(val, 10);
    });
  };
  module.exports = function parseBMFontAscii(data2) {
    if (!data2)
      throw new Error("no data provided");
    data2 = data2.toString().trim();
    var output = {
      pages: [],
      chars: [],
      kernings: []
    };
    var lines = data2.split(/\r\n?|\n/g);
    if (lines.length === 0)
      throw new Error("no data in BMFont file");
    for (var i2 = 0;i2 < lines.length; i2++) {
      var lineData = splitLine(lines[i2], i2);
      if (!lineData)
        continue;
      if (lineData.key === "page") {
        if (typeof lineData.data.id !== "number")
          throw new Error("malformed file at line " + i2 + " -- needs page id=N");
        if (typeof lineData.data.file !== "string")
          throw new Error("malformed file at line " + i2 + ' -- needs page file="path"');
        output.pages[lineData.data.id] = lineData.data.file;
      } else if (lineData.key === "chars" || lineData.key === "kernings") {
      } else if (lineData.key === "char") {
        output.chars.push(lineData.data);
      } else if (lineData.key === "kerning") {
        output.kernings.push(lineData.data);
      } else {
        output[lineData.key] = lineData.data;
      }
    }
    return output;
  };
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS((exports) => {
  (function() {
    exports.defaults = {
      "0.1": {
        explicitCharkey: false,
        trim: true,
        normalize: true,
        normalizeTags: false,
        attrkey: "@",
        charkey: "#",
        explicitArray: false,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: false,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        childkey: "@@",
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ""
      },
      "0.2": {
        explicitCharkey: false,
        trim: false,
        normalize: false,
        normalizeTags: false,
        attrkey: "$",
        charkey: "_",
        explicitArray: true,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: true,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        preserveChildrenOrder: false,
        childkey: "$$",
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: "root",
        xmldec: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: true
        },
        doctype: null,
        renderOpts: {
          pretty: true,
          indent: "  ",
          newline: "\n"
        },
        headless: false,
        chunkSize: 1e4,
        emptyTag: "",
        cdata: false
      }
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS((exports, module) => {
  (function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
    assign = function() {
      var i2, key, len, source, sources, target;
      target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (isFunction(Object.assign)) {
        Object.assign.apply(null, arguments);
      } else {
        for (i2 = 0, len = sources.length;i2 < len; i2++) {
          source = sources[i2];
          if (source != null) {
            for (key in source) {
              if (!hasProp.call(source, key))
                continue;
              target[key] = source[key];
            }
          }
        }
      }
      return target;
    };
    isFunction = function(val) {
      return !!val && Object.prototype.toString.call(val) === "[object Function]";
    };
    isObject = function(val) {
      var ref;
      return !!val && ((ref = typeof val) === "function" || ref === "object");
    };
    isArray = function(val) {
      if (isFunction(Array.isArray)) {
        return Array.isArray(val);
      } else {
        return Object.prototype.toString.call(val) === "[object Array]";
      }
    };
    isEmpty = function(val) {
      var key;
      if (isArray(val)) {
        return !val.length;
      } else {
        for (key in val) {
          if (!hasProp.call(val, key))
            continue;
          return false;
        }
        return true;
      }
    };
    isPlainObject = function(val) {
      var ctor, proto;
      return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
      if (isFunction(obj.valueOf)) {
        return obj.valueOf();
      } else {
        return obj;
      }
    };
    exports.assign = assign;
    exports.isFunction = isFunction;
    exports.isObject = isObject;
    exports.isArray = isArray;
    exports.isEmpty = isEmpty;
    exports.isPlainObject = isPlainObject;
    exports.getValue = getValue;
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS((exports, module) => {
  (function() {
    var XMLDOMImplementation;
    module.exports = XMLDOMImplementation = function() {
      function XMLDOMImplementation2() {
      }
      XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
        return true;
      };
      XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
        throw new Error("This DOM method is not implemented.");
      };
      return XMLDOMImplementation2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS((exports, module) => {
  (function() {
    var XMLDOMErrorHandler;
    module.exports = XMLDOMErrorHandler = function() {
      function XMLDOMErrorHandler2() {
      }
      XMLDOMErrorHandler2.prototype.handleError = function(error) {
        throw new Error(error);
      };
      return XMLDOMErrorHandler2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS((exports, module) => {
  (function() {
    var XMLDOMStringList;
    module.exports = XMLDOMStringList = function() {
      function XMLDOMStringList2(arr) {
        this.arr = arr || [];
      }
      Object.defineProperty(XMLDOMStringList2.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      });
      XMLDOMStringList2.prototype.item = function(index) {
        return this.arr[index] || null;
      };
      XMLDOMStringList2.prototype.contains = function(str) {
        return this.arr.indexOf(str) !== -1;
      };
      return XMLDOMStringList2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS((exports, module) => {
  (function() {
    var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require_XMLDOMErrorHandler();
    XMLDOMStringList = require_XMLDOMStringList();
    module.exports = XMLDOMConfiguration = function() {
      function XMLDOMConfiguration2() {
        var clonedSelf;
        this.defaultParams = {
          "canonical-form": false,
          "cdata-sections": false,
          comments: false,
          "datatype-normalization": false,
          "element-content-whitespace": true,
          entities: true,
          "error-handler": new XMLDOMErrorHandler,
          infoset: true,
          "validate-if-schema": false,
          namespaces: true,
          "namespace-declarations": true,
          "normalize-characters": false,
          "schema-location": "",
          "schema-type": "",
          "split-cdata-sections": true,
          validate: false,
          "well-formed": true
        };
        this.params = clonedSelf = Object.create(this.defaultParams);
      }
      Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
        get: function() {
          return new XMLDOMStringList(Object.keys(this.defaultParams));
        }
      });
      XMLDOMConfiguration2.prototype.getParameter = function(name2) {
        if (this.params.hasOwnProperty(name2)) {
          return this.params[name2];
        } else {
          return null;
        }
      };
      XMLDOMConfiguration2.prototype.canSetParameter = function(name2, value2) {
        return true;
      };
      XMLDOMConfiguration2.prototype.setParameter = function(name2, value2) {
        if (value2 != null) {
          return this.params[name2] = value2;
        } else {
          return delete this.params[name2];
        }
      };
      return XMLDOMConfiguration2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS((exports, module) => {
  (function() {
    module.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLAttribute, XMLNode;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module.exports = XMLAttribute = function() {
      function XMLAttribute2(parent, name2, value2) {
        this.parent = parent;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        if (name2 == null) {
          throw new Error("Missing attribute name. " + this.debugInfo(name2));
        }
        this.name = this.stringify.name(name2);
        this.value = this.stringify.attValue(value2);
        this.type = NodeType.Attribute;
        this.isId = false;
        this.schemaTypeInfo = null;
      }
      Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value2) {
          return this.value = value2 || "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "prefix", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "specified", {
        get: function() {
          return true;
        }
      });
      XMLAttribute2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLAttribute2.prototype.toString = function(options) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
      };
      XMLAttribute2.prototype.debugInfo = function(name2) {
        name2 = name2 || this.name;
        if (name2 == null) {
          return "parent: <" + this.parent.name + ">";
        } else {
          return "attribute: {" + name2 + "}, parent: <" + this.parent.name + ">";
        }
      };
      XMLAttribute2.prototype.isEqualNode = function(node) {
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.value !== this.value) {
          return false;
        }
        return true;
      };
      return XMLAttribute2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS((exports, module) => {
  (function() {
    var XMLNamedNodeMap;
    module.exports = XMLNamedNodeMap = function() {
      function XMLNamedNodeMap2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      });
      XMLNamedNodeMap2.prototype.clone = function() {
        return this.nodes = null;
      };
      XMLNamedNodeMap2.prototype.getNamedItem = function(name2) {
        return this.nodes[name2];
      };
      XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
        var oldNode;
        oldNode = this.nodes[node.nodeName];
        this.nodes[node.nodeName] = node;
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.removeNamedItem = function(name2) {
        var oldNode;
        oldNode = this.nodes[name2];
        delete this.nodes[name2];
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.item = function(index) {
        return this.nodes[Object.keys(this.nodes)[index]] || null;
      };
      XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };
      return XMLNamedNodeMap2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLAttribute = require_XMLAttribute();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module.exports = XMLElement = function(superClass) {
      extend(XMLElement2, superClass);
      function XMLElement2(parent, name2, attributes) {
        var child, j, len, ref1;
        XMLElement2.__super__.constructor.call(this, parent);
        if (name2 == null) {
          throw new Error("Missing element name. " + this.debugInfo());
        }
        this.name = this.stringify.name(name2);
        this.type = NodeType.Element;
        this.attribs = {};
        this.schemaTypeInfo = null;
        if (attributes != null) {
          this.attribute(attributes);
        }
        if (parent.type === NodeType.Document) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;
          if (parent.children) {
            ref1 = parent.children;
            for (j = 0, len = ref1.length;j < len; j++) {
              child = ref1[j];
              if (child.type === NodeType.DocType) {
                child.name = this.name;
                break;
              }
            }
          }
        }
      }
      Object.defineProperty(XMLElement2.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLElement2.prototype, "prefix", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLElement2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement2.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "attributes", {
        get: function() {
          if (!this.attributeMap || !this.attributeMap.nodes) {
            this.attributeMap = new XMLNamedNodeMap(this.attribs);
          }
          return this.attributeMap;
        }
      });
      XMLElement2.prototype.clone = function() {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this);
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        clonedSelf.attribs = {};
        ref1 = this.attribs;
        for (attName in ref1) {
          if (!hasProp.call(ref1, attName))
            continue;
          att = ref1[attName];
          clonedSelf.attribs[attName] = att.clone();
        }
        clonedSelf.children = [];
        this.children.forEach(function(child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };
      XMLElement2.prototype.attribute = function(name2, value2) {
        var attName, attValue;
        if (name2 != null) {
          name2 = getValue(name2);
        }
        if (isObject(name2)) {
          for (attName in name2) {
            if (!hasProp.call(name2, attName))
              continue;
            attValue = name2[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value2)) {
            value2 = value2.apply();
          }
          if (this.options.keepNullAttributes && value2 == null) {
            this.attribs[name2] = new XMLAttribute(this, name2, "");
          } else if (value2 != null) {
            this.attribs[name2] = new XMLAttribute(this, name2, value2);
          }
        }
        return this;
      };
      XMLElement2.prototype.removeAttribute = function(name2) {
        var attName, j, len;
        if (name2 == null) {
          throw new Error("Missing attribute name. " + this.debugInfo());
        }
        name2 = getValue(name2);
        if (Array.isArray(name2)) {
          for (j = 0, len = name2.length;j < len; j++) {
            attName = name2[j];
            delete this.attribs[attName];
          }
        } else {
          delete this.attribs[name2];
        }
        return this;
      };
      XMLElement2.prototype.toString = function(options) {
        return this.options.writer.element(this, this.options.writer.filterOptions(options));
      };
      XMLElement2.prototype.att = function(name2, value2) {
        return this.attribute(name2, value2);
      };
      XMLElement2.prototype.a = function(name2, value2) {
        return this.attribute(name2, value2);
      };
      XMLElement2.prototype.getAttribute = function(name2) {
        if (this.attribs.hasOwnProperty(name2)) {
          return this.attribs[name2].value;
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttribute = function(name2, value2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNode = function(name2) {
        if (this.attribs.hasOwnProperty(name2)) {
          return this.attribs[name2];
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttributeNode = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagName = function(name2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.hasAttribute = function(name2) {
        return this.attribs.hasOwnProperty(name2);
      };
      XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setIdAttribute = function(name2, isId) {
        if (this.attribs.hasOwnProperty(name2)) {
          return this.attribs[name2].isId;
        } else {
          return isId;
        }
      };
      XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.isEqualNode = function(node) {
        var i2, j, ref1;
        if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.attribs.length !== this.attribs.length) {
          return false;
        }
        for (i2 = j = 0, ref1 = this.attribs.length - 1;0 <= ref1 ? j <= ref1 : j >= ref1; i2 = 0 <= ref1 ? ++j : --j) {
          if (!this.attribs[i2].isEqualNode(node.attribs[i2])) {
            return false;
          }
        }
        return true;
      };
      return XMLElement2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS((exports, module) => {
  (function() {
    var XMLCharacterData, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    module.exports = XMLCharacterData = function(superClass) {
      extend(XMLCharacterData2, superClass);
      function XMLCharacterData2(parent) {
        XMLCharacterData2.__super__.constructor.call(this, parent);
        this.value = "";
      }
      Object.defineProperty(XMLCharacterData2.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(value2) {
          return this.value = value2 || "";
        }
      });
      Object.defineProperty(XMLCharacterData2.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      });
      Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value2) {
          return this.value = value2 || "";
        }
      });
      XMLCharacterData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCharacterData2.prototype.substringData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.appendData = function(arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.insertData = function(offset, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.deleteData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.isEqualNode = function(node) {
        if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.data !== this.data) {
          return false;
        }
        return true;
      };
      return XMLCharacterData2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLCData = function(superClass) {
      extend(XMLCData2, superClass);
      function XMLCData2(parent, text) {
        XMLCData2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing CDATA text. " + this.debugInfo());
        }
        this.name = "#cdata-section";
        this.type = NodeType.CData;
        this.value = this.stringify.cdata(text);
      }
      XMLCData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCData2.prototype.toString = function(options) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
      };
      return XMLCData2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLComment = function(superClass) {
      extend(XMLComment2, superClass);
      function XMLComment2(parent, text) {
        XMLComment2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing comment text. " + this.debugInfo());
        }
        this.name = "#comment";
        this.type = NodeType.Comment;
        this.value = this.stringify.comment(text);
      }
      XMLComment2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLComment2.prototype.toString = function(options) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(options));
      };
      return XMLComment2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDeclaration = function(superClass) {
      extend(XMLDeclaration2, superClass);
      function XMLDeclaration2(parent, version, encoding, standalone) {
        var ref;
        XMLDeclaration2.__super__.constructor.call(this, parent);
        if (isObject(version)) {
          ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
        }
        if (!version) {
          version = "1.0";
        }
        this.type = NodeType.Declaration;
        this.version = this.stringify.xmlVersion(version);
        if (encoding != null) {
          this.encoding = this.stringify.xmlEncoding(encoding);
        }
        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }
      XMLDeclaration2.prototype.toString = function(options) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
      };
      return XMLDeclaration2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDAttList = function(superClass) {
      extend(XMLDTDAttList2, superClass);
      function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        XMLDTDAttList2.__super__.constructor.call(this, parent);
        if (elementName == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (attributeName == null) {
          throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
        }
        if (!attributeType) {
          throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
        }
        if (!defaultValueType) {
          throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
        }
        if (defaultValueType.indexOf("#") !== 0) {
          defaultValueType = "#" + defaultValueType;
        }
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        this.elementName = this.stringify.name(elementName);
        this.type = NodeType.AttributeDeclaration;
        this.attributeName = this.stringify.name(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);
        if (defaultValue) {
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        }
        this.defaultValueType = defaultValueType;
      }
      XMLDTDAttList2.prototype.toString = function(options) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDAttList2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDEntity = function(superClass) {
      extend(XMLDTDEntity2, superClass);
      function XMLDTDEntity2(parent, pe, name2, value2) {
        XMLDTDEntity2.__super__.constructor.call(this, parent);
        if (name2 == null) {
          throw new Error("Missing DTD entity name. " + this.debugInfo(name2));
        }
        if (value2 == null) {
          throw new Error("Missing DTD entity value. " + this.debugInfo(name2));
        }
        this.pe = !!pe;
        this.name = this.stringify.name(name2);
        this.type = NodeType.EntityDeclaration;
        if (!isObject(value2)) {
          this.value = this.stringify.dtdEntityValue(value2);
          this.internal = true;
        } else {
          if (!value2.pubID && !value2.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name2));
          }
          if (value2.pubID && !value2.sysID) {
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name2));
          }
          this.internal = false;
          if (value2.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value2.pubID);
          }
          if (value2.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value2.sysID);
          }
          if (value2.nData != null) {
            this.nData = this.stringify.dtdNData(value2.nData);
          }
          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name2));
          }
        }
      }
      Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      });
      XMLDTDEntity2.prototype.toString = function(options) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDEntity2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDElement = function(superClass) {
      extend(XMLDTDElement2, superClass);
      function XMLDTDElement2(parent, name2, value2) {
        XMLDTDElement2.__super__.constructor.call(this, parent);
        if (name2 == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (!value2) {
          value2 = "(#PCDATA)";
        }
        if (Array.isArray(value2)) {
          value2 = "(" + value2.join(",") + ")";
        }
        this.name = this.stringify.name(name2);
        this.type = NodeType.ElementDeclaration;
        this.value = this.stringify.dtdElementValue(value2);
      }
      XMLDTDElement2.prototype.toString = function(options) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDElement2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDNotation = function(superClass) {
      extend(XMLDTDNotation2, superClass);
      function XMLDTDNotation2(parent, name2, value2) {
        XMLDTDNotation2.__super__.constructor.call(this, parent);
        if (name2 == null) {
          throw new Error("Missing DTD notation name. " + this.debugInfo(name2));
        }
        if (!value2.pubID && !value2.sysID) {
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name2));
        }
        this.name = this.stringify.name(name2);
        this.type = NodeType.NotationDeclaration;
        if (value2.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value2.pubID);
        }
        if (value2.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value2.sysID);
        }
      }
      Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      XMLDTDNotation2.prototype.toString = function(options) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDNotation2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module.exports = XMLDocType = function(superClass) {
      extend(XMLDocType2, superClass);
      function XMLDocType2(parent, pubID, sysID) {
        var child, i2, len, ref, ref1, ref2;
        XMLDocType2.__super__.constructor.call(this, parent);
        this.type = NodeType.DocType;
        if (parent.children) {
          ref = parent.children;
          for (i2 = 0, len = ref.length;i2 < len; i2++) {
            child = ref[i2];
            if (child.type === NodeType.Element) {
              this.name = child.name;
              break;
            }
          }
        }
        this.documentObject = parent;
        if (isObject(pubID)) {
          ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
        }
        if (sysID == null) {
          ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }
      Object.defineProperty(XMLDocType2.prototype, "entities", {
        get: function() {
          var child, i2, len, nodes, ref;
          nodes = {};
          ref = this.children;
          for (i2 = 0, len = ref.length;i2 < len; i2++) {
            child = ref[i2];
            if (child.type === NodeType.EntityDeclaration && !child.pe) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "notations", {
        get: function() {
          var child, i2, len, nodes, ref;
          nodes = {};
          ref = this.children;
          for (i2 = 0, len = ref.length;i2 < len; i2++) {
            child = ref[i2];
            if (child.type === NodeType.NotationDeclaration) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      XMLDocType2.prototype.element = function(name2, value2) {
        var child;
        child = new XMLDTDElement(this, name2, value2);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.entity = function(name2, value2) {
        var child;
        child = new XMLDTDEntity(this, false, name2, value2);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.pEntity = function(name2, value2) {
        var child;
        child = new XMLDTDEntity(this, true, name2, value2);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.notation = function(name2, value2) {
        var child;
        child = new XMLDTDNotation(this, name2, value2);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.toString = function(options) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(options));
      };
      XMLDocType2.prototype.ele = function(name2, value2) {
        return this.element(name2, value2);
      };
      XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      };
      XMLDocType2.prototype.ent = function(name2, value2) {
        return this.entity(name2, value2);
      };
      XMLDocType2.prototype.pent = function(name2, value2) {
        return this.pEntity(name2, value2);
      };
      XMLDocType2.prototype.not = function(name2, value2) {
        return this.notation(name2, value2);
      };
      XMLDocType2.prototype.up = function() {
        return this.root() || this.documentObject;
      };
      XMLDocType2.prototype.isEqualNode = function(node) {
        if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.name !== this.name) {
          return false;
        }
        if (node.publicId !== this.publicId) {
          return false;
        }
        if (node.systemId !== this.systemId) {
          return false;
        }
        return true;
      };
      return XMLDocType2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module.exports = XMLRaw = function(superClass) {
      extend(XMLRaw2, superClass);
      function XMLRaw2(parent, text) {
        XMLRaw2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing raw text. " + this.debugInfo());
        }
        this.type = NodeType.Raw;
        this.value = this.stringify.raw(text);
      }
      XMLRaw2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLRaw2.prototype.toString = function(options) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(options));
      };
      return XMLRaw2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLText = function(superClass) {
      extend(XMLText2, superClass);
      function XMLText2(parent, text) {
        XMLText2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing element text. " + this.debugInfo());
        }
        this.name = "#text";
        this.type = NodeType.Text;
        this.value = this.stringify.text(text);
      }
      Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLText2.prototype, "wholeText", {
        get: function() {
          var next, prev, str;
          str = "";
          prev = this.previousSibling;
          while (prev) {
            str = prev.data + str;
            prev = prev.previousSibling;
          }
          str += this.data;
          next = this.nextSibling;
          while (next) {
            str = str + next.data;
            next = next.nextSibling;
          }
          return str;
        }
      });
      XMLText2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLText2.prototype.toString = function(options) {
        return this.options.writer.text(this, this.options.writer.filterOptions(options));
      };
      XMLText2.prototype.splitText = function(offset) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLText2.prototype.replaceWholeText = function(content) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      return XMLText2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLProcessingInstruction = function(superClass) {
      extend(XMLProcessingInstruction2, superClass);
      function XMLProcessingInstruction2(parent, target, value2) {
        XMLProcessingInstruction2.__super__.constructor.call(this, parent);
        if (target == null) {
          throw new Error("Missing instruction target. " + this.debugInfo());
        }
        this.type = NodeType.ProcessingInstruction;
        this.target = this.stringify.insTarget(target);
        this.name = this.target;
        if (value2) {
          this.value = this.stringify.insValue(value2);
        }
      }
      XMLProcessingInstruction2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLProcessingInstruction2.prototype.toString = function(options) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
      };
      XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
        if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.target !== this.target) {
          return false;
        }
        return true;
      };
      return XMLProcessingInstruction2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDummy = function(superClass) {
      extend(XMLDummy2, superClass);
      function XMLDummy2(parent) {
        XMLDummy2.__super__.constructor.call(this, parent);
        this.type = NodeType.Dummy;
      }
      XMLDummy2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLDummy2.prototype.toString = function(options) {
        return "";
      };
      return XMLDummy2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS((exports, module) => {
  (function() {
    var XMLNodeList;
    module.exports = XMLNodeList = function() {
      function XMLNodeList2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNodeList2.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      });
      XMLNodeList2.prototype.clone = function() {
        return this.nodes = null;
      };
      XMLNodeList2.prototype.item = function(index) {
        return this.nodes[index] || null;
      };
      return XMLNodeList2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS((exports, module) => {
  (function() {
    module.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS((exports, module) => {
  (function() {
    var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
    ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    XMLProcessingInstruction = null;
    XMLDummy = null;
    NodeType = null;
    XMLNodeList = null;
    XMLNamedNodeMap = null;
    DocumentPosition = null;
    module.exports = XMLNode = function() {
      function XMLNode2(parent1) {
        this.parent = parent1;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        this.value = null;
        this.children = [];
        this.baseURI = null;
        if (!XMLElement) {
          XMLElement = require_XMLElement();
          XMLCData = require_XMLCData();
          XMLComment = require_XMLComment();
          XMLDeclaration = require_XMLDeclaration();
          XMLDocType = require_XMLDocType();
          XMLRaw = require_XMLRaw();
          XMLText = require_XMLText();
          XMLProcessingInstruction = require_XMLProcessingInstruction();
          XMLDummy = require_XMLDummy();
          NodeType = require_NodeType();
          XMLNodeList = require_XMLNodeList();
          XMLNamedNodeMap = require_XMLNamedNodeMap();
          DocumentPosition = require_DocumentPosition();
        }
      }
      Object.defineProperty(XMLNode2.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "childNodes", {
        get: function() {
          if (!this.childNodeList || !this.childNodeList.nodes) {
            this.childNodeList = new XMLNodeList(this.children);
          }
          return this.childNodeList;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "previousSibling", {
        get: function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          return this.parent.children[i2 - 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nextSibling", {
        get: function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          return this.parent.children[i2 + 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "textContent", {
        get: function() {
          var child, j, len, ref2, str;
          if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
            str = "";
            ref2 = this.children;
            for (j = 0, len = ref2.length;j < len; j++) {
              child = ref2[j];
              if (child.textContent) {
                str += child.textContent;
              }
            }
            return str;
          } else {
            return null;
          }
        },
        set: function(value2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      XMLNode2.prototype.setParent = function(parent) {
        var child, j, len, ref2, results;
        this.parent = parent;
        if (parent) {
          this.options = parent.options;
          this.stringify = parent.stringify;
        }
        ref2 = this.children;
        results = [];
        for (j = 0, len = ref2.length;j < len; j++) {
          child = ref2[j];
          results.push(child.setParent(this));
        }
        return results;
      };
      XMLNode2.prototype.element = function(name2, attributes, text) {
        var childNode, item2, j, k, key, lastChild, len, len1, ref2, ref3, val;
        lastChild = null;
        if (attributes === null && text == null) {
          ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
        }
        if (name2 != null) {
          name2 = getValue(name2);
        }
        if (Array.isArray(name2)) {
          for (j = 0, len = name2.length;j < len; j++) {
            item2 = name2[j];
            lastChild = this.element(item2);
          }
        } else if (isFunction(name2)) {
          lastChild = this.element(name2.apply());
        } else if (isObject(name2)) {
          for (key in name2) {
            if (!hasProp.call(name2, key))
              continue;
            val = name2[key];
            if (isFunction(val)) {
              val = val.apply();
            }
            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
              lastChild = this.dummy();
            } else if (isObject(val) && isEmpty(val)) {
              lastChild = this.element(key);
            } else if (!this.options.keepNullNodes && val == null) {
              lastChild = this.dummy();
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length;k < len1; k++) {
                item2 = val[k];
                childNode = {};
                childNode[key] = item2;
                lastChild = this.element(childNode);
              }
            } else if (isObject(val)) {
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.element(val);
              } else {
                lastChild = this.element(key);
                lastChild.element(val);
              }
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else if (!this.options.keepNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name2.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name2.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name2.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name2.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name2.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(name2.substr(this.stringify.convertPIKey.length), text);
          } else {
            lastChild = this.node(name2, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name2 + ". " + this.debugInfo());
        }
        return lastChild;
      };
      XMLNode2.prototype.insertBefore = function(name2, attributes, text) {
        var child, i2, newChild, refChild, removed;
        if (name2 != null ? name2.type : undefined) {
          newChild = name2;
          refChild = attributes;
          newChild.setParent(this);
          if (refChild) {
            i2 = children.indexOf(refChild);
            removed = children.splice(i2);
            children.push(newChild);
            Array.prototype.push.apply(children, removed);
          } else {
            children.push(newChild);
          }
          return newChild;
        } else {
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name2));
          }
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.element(name2, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        }
      };
      XMLNode2.prototype.insertAfter = function(name2, attributes, text) {
        var child, i2, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name2));
        }
        i2 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i2 + 1);
        child = this.parent.element(name2, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.remove = function() {
        var i2, ref2;
        if (this.isRoot) {
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        }
        i2 = this.parent.children.indexOf(this);
        [].splice.apply(this.parent.children, [i2, i2 - i2 + 1].concat(ref2 = []));
        return this.parent;
      };
      XMLNode2.prototype.node = function(name2, attributes, text) {
        var child, ref2;
        if (name2 != null) {
          name2 = getValue(name2);
        }
        attributes || (attributes = {});
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
        }
        child = new XMLElement(this, name2, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.text = function(value2) {
        var child;
        if (isObject(value2)) {
          this.element(value2);
        }
        child = new XMLText(this, value2);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.cdata = function(value2) {
        var child;
        child = new XMLCData(this, value2);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.comment = function(value2) {
        var child;
        child = new XMLComment(this, value2);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.commentBefore = function(value2) {
        var child, i2, removed;
        i2 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i2);
        child = this.parent.comment(value2);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.commentAfter = function(value2) {
        var child, i2, removed;
        i2 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i2 + 1);
        child = this.parent.comment(value2);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.raw = function(value2) {
        var child;
        child = new XMLRaw(this, value2);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.dummy = function() {
        var child;
        child = new XMLDummy(this);
        return child;
      };
      XMLNode2.prototype.instruction = function(target, value2) {
        var insTarget, insValue, instruction, j, len;
        if (target != null) {
          target = getValue(target);
        }
        if (value2 != null) {
          value2 = getValue(value2);
        }
        if (Array.isArray(target)) {
          for (j = 0, len = target.length;j < len; j++) {
            insTarget = target[j];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget))
              continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value2)) {
            value2 = value2.apply();
          }
          instruction = new XMLProcessingInstruction(this, target, value2);
          this.children.push(instruction);
        }
        return this;
      };
      XMLNode2.prototype.instructionBefore = function(target, value2) {
        var child, i2, removed;
        i2 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i2);
        child = this.parent.instruction(target, value2);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.instructionAfter = function(target, value2) {
        var child, i2, removed;
        i2 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i2 + 1);
        child = this.parent.instruction(target, value2);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.declaration = function(version, encoding, standalone) {
        var doc, xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration(doc, version, encoding, standalone);
        if (doc.children.length === 0) {
          doc.children.unshift(xmldec);
        } else if (doc.children[0].type === NodeType.Declaration) {
          doc.children[0] = xmldec;
        } else {
          doc.children.unshift(xmldec);
        }
        return doc.root() || doc;
      };
      XMLNode2.prototype.dtd = function(pubID, sysID) {
        var child, doc, doctype, i2, j, k, len, len1, ref2, ref3;
        doc = this.document();
        doctype = new XMLDocType(doc, pubID, sysID);
        ref2 = doc.children;
        for (i2 = j = 0, len = ref2.length;j < len; i2 = ++j) {
          child = ref2[i2];
          if (child.type === NodeType.DocType) {
            doc.children[i2] = doctype;
            return doctype;
          }
        }
        ref3 = doc.children;
        for (i2 = k = 0, len1 = ref3.length;k < len1; i2 = ++k) {
          child = ref3[i2];
          if (child.isRoot) {
            doc.children.splice(i2, 0, doctype);
            return doctype;
          }
        }
        doc.children.push(doctype);
        return doctype;
      };
      XMLNode2.prototype.up = function() {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }
        return this.parent;
      };
      XMLNode2.prototype.root = function() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node.rootObject;
          } else if (node.isRoot) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.document = function() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.end = function(options) {
        return this.document().end(options);
      };
      XMLNode2.prototype.prev = function() {
        var i2;
        i2 = this.parent.children.indexOf(this);
        if (i2 < 1) {
          throw new Error("Already at the first node. " + this.debugInfo());
        }
        return this.parent.children[i2 - 1];
      };
      XMLNode2.prototype.next = function() {
        var i2;
        i2 = this.parent.children.indexOf(this);
        if (i2 === -1 || i2 === this.parent.children.length - 1) {
          throw new Error("Already at the last node. " + this.debugInfo());
        }
        return this.parent.children[i2 + 1];
      };
      XMLNode2.prototype.importDocument = function(doc) {
        var clonedRoot;
        clonedRoot = doc.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };
      XMLNode2.prototype.debugInfo = function(name2) {
        var ref2, ref3;
        name2 = name2 || this.name;
        if (name2 == null && !((ref2 = this.parent) != null ? ref2.name : undefined)) {
          return "";
        } else if (name2 == null) {
          return "parent: <" + this.parent.name + ">";
        } else if (!((ref3 = this.parent) != null ? ref3.name : undefined)) {
          return "node: <" + name2 + ">";
        } else {
          return "node: <" + name2 + ">, parent: <" + this.parent.name + ">";
        }
      };
      XMLNode2.prototype.ele = function(name2, attributes, text) {
        return this.element(name2, attributes, text);
      };
      XMLNode2.prototype.nod = function(name2, attributes, text) {
        return this.node(name2, attributes, text);
      };
      XMLNode2.prototype.txt = function(value2) {
        return this.text(value2);
      };
      XMLNode2.prototype.dat = function(value2) {
        return this.cdata(value2);
      };
      XMLNode2.prototype.com = function(value2) {
        return this.comment(value2);
      };
      XMLNode2.prototype.ins = function(target, value2) {
        return this.instruction(target, value2);
      };
      XMLNode2.prototype.doc = function() {
        return this.document();
      };
      XMLNode2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLNode2.prototype.e = function(name2, attributes, text) {
        return this.element(name2, attributes, text);
      };
      XMLNode2.prototype.n = function(name2, attributes, text) {
        return this.node(name2, attributes, text);
      };
      XMLNode2.prototype.t = function(value2) {
        return this.text(value2);
      };
      XMLNode2.prototype.d = function(value2) {
        return this.cdata(value2);
      };
      XMLNode2.prototype.c = function(value2) {
        return this.comment(value2);
      };
      XMLNode2.prototype.r = function(value2) {
        return this.raw(value2);
      };
      XMLNode2.prototype.i = function(target, value2) {
        return this.instruction(target, value2);
      };
      XMLNode2.prototype.u = function() {
        return this.up();
      };
      XMLNode2.prototype.importXMLBuilder = function(doc) {
        return this.importDocument(doc);
      };
      XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.removeChild = function(oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.appendChild = function(newChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.hasChildNodes = function() {
        return this.children.length !== 0;
      };
      XMLNode2.prototype.cloneNode = function(deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.normalize = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isSupported = function(feature, version) {
        return true;
      };
      XMLNode2.prototype.hasAttributes = function() {
        return this.attribs.length !== 0;
      };
      XMLNode2.prototype.compareDocumentPosition = function(other) {
        var ref, res;
        ref = this;
        if (ref === other) {
          return 0;
        } else if (this.document() !== other.document()) {
          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
          if (Math.random() < 0.5) {
            res |= DocumentPosition.Preceding;
          } else {
            res |= DocumentPosition.Following;
          }
          return res;
        } else if (ref.isAncestor(other)) {
          return DocumentPosition.Contains | DocumentPosition.Preceding;
        } else if (ref.isDescendant(other)) {
          return DocumentPosition.Contains | DocumentPosition.Following;
        } else if (ref.isPreceding(other)) {
          return DocumentPosition.Preceding;
        } else {
          return DocumentPosition.Following;
        }
      };
      XMLNode2.prototype.isSameNode = function(other) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isEqualNode = function(node) {
        var i2, j, ref2;
        if (node.nodeType !== this.nodeType) {
          return false;
        }
        if (node.children.length !== this.children.length) {
          return false;
        }
        for (i2 = j = 0, ref2 = this.children.length - 1;0 <= ref2 ? j <= ref2 : j >= ref2; i2 = 0 <= ref2 ? ++j : --j) {
          if (!this.children[i2].isEqualNode(node.children[i2])) {
            return false;
          }
        }
        return true;
      };
      XMLNode2.prototype.getFeature = function(feature, version) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.setUserData = function(key, data2, handler) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.getUserData = function(key) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.contains = function(other) {
        if (!other) {
          return false;
        }
        return other === this || this.isDescendant(other);
      };
      XMLNode2.prototype.isDescendant = function(node) {
        var child, isDescendantChild, j, len, ref2;
        ref2 = this.children;
        for (j = 0, len = ref2.length;j < len; j++) {
          child = ref2[j];
          if (node === child) {
            return true;
          }
          isDescendantChild = child.isDescendant(node);
          if (isDescendantChild) {
            return true;
          }
        }
        return false;
      };
      XMLNode2.prototype.isAncestor = function(node) {
        return node.isDescendant(this);
      };
      XMLNode2.prototype.isPreceding = function(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos < thisPos;
        }
      };
      XMLNode2.prototype.isFollowing = function(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos > thisPos;
        }
      };
      XMLNode2.prototype.treePosition = function(node) {
        var found, pos;
        pos = 0;
        found = false;
        this.foreachTreeNode(this.document(), function(childNode) {
          pos++;
          if (!found && childNode === node) {
            return found = true;
          }
        });
        if (found) {
          return pos;
        } else {
          return -1;
        }
      };
      XMLNode2.prototype.foreachTreeNode = function(node, func) {
        var child, j, len, ref2, res;
        node || (node = this.document());
        ref2 = node.children;
        for (j = 0, len = ref2.length;j < len; j++) {
          child = ref2[j];
          if (res = func(child)) {
            return res;
          } else {
            res = this.foreachTreeNode(child, func);
            if (res) {
              return res;
            }
          }
        }
      };
      return XMLNode2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS((exports, module) => {
  (function() {
    var XMLStringifier, bind = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, hasProp = {}.hasOwnProperty;
    module.exports = XMLStringifier = function() {
      function XMLStringifier2(options) {
        this.assertLegalName = bind(this.assertLegalName, this);
        this.assertLegalChar = bind(this.assertLegalChar, this);
        var key, ref, value2;
        options || (options = {});
        this.options = options;
        if (!this.options.version) {
          this.options.version = "1.0";
        }
        ref = options.stringify || {};
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value2 = ref[key];
          this[key] = value2;
        }
      }
      XMLStringifier2.prototype.name = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalName("" + val || "");
      };
      XMLStringifier2.prototype.text = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.textEscape("" + val || ""));
      };
      XMLStringifier2.prototype.cdata = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        val = val.replace("]]>", "]]]]><![CDATA[>");
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.comment = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (val.match(/--/)) {
          throw new Error("Comment text cannot contain double-hypen: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.raw = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return "" + val || "";
      };
      XMLStringifier2.prototype.attValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.attEscape(val = "" + val || ""));
      };
      XMLStringifier2.prototype.insTarget = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.insValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (val.match(/\?>/)) {
          throw new Error("Invalid processing instruction value: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlVersion = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (!val.match(/1\.[0-9]+/)) {
          throw new Error("Invalid version number: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlEncoding = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error("Invalid encoding: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlStandalone = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        if (val) {
          return "yes";
        } else {
          return "no";
        }
      };
      XMLStringifier2.prototype.dtdPubID = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdSysID = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdElementValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdAttType = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdAttDefault = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdEntityValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdNData = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.convertAttKey = "@";
      XMLStringifier2.prototype.convertPIKey = "?";
      XMLStringifier2.prototype.convertTextKey = "#text";
      XMLStringifier2.prototype.convertCDataKey = "#cdata";
      XMLStringifier2.prototype.convertCommentKey = "#comment";
      XMLStringifier2.prototype.convertRawKey = "#raw";
      XMLStringifier2.prototype.assertLegalChar = function(str) {
        var regex, res;
        if (this.options.noValidation) {
          return str;
        }
        regex = "";
        if (this.options.version === "1.0") {
          regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        } else if (this.options.version === "1.1") {
          regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        }
        return str;
      };
      XMLStringifier2.prototype.assertLegalName = function(str) {
        var regex;
        if (this.options.noValidation) {
          return str;
        }
        this.assertLegalChar(str);
        regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
        if (!str.match(regex)) {
          throw new Error("Invalid character in name");
        }
        return str;
      };
      XMLStringifier2.prototype.textEscape = function(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      };
      XMLStringifier2.prototype.attEscape = function(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      };
      return XMLStringifier2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS((exports, module) => {
  (function() {
    module.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
    assign = require_Utility().assign;
    NodeType = require_NodeType();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLElement = require_XMLElement();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDummy = require_XMLDummy();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDNotation = require_XMLDTDNotation();
    WriterState = require_WriterState();
    module.exports = XMLWriterBase = function() {
      function XMLWriterBase2(options) {
        var key, ref, value2;
        options || (options = {});
        this.options = options;
        ref = options.writer || {};
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value2 = ref[key];
          this["_" + key] = this[key];
          this[key] = value2;
        }
      }
      XMLWriterBase2.prototype.filterOptions = function(options) {
        var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
        options || (options = {});
        options = assign({}, this.options, options);
        filteredOptions = {
          writer: this
        };
        filteredOptions.pretty = options.pretty || false;
        filteredOptions.allowEmpty = options.allowEmpty || false;
        filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
        filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
        filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
        filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
        filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
        if (filteredOptions.spaceBeforeSlash === true) {
          filteredOptions.spaceBeforeSlash = " ";
        }
        filteredOptions.suppressPrettyCount = 0;
        filteredOptions.user = {};
        filteredOptions.state = WriterState.None;
        return filteredOptions;
      };
      XMLWriterBase2.prototype.indent = function(node, options, level) {
        var indentLevel;
        if (!options.pretty || options.suppressPrettyCount) {
          return "";
        } else if (options.pretty) {
          indentLevel = (level || 0) + options.offset + 1;
          if (indentLevel > 0) {
            return new Array(indentLevel).join(options.indent);
          }
        }
        return "";
      };
      XMLWriterBase2.prototype.endline = function(node, options, level) {
        if (!options.pretty || options.suppressPrettyCount) {
          return "";
        } else {
          return options.newline;
        }
      };
      XMLWriterBase2.prototype.attribute = function(att, options, level) {
        var r;
        this.openAttribute(att, options, level);
        r = " " + att.name + '="' + att.value + '"';
        this.closeAttribute(att, options, level);
        return r;
      };
      XMLWriterBase2.prototype.cdata = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<![CDATA[";
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += "]]>" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.comment = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!-- ";
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += " -->" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.declaration = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<?xml";
        options.state = WriterState.InsideTag;
        r += ' version="' + node.version + '"';
        if (node.encoding != null) {
          r += ' encoding="' + node.encoding + '"';
        }
        if (node.standalone != null) {
          r += ' standalone="' + node.standalone + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + "?>";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.docType = function(node, options, level) {
        var child, i2, len, r, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        r += "<!DOCTYPE " + node.root().name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.children.length > 0) {
          r += " [";
          r += this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref = node.children;
          for (i2 = 0, len = ref.length;i2 < len; i2++) {
            child = ref[i2];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += "]";
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, i2, j, len, len1, name2, prettySuppressed, r, ref, ref1, ref2;
        level || (level = 0);
        prettySuppressed = false;
        r = "";
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r += this.indent(node, options, level) + "<" + node.name;
        ref = node.attribs;
        for (name2 in ref) {
          if (!hasProp.call(ref, name2))
            continue;
          att = ref[name2];
          r += this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        })) {
          if (options.allowEmpty) {
            r += ">";
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
          r += ">";
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          r += this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          r += "</" + node.name + ">" + this.endline(node, options, level);
        } else {
          if (options.dontPrettyTextNodes) {
            ref1 = node.children;
            for (i2 = 0, len = ref1.length;i2 < len; i2++) {
              child = ref1[i2];
              if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                options.suppressPrettyCount++;
                prettySuppressed = true;
                break;
              }
            }
          }
          r += ">" + this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref2 = node.children;
          for (j = 0, len1 = ref2.length;j < len1; j++) {
            child = ref2[j];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += this.indent(node, options, level) + "</" + node.name + ">";
          if (prettySuppressed) {
            options.suppressPrettyCount--;
          }
          r += this.endline(node, options, level);
          options.state = WriterState.None;
        }
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
        switch (node.type) {
          case NodeType.CData:
            return this.cdata(node, options, level);
          case NodeType.Comment:
            return this.comment(node, options, level);
          case NodeType.Element:
            return this.element(node, options, level);
          case NodeType.Raw:
            return this.raw(node, options, level);
          case NodeType.Text:
            return this.text(node, options, level);
          case NodeType.ProcessingInstruction:
            return this.processingInstruction(node, options, level);
          case NodeType.Dummy:
            return "";
          case NodeType.Declaration:
            return this.declaration(node, options, level);
          case NodeType.DocType:
            return this.docType(node, options, level);
          case NodeType.AttributeDeclaration:
            return this.dtdAttList(node, options, level);
          case NodeType.ElementDeclaration:
            return this.dtdElement(node, options, level);
          case NodeType.EntityDeclaration:
            return this.dtdEntity(node, options, level);
          case NodeType.NotationDeclaration:
            return this.dtdNotation(node, options, level);
          default:
            throw new Error("Unknown XML node type: " + node.constructor.name);
        }
      };
      XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<?";
        options.state = WriterState.InsideTag;
        r += node.target;
        if (node.value) {
          r += " " + node.value;
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + "?>";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.raw = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.text = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ATTLIST";
        options.state = WriterState.InsideTag;
        r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
        if (node.defaultValueType !== "#DEFAULT") {
          r += " " + node.defaultValueType;
        }
        if (node.defaultValue) {
          r += ' "' + node.defaultValue + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ELEMENT";
        options.state = WriterState.InsideTag;
        r += " " + node.name + " " + node.value;
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ENTITY";
        options.state = WriterState.InsideTag;
        if (node.pe) {
          r += " %";
        }
        r += " " + node.name;
        if (node.value) {
          r += ' "' + node.value + '"';
        } else {
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.nData) {
            r += " NDATA " + node.nData;
          }
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!NOTATION";
        options.state = WriterState.InsideTag;
        r += " " + node.name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.pubID) {
          r += ' PUBLIC "' + node.pubID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.openNode = function(node, options, level) {
      };
      XMLWriterBase2.prototype.closeNode = function(node, options, level) {
      };
      XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
      };
      XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
      };
      return XMLWriterBase2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS((exports, module) => {
  (function() {
    var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLWriterBase = require_XMLWriterBase();
    module.exports = XMLStringWriter = function(superClass) {
      extend(XMLStringWriter2, superClass);
      function XMLStringWriter2(options) {
        XMLStringWriter2.__super__.constructor.call(this, options);
      }
      XMLStringWriter2.prototype.document = function(doc, options) {
        var child, i2, len, r, ref;
        options = this.filterOptions(options);
        r = "";
        ref = doc.children;
        for (i2 = 0, len = ref.length;i2 < len; i2++) {
          child = ref[i2];
          r += this.writeChildNode(child, options, 0);
        }
        if (options.pretty && r.slice(-options.newline.length) === options.newline) {
          r = r.slice(0, -options.newline.length);
        }
        return r;
      };
      return XMLStringWriter2;
    }(XMLWriterBase);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isPlainObject = require_Utility().isPlainObject;
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDOMConfiguration = require_XMLDOMConfiguration();
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    module.exports = XMLDocument = function(superClass) {
      extend(XMLDocument2, superClass);
      function XMLDocument2(options) {
        XMLDocument2.__super__.constructor.call(this, null);
        this.name = "#document";
        this.type = NodeType.Document;
        this.documentURI = null;
        this.domConfig = new XMLDOMConfiguration;
        options || (options = {});
        if (!options.writer) {
          options.writer = new XMLStringWriter;
        }
        this.options = options;
        this.stringify = new XMLStringifier(options);
      }
      Object.defineProperty(XMLDocument2.prototype, "implementation", {
        value: new XMLDOMImplementation
      });
      Object.defineProperty(XMLDocument2.prototype, "doctype", {
        get: function() {
          var child, i2, len, ref;
          ref = this.children;
          for (i2 = 0, len = ref.length;i2 < len; i2++) {
            child = ref[i2];
            if (child.type === NodeType.DocType) {
              return child;
            }
          }
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
        get: function() {
          return false;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].encoding;
          } else {
            return null;
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].standalone === "yes";
          } else {
            return false;
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].version;
          } else {
            return "1.0";
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "origin", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "compatMode", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "characterSet", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "contentType", {
        get: function() {
          return null;
        }
      });
      XMLDocument2.prototype.end = function(writer) {
        var writerOptions;
        writerOptions = {};
        if (!writer) {
          writer = this.options.writer;
        } else if (isPlainObject(writer)) {
          writerOptions = writer;
          writer = this.options.writer;
        }
        return writer.document(this, writer.filterOptions(writerOptions));
      };
      XMLDocument2.prototype.toString = function(options) {
        return this.options.writer.document(this, this.options.writer.filterOptions(options));
      };
      XMLDocument2.prototype.createElement = function(tagName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createDocumentFragment = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createTextNode = function(data2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createComment = function(data2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createCDATASection = function(data2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createProcessingInstruction = function(target, data2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createAttribute = function(name2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createEntityReference = function(name2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.importNode = function(importedNode, deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementById = function(elementId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.adoptNode = function(source) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.normalizeDocument = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createEvent = function(eventInterface) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createRange = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      return XMLDocument2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
    ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
    NodeType = require_NodeType();
    XMLDocument = require_XMLDocument();
    XMLElement = require_XMLElement();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLAttribute = require_XMLAttribute();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    WriterState = require_WriterState();
    module.exports = XMLDocumentCB = function() {
      function XMLDocumentCB2(options, onData, onEnd) {
        var writerOptions;
        this.name = "?xml";
        this.type = NodeType.Document;
        options || (options = {});
        writerOptions = {};
        if (!options.writer) {
          options.writer = new XMLStringWriter;
        } else if (isPlainObject(options.writer)) {
          writerOptions = options.writer;
          options.writer = new XMLStringWriter;
        }
        this.options = options;
        this.writer = options.writer;
        this.writerOptions = this.writer.filterOptions(writerOptions);
        this.stringify = new XMLStringifier(options);
        this.onDataCallback = onData || function() {
        };
        this.onEndCallback = onEnd || function() {
        };
        this.currentNode = null;
        this.currentLevel = -1;
        this.openTags = {};
        this.documentStarted = false;
        this.documentCompleted = false;
        this.root = null;
      }
      XMLDocumentCB2.prototype.createChildNode = function(node) {
        var att, attName, attributes, child, i2, len, ref1, ref2;
        switch (node.type) {
          case NodeType.CData:
            this.cdata(node.value);
            break;
          case NodeType.Comment:
            this.comment(node.value);
            break;
          case NodeType.Element:
            attributes = {};
            ref1 = node.attribs;
            for (attName in ref1) {
              if (!hasProp.call(ref1, attName))
                continue;
              att = ref1[attName];
              attributes[attName] = att.value;
            }
            this.node(node.name, attributes);
            break;
          case NodeType.Dummy:
            this.dummy();
            break;
          case NodeType.Raw:
            this.raw(node.value);
            break;
          case NodeType.Text:
            this.text(node.value);
            break;
          case NodeType.ProcessingInstruction:
            this.instruction(node.target, node.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
        }
        ref2 = node.children;
        for (i2 = 0, len = ref2.length;i2 < len; i2++) {
          child = ref2[i2];
          this.createChildNode(child);
          if (child.type === NodeType.Element) {
            this.up();
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.dummy = function() {
        return this;
      };
      XMLDocumentCB2.prototype.node = function(name2, attributes, text) {
        var ref1;
        if (name2 == null) {
          throw new Error("Missing node name.");
        }
        if (this.root && this.currentLevel === -1) {
          throw new Error("Document can only have one root node. " + this.debugInfo(name2));
        }
        this.openCurrent();
        name2 = getValue(name2);
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
        }
        this.currentNode = new XMLElement(this, name2, attributes);
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        if (text != null) {
          this.text(text);
        }
        return this;
      };
      XMLDocumentCB2.prototype.element = function(name2, attributes, text) {
        var child, i2, len, oldValidationFlag, ref1, root;
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          this.dtdElement.apply(this, arguments);
        } else {
          if (Array.isArray(name2) || isObject(name2) || isFunction(name2)) {
            oldValidationFlag = this.options.noValidation;
            this.options.noValidation = true;
            root = new XMLDocument(this.options).element("TEMP_ROOT");
            root.element(name2);
            this.options.noValidation = oldValidationFlag;
            ref1 = root.children;
            for (i2 = 0, len = ref1.length;i2 < len; i2++) {
              child = ref1[i2];
              this.createChildNode(child);
              if (child.type === NodeType.Element) {
                this.up();
              }
            }
          } else {
            this.node(name2, attributes, text);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.attribute = function(name2, value2) {
        var attName, attValue;
        if (!this.currentNode || this.currentNode.children) {
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name2));
        }
        if (name2 != null) {
          name2 = getValue(name2);
        }
        if (isObject(name2)) {
          for (attName in name2) {
            if (!hasProp.call(name2, attName))
              continue;
            attValue = name2[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value2)) {
            value2 = value2.apply();
          }
          if (this.options.keepNullAttributes && value2 == null) {
            this.currentNode.attribs[name2] = new XMLAttribute(this, name2, "");
          } else if (value2 != null) {
            this.currentNode.attribs[name2] = new XMLAttribute(this, name2, value2);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.text = function(value2) {
        var node;
        this.openCurrent();
        node = new XMLText(this, value2);
        this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.cdata = function(value2) {
        var node;
        this.openCurrent();
        node = new XMLCData(this, value2);
        this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.comment = function(value2) {
        var node;
        this.openCurrent();
        node = new XMLComment(this, value2);
        this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.raw = function(value2) {
        var node;
        this.openCurrent();
        node = new XMLRaw(this, value2);
        this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.instruction = function(target, value2) {
        var i2, insTarget, insValue, len, node;
        this.openCurrent();
        if (target != null) {
          target = getValue(target);
        }
        if (value2 != null) {
          value2 = getValue(value2);
        }
        if (Array.isArray(target)) {
          for (i2 = 0, len = target.length;i2 < len; i2++) {
            insTarget = target[i2];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget))
              continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value2)) {
            value2 = value2.apply();
          }
          node = new XMLProcessingInstruction(this, target, value2);
          this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        }
        return this;
      };
      XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
        var node;
        this.openCurrent();
        if (this.documentStarted) {
          throw new Error("declaration() must be the first node.");
        }
        node = new XMLDeclaration(this, version, encoding, standalone);
        this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
        this.openCurrent();
        if (root == null) {
          throw new Error("Missing root node name.");
        }
        if (this.root) {
          throw new Error("dtd() must come before the root node.");
        }
        this.currentNode = new XMLDocType(this, pubID, sysID);
        this.currentNode.rootNodeName = root;
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        return this;
      };
      XMLDocumentCB2.prototype.dtdElement = function(name2, value2) {
        var node;
        this.openCurrent();
        node = new XMLDTDElement(this, name2, value2);
        this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var node;
        this.openCurrent();
        node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.entity = function(name2, value2) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, false, name2, value2);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.pEntity = function(name2, value2) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, true, name2, value2);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.notation = function(name2, value2) {
        var node;
        this.openCurrent();
        node = new XMLDTDNotation(this, name2, value2);
        this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.up = function() {
        if (this.currentLevel < 0) {
          throw new Error("The document node has no parent.");
        }
        if (this.currentNode) {
          if (this.currentNode.children) {
            this.closeNode(this.currentNode);
          } else {
            this.openNode(this.currentNode);
          }
          this.currentNode = null;
        } else {
          this.closeNode(this.openTags[this.currentLevel]);
        }
        delete this.openTags[this.currentLevel];
        this.currentLevel--;
        return this;
      };
      XMLDocumentCB2.prototype.end = function() {
        while (this.currentLevel >= 0) {
          this.up();
        }
        return this.onEnd();
      };
      XMLDocumentCB2.prototype.openCurrent = function() {
        if (this.currentNode) {
          this.currentNode.children = true;
          return this.openNode(this.currentNode);
        }
      };
      XMLDocumentCB2.prototype.openNode = function(node) {
        var att, chunk, name2, ref1;
        if (!node.isOpen) {
          if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
            this.root = node;
          }
          chunk = "";
          if (node.type === NodeType.Element) {
            this.writerOptions.state = WriterState.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
            ref1 = node.attribs;
            for (name2 in ref1) {
              if (!hasProp.call(ref1, name2))
                continue;
              att = ref1[name2];
              chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
            }
            chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
            this.writerOptions.state = WriterState.InsideTag;
          } else {
            this.writerOptions.state = WriterState.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
            if (node.pubID && node.sysID) {
              chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              chunk += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.children) {
              chunk += " [";
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.CloseTag;
              chunk += ">";
            }
            chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
          }
          this.onData(chunk, this.currentLevel);
          return node.isOpen = true;
        }
      };
      XMLDocumentCB2.prototype.closeNode = function(node) {
        var chunk;
        if (!node.isClosed) {
          chunk = "";
          this.writerOptions.state = WriterState.CloseTag;
          if (node.type === NodeType.Element) {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
          } else {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
          }
          this.writerOptions.state = WriterState.None;
          this.onData(chunk, this.currentLevel);
          return node.isClosed = true;
        }
      };
      XMLDocumentCB2.prototype.onData = function(chunk, level) {
        this.documentStarted = true;
        return this.onDataCallback(chunk, level + 1);
      };
      XMLDocumentCB2.prototype.onEnd = function() {
        this.documentCompleted = true;
        return this.onEndCallback();
      };
      XMLDocumentCB2.prototype.debugInfo = function(name2) {
        if (name2 == null) {
          return "";
        } else {
          return "node: <" + name2 + ">";
        }
      };
      XMLDocumentCB2.prototype.ele = function() {
        return this.element.apply(this, arguments);
      };
      XMLDocumentCB2.prototype.nod = function(name2, attributes, text) {
        return this.node(name2, attributes, text);
      };
      XMLDocumentCB2.prototype.txt = function(value2) {
        return this.text(value2);
      };
      XMLDocumentCB2.prototype.dat = function(value2) {
        return this.cdata(value2);
      };
      XMLDocumentCB2.prototype.com = function(value2) {
        return this.comment(value2);
      };
      XMLDocumentCB2.prototype.ins = function(target, value2) {
        return this.instruction(target, value2);
      };
      XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
        return this.doctype(root, pubID, sysID);
      };
      XMLDocumentCB2.prototype.e = function(name2, attributes, text) {
        return this.element(name2, attributes, text);
      };
      XMLDocumentCB2.prototype.n = function(name2, attributes, text) {
        return this.node(name2, attributes, text);
      };
      XMLDocumentCB2.prototype.t = function(value2) {
        return this.text(value2);
      };
      XMLDocumentCB2.prototype.d = function(value2) {
        return this.cdata(value2);
      };
      XMLDocumentCB2.prototype.c = function(value2) {
        return this.comment(value2);
      };
      XMLDocumentCB2.prototype.r = function(value2) {
        return this.raw(value2);
      };
      XMLDocumentCB2.prototype.i = function(target, value2) {
        return this.instruction(target, value2);
      };
      XMLDocumentCB2.prototype.att = function() {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.a = function() {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.ent = function(name2, value2) {
        return this.entity(name2, value2);
      };
      XMLDocumentCB2.prototype.pent = function(name2, value2) {
        return this.pEntity(name2, value2);
      };
      XMLDocumentCB2.prototype.not = function(name2, value2) {
        return this.notation(name2, value2);
      };
      return XMLDocumentCB2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLWriterBase = require_XMLWriterBase();
    WriterState = require_WriterState();
    module.exports = XMLStreamWriter = function(superClass) {
      extend(XMLStreamWriter2, superClass);
      function XMLStreamWriter2(stream2, options) {
        this.stream = stream2;
        XMLStreamWriter2.__super__.constructor.call(this, options);
      }
      XMLStreamWriter2.prototype.endline = function(node, options, level) {
        if (node.isLastRootNode && options.state === WriterState.CloseTag) {
          return "";
        } else {
          return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
        }
      };
      XMLStreamWriter2.prototype.document = function(doc, options) {
        var child, i2, j, k, len, len1, ref, ref1, results;
        ref = doc.children;
        for (i2 = j = 0, len = ref.length;j < len; i2 = ++j) {
          child = ref[i2];
          child.isLastRootNode = i2 === doc.children.length - 1;
        }
        options = this.filterOptions(options);
        ref1 = doc.children;
        results = [];
        for (k = 0, len1 = ref1.length;k < len1; k++) {
          child = ref1[k];
          results.push(this.writeChildNode(child, options, 0));
        }
        return results;
      };
      XMLStreamWriter2.prototype.attribute = function(att, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
      };
      XMLStreamWriter2.prototype.cdata = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.comment = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.declaration = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.docType = function(node, options, level) {
        var child, j, len, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level));
        this.stream.write("<!DOCTYPE " + node.root().name);
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.children.length > 0) {
          this.stream.write(" [");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref = node.children;
          for (j = 0, len = ref.length;j < len; j++) {
            child = ref[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write("]");
        }
        options.state = WriterState.CloseTag;
        this.stream.write(options.spaceBeforeSlash + ">");
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, j, len, name2, prettySuppressed, ref, ref1;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level) + "<" + node.name);
        ref = node.attribs;
        for (name2 in ref) {
          if (!hasProp.call(ref, name2))
            continue;
          att = ref[name2];
          this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        })) {
          if (options.allowEmpty) {
            this.stream.write(">");
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + "/>");
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
          this.stream.write(">");
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          this.stream.write("</" + node.name + ">");
        } else {
          this.stream.write(">" + this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref1 = node.children;
          for (j = 0, len = ref1.length;j < len; j++) {
            child = ref1[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
        }
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.raw = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.text = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
      };
      return XMLStreamWriter2;
    }(XMLWriterBase);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
    ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDocument = require_XMLDocument();
    XMLDocumentCB = require_XMLDocumentCB();
    XMLStringWriter = require_XMLStringWriter();
    XMLStreamWriter = require_XMLStreamWriter();
    NodeType = require_NodeType();
    WriterState = require_WriterState();
    exports.create = function(name2, xmldec, doctype, options) {
      var doc, root;
      if (name2 == null) {
        throw new Error("Root element needs a name.");
      }
      options = assign({}, xmldec, doctype, options);
      doc = new XMLDocument(options);
      root = doc.element(name2);
      if (!options.headless) {
        doc.declaration(options);
        if (options.pubID != null || options.sysID != null) {
          doc.dtd(options);
        }
      }
      return root;
    };
    exports.begin = function(options, onData, onEnd) {
      var ref1;
      if (isFunction(options)) {
        ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
        options = {};
      }
      if (onData) {
        return new XMLDocumentCB(options, onData, onEnd);
      } else {
        return new XMLDocument(options);
      }
    };
    exports.stringWriter = function(options) {
      return new XMLStringWriter(options);
    };
    exports.streamWriter = function(stream2, options) {
      return new XMLStreamWriter(stream2, options);
    };
    exports.implementation = new XMLDOMImplementation;
    exports.nodeType = NodeType;
    exports.writerState = WriterState;
  }).call(exports);
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS((exports) => {
  (function() {
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = require_lib4();
    defaults = require_defaults().defaults;
    requiresCDATA = function(entry) {
      return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
    };
    wrapCDATA = function(entry) {
      return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
      return entry.replace("]]>", "]]]]><![CDATA[>");
    };
    exports.Builder = function() {
      function Builder(opts) {
        var key, ref, value2;
        this.options = {};
        ref = defaults["0.2"];
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value2 = ref[key];
          this.options[key] = value2;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key))
            continue;
          value2 = opts[key];
          this.options[key] = value2;
        }
      }
      Builder.prototype.buildObject = function(rootObj) {
        var attrkey, charkey, render, rootElement, rootName;
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
          rootName = Object.keys(rootObj)[0];
          rootObj = rootObj[rootName];
        } else {
          rootName = this.options.rootName;
        }
        render = function(_this) {
          return function(element, obj) {
            var attr, child, entry, index, key, value2;
            if (typeof obj !== "object") {
              if (_this.options.cdata && requiresCDATA(obj)) {
                element.raw(wrapCDATA(obj));
              } else {
                element.txt(obj);
              }
            } else if (Array.isArray(obj)) {
              for (index in obj) {
                if (!hasProp.call(obj, index))
                  continue;
                child = obj[index];
                for (key in child) {
                  entry = child[key];
                  element = render(element.ele(key), entry).up();
                }
              }
            } else {
              for (key in obj) {
                if (!hasProp.call(obj, key))
                  continue;
                child = obj[key];
                if (key === attrkey) {
                  if (typeof child === "object") {
                    for (attr in child) {
                      value2 = child[attr];
                      element = element.att(attr, value2);
                    }
                  }
                } else if (key === charkey) {
                  if (_this.options.cdata && requiresCDATA(child)) {
                    element = element.raw(wrapCDATA(child));
                  } else {
                    element = element.txt(child);
                  }
                } else if (Array.isArray(child)) {
                  for (index in child) {
                    if (!hasProp.call(child, index))
                      continue;
                    entry = child[index];
                    if (typeof entry === "string") {
                      if (_this.options.cdata && requiresCDATA(entry)) {
                        element = element.ele(key).raw(wrapCDATA(entry)).up();
                      } else {
                        element = element.ele(key, entry).up();
                      }
                    } else {
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else if (typeof child === "object") {
                  element = render(element.ele(key), child).up();
                } else {
                  if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                    element = element.ele(key).raw(wrapCDATA(child)).up();
                  } else {
                    if (child == null) {
                      child = "";
                    }
                    element = element.ele(key, child.toString()).up();
                  }
                }
              }
            }
            return element;
          };
        }(this);
        rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        });
        return render(rootElement, rootObj).end(this.options.renderOpts);
      };
      return Builder;
    }();
  }).call(exports);
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS((exports) => {
  (function(sax) {
    sax.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F;
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i2 in o)
          if (o.hasOwnProperty(i2))
            a.push(i2);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i2 = 0, l = buffers.length;i2 < l; i2++) {
        var len = parser[buffers[i2]].length;
        if (len > maxAllowed) {
          switch (buffers[i2]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i2]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i2 = 0, l = buffers.length;i2 < l; i2++) {
        parser[buffers[i2]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream;
    try {
      Stream = import.meta.require("stream").Stream;
    } catch (ex) {
      Stream = function() {
      };
    }
    if (!Stream)
      Stream = function() {
      };
    var streamWraps = sax.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data2) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data2)) {
        if (!this._decoder) {
          var SD = import.meta.require("string_decoder").StringDecoder;
          this._decoder = new SD("utf8");
        }
        data2 = this._decoder.write(data2);
      }
      this._parser.write(data2.toString());
      this.emit("data", data2);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c2) {
      return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "\t";
    }
    function isQuote(c2) {
      return c2 === '"' || c2 === "\'";
    }
    function isAttribEnd(c2) {
      return c2 === ">" || isWhitespace(c2);
    }
    function isMatch(regex, c2) {
      return regex.test(c2);
    }
    function notMatch(regex, c2) {
      return !isMatch(regex, c2);
    }
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
      var e = sax.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s2;
    });
    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    }
    S = sax.STATE;
    function emit(parser, event, data2) {
      parser[event] && parser[event](data2);
    }
    function emitNode(parser, nodeType, data2) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data2);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name2, attribute) {
      var i2 = name2.indexOf(":");
      var qualName = i2 < 0 ? ["", name2] : name2.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name2 === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i2 = 0, l = parser.attribList.length;i2 < l; i2++) {
          var nv = parser.attribList[i2];
          var name2 = nv[0];
          var value2 = nv[1];
          var qualName = qname(name2, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name: name2,
            value: value2,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name2] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i2 in tag.ns) {
          x[i2] = tag.ns[i2];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c2) {
      if (c2 === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c2)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c2;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i2) {
      var result = "";
      if (i2 < chunk.length) {
        result = chunk.charAt(i2);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i2 = 0;
      var c2 = "";
      while (true) {
        c2 = charAt(chunk, i2++);
        parser.c = c2;
        if (!c2) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c2 === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c2 === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c2);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c2);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i2 - 1;
              while (c2 && c2 !== "<" && c2 !== "&") {
                c2 = charAt(chunk, i2++);
                if (c2 && parser.trackPosition) {
                  parser.position++;
                  if (c2 === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i2 - 1);
            }
            if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c2) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c2 === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c2;
              }
            }
            continue;
          case S.SCRIPT:
            if (c2 === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c2;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c2 === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c2;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c2 === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c2)) {
            } else if (isMatch(nameStart, c2)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c2;
            } else if (c2 === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c2 === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c2 = new Array(pad).join(" ") + c2;
              }
              parser.textNode += "<" + c2;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c2 === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c2 === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c2)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c2;
            } else {
              parser.sgmlDecl += c2;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c2 === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c2;
            continue;
          case S.DOCTYPE:
            if (c2 === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c2;
              if (c2 === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c2)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c2;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c2;
            if (c2 === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c2;
            if (c2 === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c2)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c2;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c2;
            if (c2 === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c2 === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c2;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c2 === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c2;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c2 !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c2;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c2 === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c2;
            }
            continue;
          case S.CDATA_ENDING:
            if (c2 === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c2;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c2 === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c2 === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c2;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c2 === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c2)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c2;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c2)) {
              continue;
            } else if (c2 === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c2;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c2 === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c2;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c2)) {
              parser.tagName += c2;
            } else {
              newTag(parser);
              if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c2)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c2 === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c2)) {
              continue;
            } else if (c2 === ">") {
              openTag(parser);
            } else if (c2 === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c2)) {
              parser.attribName = c2;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c2 === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c2 === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c2)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c2)) {
              parser.attribName += c2;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c2 === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c2)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c2 === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c2)) {
                parser.attribName = c2;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c2)) {
              continue;
            } else if (isQuote(c2)) {
              parser.q = c2;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c2;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c2 !== parser.q) {
              if (c2 === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c2;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c2)) {
              parser.state = S.ATTRIB;
            } else if (c2 === ">") {
              openTag(parser);
            } else if (c2 === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c2)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c2;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c2)) {
              if (c2 === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c2;
              }
              continue;
            }
            attrib(parser);
            if (c2 === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c2)) {
                continue;
              } else if (notMatch(nameStart, c2)) {
                if (parser.script) {
                  parser.script += "</" + c2;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c2;
              }
            } else if (c2 === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c2)) {
              parser.tagName += c2;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c2)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c2)) {
              continue;
            }
            if (c2 === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c2 === ";") {
              if (parser.opt.unparsedEntities) {
                var parsedEntity = parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              }
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
              parser.entity += c2;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c2;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default: {
            throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(typeof exports === "undefined" ? exports.sax = {} : exports);
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS((exports) => {
  (function() {
    exports.stripBOM = function(str) {
      if (str[0] === "\uFEFF") {
        return str.substring(1);
      } else {
        return str;
      }
    };
  }).call(exports);
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS((exports) => {
  (function() {
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
      return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
      return str.replace(prefixMatch, "");
    };
    exports.parseNumbers = function(str) {
      if (!isNaN(str)) {
        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
      }
      return str;
    };
    exports.parseBooleans = function(str) {
      if (/^(?:true|false)$/i.test(str)) {
        str = str.toLowerCase() === "true";
      }
      return str;
    };
  }).call(exports);
});

// node_modules/xml2js/lib/parser.js
var require_parser3 = __commonJS((exports) => {
  (function() {
    var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate2, bind = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    sax = require_sax();
    events = import.meta.require("events");
    bom = require_bom();
    processors = require_processors();
    setImmediate2 = import.meta.require("timers").setImmediate;
    defaults = require_defaults().defaults;
    isEmpty = function(thing) {
      return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors2, item2, key) {
      var i2, len, process2;
      for (i2 = 0, len = processors2.length;i2 < len; i2++) {
        process2 = processors2[i2];
        item2 = process2(item2, key);
      }
      return item2;
    };
    exports.Parser = function(superClass) {
      extend(Parser, superClass);
      function Parser(opts) {
        this.parseStringPromise = bind(this.parseStringPromise, this);
        this.parseString = bind(this.parseString, this);
        this.reset = bind(this.reset, this);
        this.assignOrPush = bind(this.assignOrPush, this);
        this.processAsync = bind(this.processAsync, this);
        var key, ref, value2;
        if (!(this instanceof exports.Parser)) {
          return new exports.Parser(opts);
        }
        this.options = {};
        ref = defaults["0.2"];
        for (key in ref) {
          if (!hasProp.call(ref, key))
            continue;
          value2 = ref[key];
          this.options[key] = value2;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key))
            continue;
          value2 = opts[key];
          this.options[key] = value2;
        }
        if (this.options.xmlns) {
          this.options.xmlnskey = this.options.attrkey + "ns";
        }
        if (this.options.normalizeTags) {
          if (!this.options.tagNameProcessors) {
            this.options.tagNameProcessors = [];
          }
          this.options.tagNameProcessors.unshift(processors.normalize);
        }
        this.reset();
      }
      Parser.prototype.processAsync = function() {
        var chunk, err;
        try {
          if (this.remaining.length <= this.options.chunkSize) {
            chunk = this.remaining;
            this.remaining = "";
            this.saxParser = this.saxParser.write(chunk);
            return this.saxParser.close();
          } else {
            chunk = this.remaining.substr(0, this.options.chunkSize);
            this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
            this.saxParser = this.saxParser.write(chunk);
            return setImmediate2(this.processAsync);
          }
        } catch (error1) {
          err = error1;
          if (!this.saxParser.errThrown) {
            this.saxParser.errThrown = true;
            return this.emit(err);
          }
        }
      };
      Parser.prototype.assignOrPush = function(obj, key, newValue) {
        if (!(key in obj)) {
          if (!this.options.explicitArray) {
            return obj[key] = newValue;
          } else {
            return obj[key] = [newValue];
          }
        } else {
          if (!(obj[key] instanceof Array)) {
            obj[key] = [obj[key]];
          }
          return obj[key].push(newValue);
        }
      };
      Parser.prototype.reset = function() {
        var attrkey, charkey, ontext, stack;
        this.removeAllListeners();
        this.saxParser = sax.parser(this.options.strict, {
          trim: false,
          normalize: false,
          xmlns: this.options.xmlns
        });
        this.saxParser.errThrown = false;
        this.saxParser.onerror = function(_this) {
          return function(error) {
            _this.saxParser.resume();
            if (!_this.saxParser.errThrown) {
              _this.saxParser.errThrown = true;
              return _this.emit("error", error);
            }
          };
        }(this);
        this.saxParser.onend = function(_this) {
          return function() {
            if (!_this.saxParser.ended) {
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);
        this.saxParser.ended = false;
        this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
        this.resultObject = null;
        stack = [];
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        this.saxParser.onopentag = function(_this) {
          return function(node) {
            var key, newValue, obj, processedKey, ref;
            obj = {};
            obj[charkey] = "";
            if (!_this.options.ignoreAttrs) {
              ref = node.attributes;
              for (key in ref) {
                if (!hasProp.call(ref, key))
                  continue;
                if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                  obj[attrkey] = {};
                }
                newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                if (_this.options.mergeAttrs) {
                  _this.assignOrPush(obj, processedKey, newValue);
                } else {
                  obj[attrkey][processedKey] = newValue;
                }
              }
            }
            obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
            if (_this.options.xmlns) {
              obj[_this.options.xmlnskey] = {
                uri: node.uri,
                local: node.local
              };
            }
            return stack.push(obj);
          };
        }(this);
        this.saxParser.onclosetag = function(_this) {
          return function() {
            var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
            obj = stack.pop();
            nodeName = obj["#name"];
            if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
              delete obj["#name"];
            }
            if (obj.cdata === true) {
              cdata = obj.cdata;
              delete obj.cdata;
            }
            s = stack[stack.length - 1];
            if (obj[charkey].match(/^\s*$/) && !cdata) {
              emptyStr = obj[charkey];
              delete obj[charkey];
            } else {
              if (_this.options.trim) {
                obj[charkey] = obj[charkey].trim();
              }
              if (_this.options.normalize) {
                obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
              }
              obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
            if (isEmpty(obj)) {
              obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
            }
            if (_this.options.validator != null) {
              xpath = "/" + function() {
                var i2, len, results;
                results = [];
                for (i2 = 0, len = stack.length;i2 < len; i2++) {
                  node = stack[i2];
                  results.push(node["#name"]);
                }
                return results;
              }().concat(nodeName).join("/");
              (function() {
                var err;
                try {
                  return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                } catch (error1) {
                  err = error1;
                  return _this.emit("error", err);
                }
              })();
            }
            if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
              if (!_this.options.preserveChildrenOrder) {
                node = {};
                if (_this.options.attrkey in obj) {
                  node[_this.options.attrkey] = obj[_this.options.attrkey];
                  delete obj[_this.options.attrkey];
                }
                if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                  node[_this.options.charkey] = obj[_this.options.charkey];
                  delete obj[_this.options.charkey];
                }
                if (Object.getOwnPropertyNames(obj).length > 0) {
                  node[_this.options.childkey] = obj;
                }
                obj = node;
              } else if (s) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                objClone = {};
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  objClone[key] = obj[key];
                }
                s[_this.options.childkey].push(objClone);
                delete obj["#name"];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
            }
            if (stack.length > 0) {
              return _this.assignOrPush(s, nodeName, obj);
            } else {
              if (_this.options.explicitRoot) {
                old = obj;
                obj = {};
                obj[nodeName] = old;
              }
              _this.resultObject = obj;
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);
        ontext = function(_this) {
          return function(text) {
            var charChild, s;
            s = stack[stack.length - 1];
            if (s) {
              s[charkey] += text;
              if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                charChild = {
                  "#name": "__text__"
                };
                charChild[charkey] = text;
                if (_this.options.normalize) {
                  charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                }
                s[_this.options.childkey].push(charChild);
              }
              return s;
            }
          };
        }(this);
        this.saxParser.ontext = ontext;
        return this.saxParser.oncdata = function(_this) {
          return function(text) {
            var s;
            s = ontext(text);
            if (s) {
              return s.cdata = true;
            }
          };
        }(this);
      };
      Parser.prototype.parseString = function(str, cb) {
        var err;
        if (cb != null && typeof cb === "function") {
          this.on("end", function(result) {
            this.reset();
            return cb(null, result);
          });
          this.on("error", function(err2) {
            this.reset();
            return cb(err2);
          });
        }
        try {
          str = str.toString();
          if (str.trim() === "") {
            this.emit("end", null);
            return true;
          }
          str = bom.stripBOM(str);
          if (this.options.async) {
            this.remaining = str;
            setImmediate2(this.processAsync);
            return this.saxParser;
          }
          return this.saxParser.write(str).close();
        } catch (error1) {
          err = error1;
          if (!(this.saxParser.errThrown || this.saxParser.ended)) {
            this.emit("error", err);
            return this.saxParser.errThrown = true;
          } else if (this.saxParser.ended) {
            throw err;
          }
        }
      };
      Parser.prototype.parseStringPromise = function(str) {
        return new Promise(function(_this) {
          return function(resolve2, reject2) {
            return _this.parseString(str, function(err, value2) {
              if (err) {
                return reject2(err);
              } else {
                return resolve2(value2);
              }
            });
          };
        }(this));
      };
      return Parser;
    }(events);
    exports.parseString = function(str, a, b) {
      var cb, options, parser;
      if (b != null) {
        if (typeof b === "function") {
          cb = b;
        }
        if (typeof a === "object") {
          options = a;
        }
      } else {
        if (typeof a === "function") {
          cb = a;
        }
        options = {};
      }
      parser = new exports.Parser(options);
      return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
      var options, parser;
      if (typeof a === "object") {
        options = a;
      }
      parser = new exports.Parser(options);
      return parser.parseStringPromise(str);
    };
  }).call(exports);
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS((exports) => {
  (function() {
    var builder, defaults, parser, processors, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    defaults = require_defaults();
    builder = require_builder();
    parser = require_parser3();
    processors = require_processors();
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = function(superClass) {
      extend(ValidationError, superClass);
      function ValidationError(message) {
        this.message = message;
      }
      return ValidationError;
    }(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
  }).call(exports);
});

// node_modules/parse-bmfont-xml/lib/parse-attribs.js
var require_parse_attribs = __commonJS((exports, module) => {
  var parseIntList = function(data2) {
    return data2.split(",").map(function(val) {
      return parseInt(val, 10);
    });
  };
  var GLYPH_DESIGNER_ERROR = "chasrset";
  module.exports = function parseAttributes(obj) {
    if (GLYPH_DESIGNER_ERROR in obj) {
      obj["charset"] = obj[GLYPH_DESIGNER_ERROR];
      delete obj[GLYPH_DESIGNER_ERROR];
    }
    for (var k in obj) {
      if (k === "face" || k === "charset")
        continue;
      else if (k === "padding" || k === "spacing")
        obj[k] = parseIntList(obj[k]);
      else
        obj[k] = parseInt(obj[k], 10);
    }
    return obj;
  };
});

// node_modules/parse-bmfont-xml/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  var xml2js = require_xml2js();
  var parseAttributes = require_parse_attribs();
  module.exports = function parseBMFontXML(data2) {
    data2 = data2.toString().trim();
    var output = {
      pages: [],
      chars: [],
      kernings: []
    };
    xml2js.parseString(data2, function(err, result) {
      if (err)
        throw err;
      if (!result.font)
        throw "XML bitmap font doesn't have <font> root";
      result = result.font;
      output.common = parseAttributes(result.common[0].$);
      output.info = parseAttributes(result.info[0].$);
      for (var i2 = 0;i2 < result.pages.length; i2++) {
        var p = result.pages[i2].page[0].$;
        if (typeof p.id === "undefined")
          throw new Error("malformed file -- needs page id=N");
        if (typeof p.file !== "string")
          throw new Error("malformed file -- needs page file=\"path\"");
        output.pages[parseInt(p.id, 10)] = p.file;
      }
      if (result.chars) {
        var chrArray = result.chars[0]["char"] || [];
        for (var i2 = 0;i2 < chrArray.length; i2++) {
          output.chars.push(parseAttributes(chrArray[i2].$));
        }
      }
      if (result.kernings) {
        var kernArray = result.kernings[0]["kerning"] || [];
        for (var i2 = 0;i2 < kernArray.length; i2++) {
          output.kernings.push(parseAttributes(kernArray[i2].$));
        }
      }
    });
    return output;
  };
});

// node_modules/parse-bmfont-binary/index.js
var require_parse_bmfont_binary = __commonJS((exports, module) => {
  var readBlock = function(target, buf, i2) {
    if (i2 > buf.length - 1)
      return 0;
    var blockID = buf.readUInt8(i2++);
    var blockSize = buf.readInt32LE(i2);
    i2 += 4;
    switch (blockID) {
      case 1:
        target.info = readInfo(buf, i2);
        break;
      case 2:
        target.common = readCommon(buf, i2);
        break;
      case 3:
        target.pages = readPages(buf, i2, blockSize);
        break;
      case 4:
        target.chars = readChars(buf, i2, blockSize);
        break;
      case 5:
        target.kernings = readKernings(buf, i2, blockSize);
        break;
    }
    return 5 + blockSize;
  };
  var readInfo = function(buf, i2) {
    var info = {};
    info.size = buf.readInt16LE(i2);
    var bitField = buf.readUInt8(i2 + 2);
    info.smooth = bitField >> 7 & 1;
    info.unicode = bitField >> 6 & 1;
    info.italic = bitField >> 5 & 1;
    info.bold = bitField >> 4 & 1;
    if (bitField >> 3 & 1)
      info.fixedHeight = 1;
    info.charset = buf.readUInt8(i2 + 3) || "";
    info.stretchH = buf.readUInt16LE(i2 + 4);
    info.aa = buf.readUInt8(i2 + 6);
    info.padding = [
      buf.readInt8(i2 + 7),
      buf.readInt8(i2 + 8),
      buf.readInt8(i2 + 9),
      buf.readInt8(i2 + 10)
    ];
    info.spacing = [
      buf.readInt8(i2 + 11),
      buf.readInt8(i2 + 12)
    ];
    info.outline = buf.readUInt8(i2 + 13);
    info.face = readStringNT(buf, i2 + 14);
    return info;
  };
  var readCommon = function(buf, i2) {
    var common = {};
    common.lineHeight = buf.readUInt16LE(i2);
    common.base = buf.readUInt16LE(i2 + 2);
    common.scaleW = buf.readUInt16LE(i2 + 4);
    common.scaleH = buf.readUInt16LE(i2 + 6);
    common.pages = buf.readUInt16LE(i2 + 8);
    var bitField = buf.readUInt8(i2 + 10);
    common.packed = 0;
    common.alphaChnl = buf.readUInt8(i2 + 11);
    common.redChnl = buf.readUInt8(i2 + 12);
    common.greenChnl = buf.readUInt8(i2 + 13);
    common.blueChnl = buf.readUInt8(i2 + 14);
    return common;
  };
  var readPages = function(buf, i2, size) {
    var pages = [];
    var text = readNameNT(buf, i2);
    var len = text.length + 1;
    var count = size / len;
    for (var c2 = 0;c2 < count; c2++) {
      pages[c2] = buf.slice(i2, i2 + text.length).toString("utf8");
      i2 += len;
    }
    return pages;
  };
  var readChars = function(buf, i2, blockSize) {
    var chars = [];
    var count = blockSize / 20;
    for (var c2 = 0;c2 < count; c2++) {
      var char = {};
      var off = c2 * 20;
      char.id = buf.readUInt32LE(i2 + 0 + off);
      char.x = buf.readUInt16LE(i2 + 4 + off);
      char.y = buf.readUInt16LE(i2 + 6 + off);
      char.width = buf.readUInt16LE(i2 + 8 + off);
      char.height = buf.readUInt16LE(i2 + 10 + off);
      char.xoffset = buf.readInt16LE(i2 + 12 + off);
      char.yoffset = buf.readInt16LE(i2 + 14 + off);
      char.xadvance = buf.readInt16LE(i2 + 16 + off);
      char.page = buf.readUInt8(i2 + 18 + off);
      char.chnl = buf.readUInt8(i2 + 19 + off);
      chars[c2] = char;
    }
    return chars;
  };
  var readKernings = function(buf, i2, blockSize) {
    var kernings = [];
    var count = blockSize / 10;
    for (var c2 = 0;c2 < count; c2++) {
      var kern = {};
      var off = c2 * 10;
      kern.first = buf.readUInt32LE(i2 + 0 + off);
      kern.second = buf.readUInt32LE(i2 + 4 + off);
      kern.amount = buf.readInt16LE(i2 + 8 + off);
      kernings[c2] = kern;
    }
    return kernings;
  };
  var readNameNT = function(buf, offset) {
    var pos = offset;
    for (;pos < buf.length; pos++) {
      if (buf[pos] === 0)
        break;
    }
    return buf.slice(offset, pos);
  };
  var readStringNT = function(buf, offset) {
    return readNameNT(buf, offset).toString("utf8");
  };
  var HEADER = [66, 77, 70];
  module.exports = function readBMFontBinary(buf) {
    if (buf.length < 6)
      throw new Error("invalid buffer length for BMFont");
    var header = HEADER.every(function(byte, i3) {
      return buf.readUInt8(i3) === byte;
    });
    if (!header)
      throw new Error("BMFont missing BMF byte header");
    var i2 = 3;
    var vers = buf.readUInt8(i2++);
    if (vers > 3)
      throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
    var target = { kernings: [], chars: [] };
    for (var b = 0;b < 5; b++)
      i2 += readBlock(target, buf, i2);
    return target;
  };
});

// node_modules/mime/types.json
var require_types = __commonJS((exports, module) => {
  module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
});

// node_modules/mime/mime.js
var require_mime = __commonJS((exports, module) => {
  var Mime = function() {
    this.types = Object.create(null);
    this.extensions = Object.create(null);
  };
  var path2 = import.meta.require("path");
  var fs2 = import.meta.require("fs");
  Mime.prototype.define = function(map) {
    for (var type in map) {
      var exts = map[type];
      for (var i2 = 0;i2 < exts.length; i2++) {
        if (process.env.DEBUG_MIME && this.types[exts[i2]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i2] + '" extension type from ' + this.types[exts[i2]] + " to " + type);
        }
        this.types[exts[i2]] = type;
      }
      if (!this.extensions[type]) {
        this.extensions[type] = exts[0];
      }
    }
  };
  Mime.prototype.load = function(file) {
    this._loading = file;
    var map = {}, content = fs2.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
    lines.forEach(function(line) {
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
      map[fields.shift()] = fields;
    });
    this.define(map);
    this._loading = null;
  };
  Mime.prototype.lookup = function(path3, fallback) {
    var ext = path3.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };
  Mime.prototype.extension = function(mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
  };
  var mime = new Mime;
  mime.define(require_types());
  mime.default_type = mime.lookup("bin");
  mime.Mime = Mime;
  mime.charsets = {
    lookup: function(mimeType, fallback) {
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
  };
  module.exports = mime;
});

// node_modules/buffer-equal/index.js
var require_buffer_equal = __commonJS((exports, module) => {
  var Buffer2 = import.meta.require("buffer").Buffer;
  module.exports = function(a, b) {
    if (!Buffer2.isBuffer(a))
      return;
    if (!Buffer2.isBuffer(b))
      return;
    if (typeof a.equals === "function")
      return a.equals(b);
    if (a.length !== b.length)
      return false;
    for (var i2 = 0;i2 < a.length; i2++) {
      if (a[i2] !== b[i2])
        return false;
    }
    return true;
  };
});

// node_modules/load-bmfont/lib/is-binary.js
var require_is_binary = __commonJS((exports, module) => {
  var equal = require_buffer_equal();
  var HEADER = Buffer.from([66, 77, 70, 3]);
  module.exports = function(buf) {
    if (typeof buf === "string")
      return buf.substring(0, 3) === "BMF";
    return buf.length > 4 && equal(buf.slice(0, 4), HEADER);
  };
});

// node_modules/load-bmfont/index.js
var require_load_bmfont = __commonJS((exports, module) => {
  var parseFont = function(file, data2, cb) {
    var result, binary;
    if (isBinary(data2)) {
      if (typeof data2 === "string")
        data2 = Buffer.from(data2, "binary");
      binary = true;
    } else
      data2 = data2.toString().trim();
    try {
      if (binary)
        result = readBinary(data2);
      else if (/json/.test(mime.lookup(file)) || data2.charAt(0) === "{")
        result = JSON.parse(data2);
      else if (/xml/.test(mime.lookup(file)) || data2.charAt(0) === "<")
        result = parseXML(data2);
      else
        result = parseASCII(data2);
    } catch (e) {
      cb(e);
      cb = noop2;
    }
    cb(null, result);
  };
  var fs2 = import.meta.require("fs");
  var url = import.meta.require("url");
  var path2 = import.meta.require("path");
  var request2 = require_phin_compiled();
  var parseASCII = require_parse_bmfont_ascii();
  var parseXML = require_lib5();
  var readBinary = require_parse_bmfont_binary();
  var mime = require_mime();
  var noop2 = function() {
  };
  var isBinary = require_is_binary();
  module.exports = function loadFont(opt, cb) {
    cb = typeof cb === "function" ? cb : noop2;
    if (typeof opt === "string")
      opt = { uri: opt, url: opt };
    else if (!opt)
      opt = {};
    var file = opt.uri || opt.url;
    function handleData(err, data2) {
      if (err)
        return cb(err);
      parseFont(file, data2.body || data2, cb);
    }
    if (url.parse(file).host) {
      request2(opt, handleData);
    } else {
      fs2.readFile(file, opt, handleData);
    }
  };
});

// node_modules/commander/esm.mjs
var import_ = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import_.default;

// actions/Hide.ts
var import_prompt = __toESM(require_prompt(), 1);

// config/password.ts
var default_ = {
  name: "password",
  description: "Enter an unique keypass",
  message: "Keypass must be letters",
  hidden: true,
  replace: "*",
  type: "string"
};

// services/DataService.ts
var {hash } = globalThis.Bun;

// config/data.ts
import {join} from "path";
var default_2 = {
  path: join(import.meta.dir, "..", "data.json")
};

// utils/FileSystem.ts
import {readFileSync, writeFileSync} from "fs";

class FileSystem {
  static read(filePath) {
    const file = readFileSync(filePath);
    return file.toString();
  }
  static write(filePath, data) {
    const file = writeFileSync(filePath, data);
  }
}

// services/DataService.ts
class DataService {
  save(data2) {
    let savedData = JSON.parse(FileSystem.read(default_2.path));
    if (!Array.isArray(savedData)) {
      savedData = [];
    }
    savedData.push({
      password: hash(data2.password).toString(),
      size: data2.size
    });
    FileSystem.write(default_2.path, JSON.stringify(savedData));
  }
  async reset() {
    await FileSystem.write(default_2.path, JSON.stringify([]));
  }
  verify(password) {
    let savedData = JSON.parse(FileSystem.read(default_2.path));
    if (!Array.isArray(savedData)) {
      throw new Error("No steganogany in the system yet...");
    }
    for (let i2 = 0;i2 < savedData.length; i2++) {
      const data2 = savedData[i2];
      const hashedPassword = hash(password).toString();
      if (hashedPassword === data2?.password) {
        return data2?.size;
      }
    }
    return -1;
  }
}

// node_modules/@jimp/core/es/index.js
var _defineProperty = function(obj, key, value2) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value2;
  }
  return obj;
};
var _toPropertyKey = function(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
};
var _toPrimitive = function(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
};
import fs from "fs";
import Path from "path";
import EventEmitter from "events";

// node_modules/@jimp/utils/es/index.js
function isNodePattern(cb) {
  if (typeof cb === "undefined") {
    return false;
  }
  if (typeof cb !== "function") {
    throw new TypeError("Callback must be a function");
  }
  return true;
}
function throwError(error, cb) {
  if (typeof error === "string") {
    error = new Error(error);
  }
  if (typeof cb === "function") {
    return cb.call(this, error);
  }
  throw error;
}
function scan(image2, x, y, w, h, f) {
  x = Math.round(x);
  y = Math.round(y);
  w = Math.round(w);
  h = Math.round(h);
  for (let _y = y;_y < y + h; _y++) {
    for (let _x = x;_x < x + w; _x++) {
      const idx = image2.bitmap.width * _y + _x << 2;
      f.call(image2, _x, _y, idx);
    }
  }
  return image2;
}
function* scanIterator(image2, x, y, w, h) {
  x = Math.round(x);
  y = Math.round(y);
  w = Math.round(w);
  h = Math.round(h);
  for (let _y = y;_y < y + h; _y++) {
    for (let _x = x;_x < x + w; _x++) {
      const idx = image2.bitmap.width * _y + _x << 2;
      yield {
        x: _x,
        y: _y,
        idx,
        image: image2
      };
    }
  }
}

// node_modules/@jimp/core/es/index.js
var import_any_base = __toESM(require_any_base(), 1);
var import_pixelmatch = __toESM(require_pixelmatch(), 1);

// node_modules/tinycolor2/esm/tinycolor.js
var _typeof = function(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
};
var tinycolor = function(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
};
var inputToRGB = function(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
};
var rgbToRgb = function(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
};
var rgbToHsl = function(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    l
  };
};
var hslToRgb = function(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q2, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p2 + (q2 - p2) * 6 * t;
    if (t < 1 / 2)
      return q2;
    if (t < 2 / 3)
      return p2 + (q2 - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
};
var rgbToHsv = function(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h = 0;
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    v
  };
};
var hsvToRgb = function(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i2 = Math.floor(h), f = h - i2, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i2 % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
};
var rgbToHex = function(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
};
var rgbaToHex = function(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
};
var rgbaToArgbHex = function(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
};
var _desaturate = function(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
};
var _saturate = function(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
};
var _greyscale = function(color) {
  return tinycolor(color).desaturate(100);
};
var _lighten = function(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
};
var _brighten = function(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
};
var _darken = function(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
};
var _spin = function(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
};
var _complement = function(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
};
var polyad = function(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i2 = 1;i2 < number; i2++) {
    result.push(tinycolor({
      h: (hsl.h + i2 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
};
var _splitcomplement = function(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
};
var _analogous = function(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360;--results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
};
var _monochromatic = function(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var { h, s, v } = hsv;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h,
      s,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
};
var flip = function(o) {
  var flipped = {};
  for (var i2 in o) {
    if (o.hasOwnProperty(i2)) {
      flipped[o[i2]] = i2;
    }
  }
  return flipped;
};
var boundAlpha = function(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
};
var bound01 = function(n, max) {
  if (isOnePointZero(n))
    n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }
  return n % max / parseFloat(max);
};
var clamp01 = function(val) {
  return Math.min(1, Math.max(0, val));
};
var parseIntFromHex = function(val) {
  return parseInt(val, 16);
};
var isOnePointZero = function(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
};
var isPercentage = function(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
};
var pad2 = function(c) {
  return c.length == 1 ? "0" + c : "" + c;
};
var convertToPercentage = function(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
};
var convertDecimalToHex = function(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
};
var convertHexToDecimal = function(h) {
  return parseIntFromHex(h) / 255;
};
var isValidCSSUnit = function(color) {
  return !!matchers.CSS_UNIT.exec(color);
};
var stringInputToObject = function(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
};
var validateWCAG2Parms = function(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
};
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R = RsRGB / 12.92;
    else
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G = GsRGB / 12.92;
    else
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B = BsRGB / 12.92;
    else
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value2) {
    this._a = boundAlpha(value2);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i2 in color) {
      if (color.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color[i2];
        } else {
          newColor[i2] = convertToPercentage(color[i2]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i2 = 0;i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();

// node_modules/@jimp/core/es/modules/phash.js
var ImagePHash = function(size, smallerSize) {
  this.size = this.size || size;
  this.smallerSize = this.smallerSize || smallerSize;
  initCoefficients(this.size);
};
var intToRGBA = function(i2) {
  const rgba = {};
  rgba.r = Math.floor(i2 / Math.pow(256, 3));
  rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
  rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
  rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
  return rgba;
};
var initCoefficients = function(size) {
  for (let i2 = 1;i2 < size; i2++) {
    c[i2] = 1;
  }
  c[0] = 1 / Math.sqrt(2);
};
var applyDCT = function(f, size) {
  const N = size;
  const F = [];
  for (let u = 0;u < N; u++) {
    F[u] = [];
    for (let v = 0;v < N; v++) {
      let sum = 0;
      for (let i2 = 0;i2 < N; i2++) {
        for (let j = 0;j < N; j++) {
          sum += Math.cos((2 * i2 + 1) / (2 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2 * N) * v * Math.PI) * f[i2][j];
        }
      }
      sum *= c[u] * c[v] / 4;
      F[u][v] = sum;
    }
  }
  return F;
};
ImagePHash.prototype.size = 32;
ImagePHash.prototype.smallerSize = 8;
ImagePHash.prototype.distance = function(s1, s2) {
  let counter = 0;
  for (let k = 0;k < s1.length; k++) {
    if (s1[k] !== s2[k]) {
      counter++;
    }
  }
  return counter / s1.length;
};
ImagePHash.prototype.getHash = function(img) {
  img = img.clone().resize(this.size, this.size);
  img.grayscale();
  const vals = [];
  for (let x = 0;x < img.bitmap.width; x++) {
    vals[x] = [];
    for (let y = 0;y < img.bitmap.height; y++) {
      vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
    }
  }
  const dctVals = applyDCT(vals, this.size);
  let total = 0;
  for (let x = 0;x < this.smallerSize; x++) {
    for (let y = 0;y < this.smallerSize; y++) {
      total += dctVals[x][y];
    }
  }
  const avg = total / (this.smallerSize * this.smallerSize);
  let hash2 = "";
  for (let x = 0;x < this.smallerSize; x++) {
    for (let y = 0;y < this.smallerSize; y++) {
      hash2 += dctVals[x][y] > avg ? "1" : "0";
    }
  }
  return hash2;
};
var c = [];
var phash_default = ImagePHash;

// node_modules/@jimp/core/es/request.js
var request_default = (_ref, cb) => {
  let {
    url,
    ...options
  } = _ref;
  fetch(url, options).then((response) => {
    if (response.ok) {
      return response.arrayBuffer().catch((error) => {
        throw new Error(`Response is not a buffer for url ${url}. Error: ${error.message}`);
      });
    }
    throw new Error(`HTTP Status ${response.status} for url ${url}`);
  }).then((data2) => cb(null, data2)).catch((error) => cb(error));
};

// node_modules/@jimp/core/es/constants.js
var exports_constants = {};
__export(exports_constants, {
  VERTICAL_ALIGN_TOP: () => {
    {
      return VERTICAL_ALIGN_TOP;
    }
  },
  VERTICAL_ALIGN_MIDDLE: () => {
    {
      return VERTICAL_ALIGN_MIDDLE;
    }
  },
  VERTICAL_ALIGN_BOTTOM: () => {
    {
      return VERTICAL_ALIGN_BOTTOM;
    }
  },
  HORIZONTAL_ALIGN_RIGHT: () => {
    {
      return HORIZONTAL_ALIGN_RIGHT;
    }
  },
  HORIZONTAL_ALIGN_LEFT: () => {
    {
      return HORIZONTAL_ALIGN_LEFT;
    }
  },
  HORIZONTAL_ALIGN_CENTER: () => {
    {
      return HORIZONTAL_ALIGN_CENTER;
    }
  },
  EDGE_WRAP: () => {
    {
      return EDGE_WRAP;
    }
  },
  EDGE_EXTEND: () => {
    {
      return EDGE_EXTEND;
    }
  },
  EDGE_CROP: () => {
    {
      return EDGE_CROP;
    }
  },
  BLEND_SOURCE_OVER: () => {
    {
      return BLEND_SOURCE_OVER;
    }
  },
  BLEND_SCREEN: () => {
    {
      return BLEND_SCREEN;
    }
  },
  BLEND_OVERLAY: () => {
    {
      return BLEND_OVERLAY;
    }
  },
  BLEND_MULTIPLY: () => {
    {
      return BLEND_MULTIPLY;
    }
  },
  BLEND_LIGHTEN: () => {
    {
      return BLEND_LIGHTEN;
    }
  },
  BLEND_HARDLIGHT: () => {
    {
      return BLEND_HARDLIGHT;
    }
  },
  BLEND_EXCLUSION: () => {
    {
      return BLEND_EXCLUSION;
    }
  },
  BLEND_DIFFERENCE: () => {
    {
      return BLEND_DIFFERENCE;
    }
  },
  BLEND_DESTINATION_OVER: () => {
    {
      return BLEND_DESTINATION_OVER;
    }
  },
  BLEND_DARKEN: () => {
    {
      return BLEND_DARKEN;
    }
  },
  BLEND_ADD: () => {
    {
      return BLEND_ADD;
    }
  },
  AUTO: () => {
    {
      return AUTO;
    }
  }
});
var AUTO = -1;
var HORIZONTAL_ALIGN_LEFT = 1;
var HORIZONTAL_ALIGN_CENTER = 2;
var HORIZONTAL_ALIGN_RIGHT = 4;
var VERTICAL_ALIGN_TOP = 8;
var VERTICAL_ALIGN_MIDDLE = 16;
var VERTICAL_ALIGN_BOTTOM = 32;
var BLEND_SOURCE_OVER = "srcOver";
var BLEND_DESTINATION_OVER = "dstOver";
var BLEND_MULTIPLY = "multiply";
var BLEND_ADD = "add";
var BLEND_SCREEN = "screen";
var BLEND_OVERLAY = "overlay";
var BLEND_DARKEN = "darken";
var BLEND_LIGHTEN = "lighten";
var BLEND_HARDLIGHT = "hardLight";
var BLEND_DIFFERENCE = "difference";
var BLEND_EXCLUSION = "exclusion";
var EDGE_EXTEND = 1;
var EDGE_WRAP = 2;
var EDGE_CROP = 3;

// node_modules/@jimp/core/es/composite/composite-modes.js
var exports_composite_modes = {};
__export(exports_composite_modes, {
  srcOver: () => {
    {
      return srcOver;
    }
  },
  screen: () => {
    {
      return screen;
    }
  },
  overlay: () => {
    {
      return overlay;
    }
  },
  multiply: () => {
    {
      return multiply;
    }
  },
  lighten: () => {
    {
      return lighten2;
    }
  },
  hardLight: () => {
    {
      return hardLight;
    }
  },
  exclusion: () => {
    {
      return exclusion;
    }
  },
  dstOver: () => {
    {
      return dstOver;
    }
  },
  difference: () => {
    {
      return difference;
    }
  },
  darken: () => {
    {
      return darken2;
    }
  },
  add: () => {
    {
      return add;
    }
  }
});
function srcOver(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
  const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
  const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function dstOver(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
  const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
  const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function multiply(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function add(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra + dra) / a;
  const g = (sga + dga) / a;
  const b = (sba + dba) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function screen(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  const g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  const b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function overlay(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
  const g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
  const b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function darken2(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  const g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  const b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function lighten2(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  const g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  const b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function hardLight(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
  const g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
  const b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function difference(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
  const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
  const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}
function exclusion(src, dst) {
  let ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
  const g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
  const b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
  return {
    r,
    g,
    b,
    a
  };
}

// node_modules/@jimp/core/es/composite/index.js
function composite(src, x, y) {
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  let cb = arguments.length > 4 ? arguments[4] : undefined;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  if (!(src instanceof this.constructor)) {
    return throwError.call(this, "The source must be a Jimp image", cb);
  }
  if (typeof x !== "number" || typeof y !== "number") {
    return throwError.call(this, "x and y must be numbers", cb);
  }
  let {
    mode,
    opacitySource,
    opacityDest
  } = options;
  if (!mode) {
    mode = BLEND_SOURCE_OVER;
  }
  if (typeof opacitySource !== "number" || opacitySource < 0 || opacitySource > 1) {
    opacitySource = 1;
  }
  if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
    opacityDest = 1;
  }
  const blendmode = exports_composite_modes[mode];
  x = Math.round(x);
  y = Math.round(y);
  const baseImage = this;
  if (opacityDest !== 1) {
    baseImage.opacity(opacityDest);
  }
  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, EDGE_CROP);
    if (dstIdx === -1) {
      return;
    }
    const blended = blendmode({
      r: this.bitmap.data[idx + 0] / 255,
      g: this.bitmap.data[idx + 1] / 255,
      b: this.bitmap.data[idx + 2] / 255,
      a: this.bitmap.data[idx + 3] / 255
    }, {
      r: baseImage.bitmap.data[dstIdx + 0] / 255,
      g: baseImage.bitmap.data[dstIdx + 1] / 255,
      b: baseImage.bitmap.data[dstIdx + 2] / 255,
      a: baseImage.bitmap.data[dstIdx + 3] / 255
    }, opacitySource);
    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);
    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);
    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);
    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);
  });
  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }
  return this;
}

// node_modules/@jimp/core/es/utils/promisify.js
var promisify = function(fun, ctx) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2;_key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  return new Promise((resolve2, reject2) => {
    args.push((err, data2) => {
      if (err) {
        reject2(err);
      }
      resolve2(data2);
    });
    fun.bind(ctx)(...args);
  });
};
var promisify_default = promisify;

// node_modules/@jimp/core/es/utils/mime.js
var mimeTypes = {};
var findType = (extension) => Object.entries(mimeTypes).find((type) => type[1].includes(extension)) || [];
var addType = (mime, extensions) => {
  mimeTypes[mime] = extensions;
};
var getType = (path2) => {
  const pathParts = path2.split("/").slice(-1);
  const extension = pathParts[pathParts.length - 1].split(".").pop();
  const type = findType(extension);
  return type[0];
};
var getExtension = (type) => (mimeTypes[type.toLowerCase()] || [])[0];

// node_modules/@jimp/core/es/utils/image-bitmap.js
var import_file_type = __toESM(require_file_type(), 1);
var import_exif_parser = __toESM(require_exif_parser(), 1);
async function getMIMEFromBuffer(buffer, path2) {
  const fileTypeFromBuffer = await import_file_type.default.fromBuffer(buffer);
  if (fileTypeFromBuffer) {
    return fileTypeFromBuffer.mime;
  }
  if (path2) {
    return getType(path2);
  }
  return null;
}
var getExifOrientation = function(img) {
  return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
};
var getExifOrientationTransformation = function(img) {
  const w = img.getWidth();
  const h = img.getHeight();
  switch (getExifOrientation(img)) {
    case 1:
      return null;
    case 2:
      return function(x, y) {
        return [w - x - 1, y];
      };
    case 3:
      return function(x, y) {
        return [w - x - 1, h - y - 1];
      };
    case 4:
      return function(x, y) {
        return [x, h - y - 1];
      };
    case 5:
      return function(x, y) {
        return [y, x];
      };
    case 6:
      return function(x, y) {
        return [y, h - x - 1];
      };
    case 7:
      return function(x, y) {
        return [w - y - 1, h - x - 1];
      };
    case 8:
      return function(x, y) {
        return [w - y - 1, x];
      };
    default:
      return null;
  }
};
var transformBitmap = function(img, width, height, transformation) {
  const _data = img.bitmap.data;
  const _width = img.bitmap.width;
  const data2 = Buffer.alloc(_data.length);
  for (let x = 0;x < width; x++) {
    for (let y = 0;y < height; y++) {
      const [_x, _y] = transformation(x, y);
      const idx = width * y + x << 2;
      const _idx = _width * _y + _x << 2;
      const pixel = _data.readUInt32BE(_idx);
      data2.writeUInt32BE(pixel, idx);
    }
  }
  img.bitmap.data = data2;
  img.bitmap.width = width;
  img.bitmap.height = height;
};
var exifRotate = function(img) {
  if (getExifOrientation(img) < 2)
    return;
  const transformation = getExifOrientationTransformation(img);
  const swapDimensions = getExifOrientation(img) > 4;
  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
  transformBitmap(img, newWidth, newHeight, transformation);
};
async function parseBitmap(data2, path2, cb) {
  const mime = await getMIMEFromBuffer(data2, path2);
  if (typeof mime !== "string") {
    return cb(new Error("Could not find MIME for Buffer <" + path2 + ">"));
  }
  this._originalMime = mime.toLowerCase();
  try {
    const mime2 = this.getMIME();
    if (this.constructor.decoders[mime2]) {
      this.bitmap = this.constructor.decoders[mime2](data2);
    } else {
      return throwError.call(this, "Unsupported MIME type: " + mime2, cb);
    }
  } catch (error) {
    return cb.call(this, error, this);
  }
  try {
    this._exif = import_exif_parser.default.create(data2).parse();
    exifRotate(this);
  } catch (error) {
  }
  cb.call(this, null, this);
  return this;
}
var compositeBitmapOverBackground = function(Jimp, image2) {
  return new Jimp(image2.bitmap.width, image2.bitmap.height, image2._background).composite(image2, 0, 0).bitmap;
};
function getBuffer(mime, cb) {
  if (mime === AUTO) {
    mime = this.getMIME();
  }
  if (typeof mime !== "string") {
    return throwError.call(this, "mime must be a string", cb);
  }
  if (typeof cb !== "function") {
    return throwError.call(this, "cb must be a function", cb);
  }
  mime = mime.toLowerCase();
  if (this._rgba && this.constructor.hasAlpha[mime]) {
    this.bitmap.data = Buffer.from(this.bitmap.data);
  } else {
    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;
  }
  if (this.constructor.encoders[mime]) {
    const buffer = this.constructor.encoders[mime](this);
    if (buffer instanceof Promise) {
      buffer.then((buff) => {
        cb.call(this, null, buff);
      });
    } else {
      cb.call(this, null, buffer);
    }
  } else {
    return throwError.call(this, "Unsupported MIME type: " + mime, cb);
  }
  return this;
}
function getBufferAsync(mime) {
  return promisify_default(getBuffer, this, mime);
}

// node_modules/@jimp/core/es/index.js
var noop = function() {
};
var isArrayBuffer = function(test) {
  return Object.prototype.toString.call(test).toLowerCase().indexOf("arraybuffer") > -1;
};
var bufferFromArrayBuffer = function(arrayBuffer) {
  const buffer = Buffer.alloc(arrayBuffer.byteLength);
  const view = new Uint8Array(arrayBuffer);
  for (let i2 = 0;i2 < buffer.length; ++i2) {
    buffer[i2] = view[i2];
  }
  return buffer;
};
var loadFromURL = function(options, cb) {
  request_default(options, (err, data2) => {
    if (err) {
      return cb(err);
    }
    if (typeof data2 === "object" && Buffer.isBuffer(data2)) {
      return cb(null, data2);
    }
    if (typeof data2 === "object" && isArrayBuffer(data2)) {
      return cb(null, bufferFromArrayBuffer(data2));
    }
    return new Error(`Could not load Buffer from <${options.url}>`);
  });
};
var loadBufferFromPath = function(src, cb) {
  if (fs && typeof fs.readFile === "function" && !src.match(/^(http|ftp)s?:\/\/./)) {
    fs.readFile(src, cb);
  } else {
    loadFromURL({
      url: src
    }, cb);
  }
};
var isRawRGBAData = function(obj) {
  return obj && typeof obj === "object" && typeof obj.width === "number" && typeof obj.height === "number" && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === "function" && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
};
var makeRGBABufferFromRGB = function(buffer) {
  if (buffer.length % 3 !== 0) {
    throw new Error("Buffer length is incorrect");
  }
  const rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);
  let j = 0;
  for (let i2 = 0;i2 < buffer.length; i2++) {
    rgbaBuffer[j] = buffer[i2];
    if ((i2 + 1) % 3 === 0) {
      rgbaBuffer[++j] = 255;
    }
    j++;
  }
  return rgbaBuffer;
};
function addConstants(constants2) {
  let jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;
  Object.entries(constants2).forEach((_ref) => {
    let [name2, value2] = _ref;
    jimpInstance[name2] = value2;
  });
}
function addJimpMethods(methods) {
  let jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;
  Object.entries(methods).forEach((_ref2) => {
    let [name2, value2] = _ref2;
    jimpInstance.prototype[name2] = value2;
  });
}
function jimpEvMethod(methodName, evName, method) {
  const evNameBefore = "before-" + evName;
  const evNameAfter = evName.replace(/e$/, "") + "ed";
  Jimp.prototype[methodName] = function() {
    let wrappedCb;
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;_key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    const cb = args[method.length - 1];
    const jimpInstance = this;
    if (typeof cb === "function") {
      wrappedCb = function() {
        for (var _len5 = arguments.length, args2 = new Array(_len5), _key5 = 0;_key5 < _len5; _key5++) {
          args2[_key5] = arguments[_key5];
        }
        const [err, data2] = args2;
        if (err) {
          jimpInstance.emitError(methodName, err);
        } else {
          jimpInstance.emitMulti(methodName, evNameAfter, {
            [methodName]: data2
          });
        }
        cb.apply(this, args2);
      };
      args[args.length - 1] = wrappedCb;
    } else {
      wrappedCb = false;
    }
    this.emitMulti(methodName, evNameBefore);
    let result;
    try {
      result = method.apply(this, args);
      if (!wrappedCb) {
        this.emitMulti(methodName, evNameAfter, {
          [methodName]: result
        });
      }
    } catch (error) {
      error.methodName = methodName;
      this.emitError(methodName, error);
    }
    return result;
  };
  Jimp.prototype[methodName + "Quiet"] = method;
}
function jimpEvChange(methodName, method) {
  jimpEvMethod(methodName, "change", method);
}
var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
var maxHashLength = [NaN, NaN];
for (let i2 = 2;i2 < 65; i2++) {
  const maxHash = import_any_base.default(import_any_base.default.BIN, alphabet.slice(0, i2))(new Array(64 + 1).join("1"));
  maxHashLength.push(maxHash.length);
}
var emptyBitmap = {
  data: null,
  width: null,
  height: null
};

class Jimp extends EventEmitter {
  constructor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    super();
    _defineProperty(this, "bitmap", emptyBitmap);
    _defineProperty(this, "_background", 0);
    _defineProperty(this, "_originalMime", Jimp.MIME_PNG);
    _defineProperty(this, "_exif", null);
    _defineProperty(this, "_rgba", true);
    _defineProperty(this, "writeAsync", (path2) => promisify_default(this.write, this, path2));
    _defineProperty(this, "getBase64Async", (mime) => promisify_default(this.getBase64, this, mime));
    _defineProperty(this, "getBuffer", getBuffer);
    _defineProperty(this, "getBufferAsync", getBufferAsync);
    _defineProperty(this, "getPixelColour", this.getPixelColor);
    _defineProperty(this, "setPixelColour", this.setPixelColor);
    const jimpInstance = this;
    let cb = noop;
    if (isArrayBuffer(args[0])) {
      args[0] = bufferFromArrayBuffer(args[0]);
    }
    function finish() {
      for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0;_key2 < _len2; _key2++) {
        args2[_key2] = arguments[_key2];
      }
      const [err] = args2;
      const evData = err || {};
      evData.methodName = "constructor";
      setTimeout(() => {
        if (err && cb === noop) {
          jimpInstance.emitError("constructor", err);
        } else if (!err) {
          jimpInstance.emitMulti("constructor", "initialized");
        }
        cb.call(jimpInstance, ...args2);
      }, 1);
    }
    if (typeof args[0] === "number" && typeof args[1] === "number" || parseInt(args[0], 10) && parseInt(args[1], 10)) {
      const w = parseInt(args[0], 10);
      const h = parseInt(args[1], 10);
      cb = args[2];
      if (typeof args[2] === "number") {
        this._background = args[2];
        cb = args[3];
      }
      if (typeof args[2] === "string") {
        this._background = Jimp.cssColorToHex(args[2]);
        cb = args[3];
      }
      if (typeof cb === "undefined") {
        cb = noop;
      }
      if (typeof cb !== "function") {
        return throwError.call(this, "cb must be a function", finish);
      }
      this.bitmap = {
        data: Buffer.alloc(w * h * 4),
        width: w,
        height: h
      };
      for (let i2 = 0;i2 < this.bitmap.data.length; i2 += 4) {
        this.bitmap.data.writeUInt32BE(this._background, i2);
      }
      finish(null, this);
    } else if (typeof args[0] === "object" && args[0].url) {
      cb = args[1] || noop;
      if (typeof cb !== "function") {
        return throwError.call(this, "cb must be a function", finish);
      }
      loadFromURL(args[0], (err, data2) => {
        if (err) {
          return throwError.call(this, err, finish);
        }
        this.parseBitmap(data2, args[0].url, finish);
      });
    } else if (args[0] instanceof Jimp) {
      const [original] = args;
      cb = args[1];
      if (typeof cb === "undefined") {
        cb = noop;
      }
      if (typeof cb !== "function") {
        return throwError.call(this, "cb must be a function", finish);
      }
      this.bitmap = {
        data: Buffer.from(original.bitmap.data),
        width: original.bitmap.width,
        height: original.bitmap.height
      };
      this._quality = original._quality;
      this._deflateLevel = original._deflateLevel;
      this._deflateStrategy = original._deflateStrategy;
      this._filterType = original._filterType;
      this._rgba = original._rgba;
      this._background = original._background;
      this._originalMime = original._originalMime;
      finish(null, this);
    } else if (isRawRGBAData(args[0])) {
      const [imageData] = args;
      cb = args[1] || noop;
      const isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;
      const buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
      this.bitmap = {
        data: buffer,
        width: imageData.width,
        height: imageData.height
      };
      finish(null, this);
    } else if (typeof args[0] === "string") {
      const path2 = args[0];
      cb = args[1];
      if (typeof cb === "undefined") {
        cb = noop;
      }
      if (typeof cb !== "function") {
        return throwError.call(this, "cb must be a function", finish);
      }
      loadBufferFromPath(path2, (err, data2) => {
        if (err) {
          return throwError.call(this, err, finish);
        }
        this.parseBitmap(data2, path2, finish);
      });
    } else if (typeof args[0] === "object" && Buffer.isBuffer(args[0])) {
      const data2 = args[0];
      cb = args[1];
      if (typeof cb !== "function") {
        return throwError.call(this, "cb must be a function", finish);
      }
      this.parseBitmap(data2, null, finish);
    } else {
      cb = args[args.length - 1];
      if (typeof cb !== "function") {
        cb = args[args.length - 2];
        if (typeof cb !== "function") {
          cb = noop;
        }
      }
      const extraConstructor = Jimp.__extraConstructors.find((c2) => c2.test(...args));
      if (extraConstructor) {
        new Promise((resolve2, reject2) => {
          extraConstructor.run.call(this, resolve2, reject2, ...args);
        }).then(() => finish(null, this)).catch(finish);
      } else {
        return throwError.call(this, "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", finish);
      }
    }
  }
  parseBitmap(data2, path2, finish) {
    parseBitmap.call(this, data2, null, finish);
  }
  rgba(bool, cb) {
    if (typeof bool !== "boolean") {
      return throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", cb);
    }
    this._rgba = bool;
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
  emitMulti(methodName, eventName) {
    let data2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    data2 = Object.assign(data2, {
      methodName,
      eventName
    });
    this.emit("any", data2);
    if (methodName) {
      this.emit(methodName, data2);
    }
    this.emit(eventName, data2);
  }
  emitError(methodName, err) {
    this.emitMulti(methodName, "error", err);
  }
  getHeight() {
    return this.bitmap.height;
  }
  getWidth() {
    return this.bitmap.width;
  }
  inspect() {
    return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
  }
  toString() {
    return "[object Jimp]";
  }
  getMIME() {
    const mime = this._originalMime || Jimp.MIME_PNG;
    return mime;
  }
  getExtension() {
    const mime = this.getMIME();
    return getExtension(mime);
  }
  write(path2, cb) {
    if (!fs || !fs.createWriteStream) {
      throw new Error("Cant access the filesystem. You can use the getBase64 method.");
    }
    if (typeof path2 !== "string") {
      return throwError.call(this, "path must be a string", cb);
    }
    if (typeof cb === "undefined") {
      cb = noop;
    }
    if (typeof cb !== "function") {
      return throwError.call(this, "cb must be a function", cb);
    }
    const mime = getType(path2) || this.getMIME();
    const pathObj = Path.parse(path2);
    if (pathObj.dir) {
      fs.mkdirSync(pathObj.dir, {
        recursive: true
      });
    }
    this.getBuffer(mime, (err, buffer) => {
      if (err) {
        return throwError.call(this, err, cb);
      }
      const stream2 = fs.createWriteStream(path2);
      stream2.on("open", () => {
        stream2.write(buffer);
        stream2.end();
      }).on("error", (err2) => {
        return throwError.call(this, err2, cb);
      });
      stream2.on("finish", () => {
        cb.call(this, null, this);
      });
    });
    return this;
  }
  getBase64(mime, cb) {
    if (mime === Jimp.AUTO) {
      mime = this.getMIME();
    }
    if (typeof mime !== "string") {
      return throwError.call(this, "mime must be a string", cb);
    }
    if (typeof cb !== "function") {
      return throwError.call(this, "cb must be a function", cb);
    }
    this.getBuffer(mime, function(err, data2) {
      if (err) {
        return throwError.call(this, err, cb);
      }
      const src = "data:" + mime + ";base64," + data2.toString("base64");
      cb.call(this, null, src);
    });
    return this;
  }
  hash(base, cb) {
    base = base || 64;
    if (typeof base === "function") {
      cb = base;
      base = 64;
    }
    if (typeof base !== "number") {
      return throwError.call(this, "base must be a number", cb);
    }
    if (base < 2 || base > 64) {
      return throwError.call(this, "base must be a number between 2 and 64", cb);
    }
    let hash2 = this.pHash();
    hash2 = import_any_base.default(import_any_base.default.BIN, alphabet.slice(0, base))(hash2);
    while (hash2.length < maxHashLength[base]) {
      hash2 = "0" + hash2;
    }
    if (isNodePattern(cb)) {
      cb.call(this, null, hash2);
    }
    return hash2;
  }
  pHash() {
    const pHash = new phash_default;
    return pHash.getHash(this);
  }
  distanceFromHash(compareHash) {
    const pHash = new phash_default;
    const currentHash = pHash.getHash(this);
    return pHash.distance(currentHash, compareHash);
  }
  getPixelIndex(x, y, edgeHandling, cb) {
    let xi;
    let yi;
    if (typeof edgeHandling === "function" && typeof cb === "undefined") {
      cb = edgeHandling;
      edgeHandling = null;
    }
    if (!edgeHandling) {
      edgeHandling = Jimp.EDGE_EXTEND;
    }
    if (typeof x !== "number" || typeof y !== "number") {
      return throwError.call(this, "x and y must be numbers", cb);
    }
    x = Math.round(x);
    y = Math.round(y);
    xi = x;
    yi = y;
    if (edgeHandling === Jimp.EDGE_EXTEND) {
      if (x < 0)
        xi = 0;
      if (x >= this.bitmap.width)
        xi = this.bitmap.width - 1;
      if (y < 0)
        yi = 0;
      if (y >= this.bitmap.height)
        yi = this.bitmap.height - 1;
    }
    if (edgeHandling === Jimp.EDGE_WRAP) {
      if (x < 0) {
        xi = this.bitmap.width + x;
      }
      if (x >= this.bitmap.width) {
        xi = x % this.bitmap.width;
      }
      if (y < 0) {
        yi = this.bitmap.height + y;
      }
      if (y >= this.bitmap.height) {
        yi = y % this.bitmap.height;
      }
    }
    let i2 = this.bitmap.width * yi + xi << 2;
    if (xi < 0 || xi >= this.bitmap.width) {
      i2 = -1;
    }
    if (yi < 0 || yi >= this.bitmap.height) {
      i2 = -1;
    }
    if (isNodePattern(cb)) {
      cb.call(this, null, i2);
    }
    return i2;
  }
  getPixelColor(x, y, cb) {
    if (typeof x !== "number" || typeof y !== "number")
      return throwError.call(this, "x and y must be numbers", cb);
    x = Math.round(x);
    y = Math.round(y);
    const idx = this.getPixelIndex(x, y);
    const hex = this.bitmap.data.readUInt32BE(idx);
    if (isNodePattern(cb)) {
      cb.call(this, null, hex);
    }
    return hex;
  }
  setPixelColor(hex, x, y, cb) {
    if (typeof hex !== "number" || typeof x !== "number" || typeof y !== "number")
      return throwError.call(this, "hex, x and y must be numbers", cb);
    x = Math.round(x);
    y = Math.round(y);
    const idx = this.getPixelIndex(x, y);
    this.bitmap.data.writeUInt32BE(hex, idx);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
  hasAlpha() {
    for (let yIndex = 0;yIndex < this.bitmap.height; yIndex++) {
      for (let xIndex = 0;xIndex < this.bitmap.width; xIndex++) {
        const idx = this.bitmap.width * yIndex + xIndex << 2;
        const alpha = this.bitmap.data[idx + 3];
        if (alpha !== 255) {
          return true;
        }
      }
    }
    return false;
  }
  scanIterator(x, y, w, h) {
    if (typeof x !== "number" || typeof y !== "number") {
      return throwError.call(this, "x and y must be numbers");
    }
    if (typeof w !== "number" || typeof h !== "number") {
      return throwError.call(this, "w and h must be numbers");
    }
    return scanIterator(this, x, y, w, h);
  }
}
addConstants(exports_constants);
addJimpMethods({
  composite
});
Jimp.__extraConstructors = [];
Jimp.appendConstructorOption = function(name2, test, run) {
  Jimp.__extraConstructors.push({
    name: name2,
    test,
    run
  });
};
Jimp.read = function() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;_key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  return new Promise((resolve2, reject2) => {
    new Jimp(...args, (err, image2) => {
      if (err)
        reject2(err);
      else
        resolve2(image2);
    });
  });
};
Jimp.create = Jimp.read;
Jimp.rgbaToInt = function(r, g, b, a, cb) {
  if (typeof r !== "number" || typeof g !== "number" || typeof b !== "number" || typeof a !== "number") {
    return throwError.call(this, "r, g, b and a must be numbers", cb);
  }
  if (r < 0 || r > 255) {
    return throwError.call(this, "r must be between 0 and 255", cb);
  }
  if (g < 0 || g > 255) {
    throwError.call(this, "g must be between 0 and 255", cb);
  }
  if (b < 0 || b > 255) {
    return throwError.call(this, "b must be between 0 and 255", cb);
  }
  if (a < 0 || a > 255) {
    return throwError.call(this, "a must be between 0 and 255", cb);
  }
  r = Math.round(r);
  b = Math.round(b);
  g = Math.round(g);
  a = Math.round(a);
  const i2 = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
  if (isNodePattern(cb)) {
    cb.call(this, null, i2);
  }
  return i2;
};
Jimp.intToRGBA = function(i2, cb) {
  if (typeof i2 !== "number") {
    return throwError.call(this, "i must be a number", cb);
  }
  const rgba = {};
  rgba.r = Math.floor(i2 / Math.pow(256, 3));
  rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
  rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
  rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
  if (isNodePattern(cb)) {
    cb.call(this, null, rgba);
  }
  return rgba;
};
Jimp.cssColorToHex = function(cssColor) {
  cssColor = cssColor || 0;
  if (typeof cssColor === "number")
    return Number(cssColor);
  return parseInt(tinycolor(cssColor).toHex8(), 16);
};
Jimp.limit255 = function(n) {
  n = Math.max(n, 0);
  n = Math.min(n, 255);
  return n;
};
Jimp.diff = function(img1, img2) {
  let threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp))
    return throwError.call(this, "img1 and img2 must be an Jimp images");
  const bmp1 = img1.bitmap;
  const bmp2 = img2.bitmap;
  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {
    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {
      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);
    } else {
      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);
    }
  }
  if (typeof threshold !== "number" || threshold < 0 || threshold > 1) {
    return throwError.call(this, "threshold must be a number between 0 and 1");
  }
  const diff = new Jimp(bmp1.width, bmp1.height, 4294967295);
  const numDiffPixels = import_pixelmatch.default(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
    threshold
  });
  return {
    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
    image: diff
  };
};
Jimp.distance = function(img1, img2) {
  const phash2 = new phash_default;
  const hash1 = phash2.getHash(img1);
  const hash2 = phash2.getHash(img2);
  return phash2.distance(hash1, hash2);
};
Jimp.compareHashes = function(hash1, hash2) {
  const phash2 = new phash_default;
  return phash2.distance(hash1, hash2);
};
Jimp.colorDiff = function(rgba1, rgba2) {
  const pow = (n) => Math.pow(n, 2);
  const {
    max
  } = Math;
  const maxVal = 255 * 255 * 3;
  if (rgba1.a !== 0 && !rgba1.a) {
    rgba1.a = 255;
  }
  if (rgba2.a !== 0 && !rgba2.a) {
    rgba2.a = 255;
  }
  return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;
};
jimpEvMethod("clone", "clone", function(cb) {
  const clone2 = new Jimp(this);
  if (isNodePattern(cb)) {
    cb.call(clone2, null, clone2);
  }
  return clone2;
});
jimpEvChange("background", function(hex, cb) {
  if (typeof hex !== "number") {
    return throwError.call(this, "hex must be a hexadecimal rgba value", cb);
  }
  this._background = hex;
  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }
  return this;
});
jimpEvChange("scan", function(x, y, w, h, f, cb) {
  if (typeof x !== "number" || typeof y !== "number") {
    return throwError.call(this, "x and y must be numbers", cb);
  }
  if (typeof w !== "number" || typeof h !== "number") {
    return throwError.call(this, "w and h must be numbers", cb);
  }
  if (typeof f !== "function") {
    return throwError.call(this, "f must be a function", cb);
  }
  const result = scan(this, x, y, w, h, f);
  if (isNodePattern(cb)) {
    cb.call(this, null, result);
  }
  return result;
});
if (process.env.ENVIRONMENT === "BROWSER") {
  let gl;
  if (typeof window !== "undefined" && typeof window === "object") {
    gl = window;
  }
  if (typeof self !== "undefined" && typeof self === "object") {
    gl = self;
  }
  gl.Jimp = Jimp;
  gl.Buffer = Buffer;
}
var es_default = Jimp;

// node_modules/@jimp/custom/es/index.js
function configure(configuration) {
  let jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : es_default;
  const jimpConfig = {
    hasAlpha: {},
    encoders: {},
    decoders: {},
    class: {},
    constants: {}
  };
  function addToConfig(newConfig) {
    Object.entries(newConfig).forEach((_ref) => {
      let [key, value2] = _ref;
      jimpConfig[key] = {
        ...jimpConfig[key],
        ...value2
      };
    });
  }
  function addImageType(typeModule) {
    const type = typeModule();
    if (Array.isArray(type.mime)) {
      addType(...type.mime);
    } else {
      Object.entries(type.mime).forEach((mimeType) => addType(...mimeType));
    }
    delete type.mime;
    addToConfig(type);
  }
  function addPlugin(pluginModule) {
    const plugin = pluginModule(jimpEvChange) || {};
    if (!plugin.class && !plugin.constants) {
      addToConfig({
        class: plugin
      });
    } else {
      addToConfig(plugin);
    }
  }
  if (configuration.types) {
    configuration.types.forEach(addImageType);
    jimpInstance.decoders = {
      ...jimpInstance.decoders,
      ...jimpConfig.decoders
    };
    jimpInstance.encoders = {
      ...jimpInstance.encoders,
      ...jimpConfig.encoders
    };
    jimpInstance.hasAlpha = {
      ...jimpInstance.hasAlpha,
      ...jimpConfig.hasAlpha
    };
  }
  if (configuration.plugins) {
    configuration.plugins.forEach(addPlugin);
  }
  addJimpMethods(jimpConfig.class, jimpInstance);
  addConstants(jimpConfig.constants, jimpInstance);
  return es_default;
}

// node_modules/@jimp/types/es/index.js
var import_timm = __toESM(require_timm(), 1);

// node_modules/@jimp/jpeg/es/index.js
var import_jpeg_js = __toESM(require_jpeg_js(), 1);
var MIME_TYPE = "image/jpeg";
var es_default2 = () => ({
  mime: {
    [MIME_TYPE]: ["jpeg", "jpg", "jpe"]
  },
  constants: {
    MIME_JPEG: MIME_TYPE
  },
  decoders: {
    [MIME_TYPE]: import_jpeg_js.default.decode
  },
  encoders: {
    [MIME_TYPE]: (image2) => import_jpeg_js.default.encode(image2.bitmap, image2._quality).data
  },
  class: {
    _quality: 100,
    quality(n, cb) {
      if (typeof n !== "number") {
        return throwError.call(this, "n must be a number", cb);
      }
      if (n < 0 || n > 100) {
        return throwError.call(this, "n must be a number 0 - 100", cb);
      }
      this._quality = Math.round(n);
      if (isNodePattern(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
  }
});

// node_modules/@jimp/png/es/index.js
var import_pngjs = __toESM(require_png(), 1);
var MIME_TYPE2 = "image/png";
var PNG_FILTER_AUTO = -1;
var PNG_FILTER_NONE = 0;
var PNG_FILTER_SUB = 1;
var PNG_FILTER_UP = 2;
var PNG_FILTER_AVERAGE = 3;
var PNG_FILTER_PATH = 4;
var es_default3 = () => ({
  mime: {
    [MIME_TYPE2]: ["png"]
  },
  constants: {
    MIME_PNG: MIME_TYPE2,
    PNG_FILTER_AUTO,
    PNG_FILTER_NONE,
    PNG_FILTER_SUB,
    PNG_FILTER_UP,
    PNG_FILTER_AVERAGE,
    PNG_FILTER_PATH
  },
  hasAlpha: {
    [MIME_TYPE2]: true
  },
  decoders: {
    [MIME_TYPE2]: import_pngjs.PNG.sync.read
  },
  encoders: {
    [MIME_TYPE2](data2) {
      const png = new import_pngjs.PNG({
        width: data2.bitmap.width,
        height: data2.bitmap.height
      });
      png.data = data2.bitmap.data;
      return import_pngjs.PNG.sync.write(png, {
        deflateLevel: data2._deflateLevel,
        deflateStrategy: data2._deflateStrategy,
        filterType: data2._filterType,
        colorType: typeof data2._colorType === "number" ? data2._colorType : data2._rgba ? 6 : 2,
        inputHasAlpha: data2._rgba
      });
    }
  },
  class: {
    _deflateLevel: 9,
    _deflateStrategy: 3,
    _filterType: PNG_FILTER_AUTO,
    _colorType: null,
    deflateLevel(l, cb) {
      if (typeof l !== "number") {
        return throwError.call(this, "l must be a number", cb);
      }
      if (l < 0 || l > 9) {
        return throwError.call(this, "l must be a number 0 - 9", cb);
      }
      this._deflateLevel = Math.round(l);
      if (isNodePattern(cb)) {
        cb.call(this, null, this);
      }
      return this;
    },
    deflateStrategy(s, cb) {
      if (typeof s !== "number") {
        return throwError.call(this, "s must be a number", cb);
      }
      if (s < 0 || s > 3) {
        return throwError.call(this, "s must be a number 0 - 3", cb);
      }
      this._deflateStrategy = Math.round(s);
      if (isNodePattern(cb)) {
        cb.call(this, null, this);
      }
      return this;
    },
    filterType(f, cb) {
      if (typeof f !== "number") {
        return throwError.call(this, "n must be a number", cb);
      }
      if (f < -1 || f > 4) {
        return throwError.call(this, "n must be -1 (auto) or a number 0 - 4", cb);
      }
      this._filterType = Math.round(f);
      if (isNodePattern(cb)) {
        cb.call(this, null, this);
      }
      return this;
    },
    colorType(s, cb) {
      if (typeof s !== "number") {
        return throwError.call(this, "s must be a number", cb);
      }
      if (s !== 0 && s !== 2 && s !== 4 && s !== 6) {
        return throwError.call(this, "s must be a number 0, 2, 4, 6.", cb);
      }
      this._colorType = Math.round(s);
      if (isNodePattern(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
  }
});

// node_modules/@jimp/bmp/es/index.js
var import_bmp_js = __toESM(require_bmp_js(), 1);
var toAGBR = function(image2) {
  return scan(image2, 0, 0, image2.bitmap.width, image2.bitmap.height, function(x, y, index) {
    const red = this.bitmap.data[index + 0];
    const green = this.bitmap.data[index + 1];
    const blue = this.bitmap.data[index + 2];
    const alpha = this.bitmap.data[index + 3];
    this.bitmap.data[index + 0] = alpha;
    this.bitmap.data[index + 1] = blue;
    this.bitmap.data[index + 2] = green;
    this.bitmap.data[index + 3] = red;
  }).bitmap;
};
var fromAGBR = function(bitmap) {
  return scan({
    bitmap
  }, 0, 0, bitmap.width, bitmap.height, function(x, y, index) {
    const alpha = this.bitmap.data[index + 0];
    const blue = this.bitmap.data[index + 1];
    const green = this.bitmap.data[index + 2];
    const red = this.bitmap.data[index + 3];
    this.bitmap.data[index + 0] = red;
    this.bitmap.data[index + 1] = green;
    this.bitmap.data[index + 2] = blue;
    this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 255;
  }).bitmap;
};
var MIME_TYPE3 = "image/bmp";
var MIME_TYPE_SECOND = "image/x-ms-bmp";
var decode = (data2) => fromAGBR(import_bmp_js.default.decode(data2));
var encode = (image2) => import_bmp_js.default.encode(toAGBR(image2)).data;
var es_default4 = () => ({
  mime: {
    [MIME_TYPE3]: ["bmp"]
  },
  constants: {
    MIME_BMP: MIME_TYPE3,
    MIME_X_MS_BMP: MIME_TYPE_SECOND
  },
  decoders: {
    [MIME_TYPE3]: decode,
    [MIME_TYPE_SECOND]: decode
  },
  encoders: {
    [MIME_TYPE3]: encode,
    [MIME_TYPE_SECOND]: encode
  }
});

// node_modules/@jimp/tiff/es/index.js
var import_utif2 = __toESM(require_UTIF(), 1);
var MIME_TYPE4 = "image/tiff";
var es_default5 = () => ({
  mime: {
    [MIME_TYPE4]: ["tiff", "tif"]
  },
  constants: {
    MIME_TIFF: MIME_TYPE4
  },
  decoders: {
    [MIME_TYPE4]: (data2) => {
      const ifds = import_utif2.default.decode(data2);
      const page = ifds[0];
      ifds.forEach((ifd) => {
        import_utif2.default.decodeImage(data2, ifd);
      });
      const rgba = import_utif2.default.toRGBA8(page);
      return {
        data: Buffer.from(rgba),
        width: page.t256[0],
        height: page.t257[0]
      };
    }
  },
  encoders: {
    [MIME_TYPE4]: (image2) => {
      const tiff = import_utif2.default.encodeImage(image2.bitmap.data, image2.bitmap.width, image2.bitmap.height);
      return Buffer.from(tiff);
    }
  }
});

// node_modules/@jimp/gif/es/index.js
var import_omggif = __toESM(require_omggif(), 1);
var import_gifwrap = __toESM(require_src(), 1);
var MIME_TYPE5 = "image/gif";
var es_default6 = () => ({
  mime: {
    [MIME_TYPE5]: ["gif"]
  },
  constants: {
    MIME_GIF: MIME_TYPE5
  },
  decoders: {
    [MIME_TYPE5]: (data2) => {
      const gifObj = new import_omggif.default.GifReader(data2);
      const gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
      gifObj.decodeAndBlitFrameRGBA(0, gifData);
      return {
        data: gifData,
        width: gifObj.width,
        height: gifObj.height
      };
    }
  },
  encoders: {
    [MIME_TYPE5]: (data2) => {
      const bitmap = new import_gifwrap.BitmapImage(data2.bitmap);
      import_gifwrap.GifUtil.quantizeDekker(bitmap, 256);
      const newFrame = new import_gifwrap.GifFrame(bitmap);
      const gifCodec = new import_gifwrap.GifCodec;
      return gifCodec.encodeGif([newFrame], {}).then((newGif) => {
        return newGif.buffer;
      });
    }
  }
});

// node_modules/@jimp/types/es/index.js
var es_default7 = () => import_timm.mergeDeep(es_default2(), es_default3(), es_default4(), es_default5(), es_default6());

// node_modules/@jimp/plugins/es/index.js
var import_timm2 = __toESM(require_timm(), 1);

// node_modules/@jimp/plugin-blit/es/index.js
var es_default8 = () => ({
  blit(src, x, y, srcx, srcy, srcw, srch, cb) {
    if (!(src instanceof this.constructor)) {
      return throwError.call(this, "The source must be a Jimp image", cb);
    }
    if (typeof x !== "number" || typeof y !== "number") {
      return throwError.call(this, "x and y must be numbers", cb);
    }
    if (typeof srcx === "function") {
      cb = srcx;
      srcx = 0;
      srcy = 0;
      srcw = src.bitmap.width;
      srch = src.bitmap.height;
    } else if (typeof srcx === typeof srcy && typeof srcy === typeof srcw && typeof srcw === typeof srch) {
      srcx = srcx || 0;
      srcy = srcy || 0;
      srcw = srcw || src.bitmap.width;
      srch = srch || src.bitmap.height;
    } else {
      return throwError.call(this, "srcx, srcy, srcw, srch must be numbers", cb);
    }
    x = Math.round(x);
    y = Math.round(y);
    srcx = Math.round(srcx);
    srcy = Math.round(srcy);
    srcw = Math.round(srcw);
    srch = Math.round(srch);
    const maxWidth = this.bitmap.width;
    const maxHeight = this.bitmap.height;
    const baseImage = this;
    src.scanQuiet(srcx, srcy, srcw, srch, function(sx, sy, idx) {
      const xOffset = x + sx - srcx;
      const yOffset = y + sy - srcy;
      if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
        const dstIdx = baseImage.getPixelIndex(xOffset, yOffset);
        const src2 = {
          r: this.bitmap.data[idx],
          g: this.bitmap.data[idx + 1],
          b: this.bitmap.data[idx + 2],
          a: this.bitmap.data[idx + 3]
        };
        const dst = {
          r: baseImage.bitmap.data[dstIdx],
          g: baseImage.bitmap.data[dstIdx + 1],
          b: baseImage.bitmap.data[dstIdx + 2],
          a: baseImage.bitmap.data[dstIdx + 3]
        };
        baseImage.bitmap.data[dstIdx] = (src2.a * (src2.r - dst.r) - dst.r + 255 >> 8) + dst.r;
        baseImage.bitmap.data[dstIdx + 1] = (src2.a * (src2.g - dst.g) - dst.g + 255 >> 8) + dst.g;
        baseImage.bitmap.data[dstIdx + 2] = (src2.a * (src2.b - dst.b) - dst.b + 255 >> 8) + dst.b;
        baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + src2.a);
      }
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-blur/es/blur-tables.js
var mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
var shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];

// node_modules/@jimp/plugin-blur/es/index.js
var es_default9 = () => ({
  blur(r, cb) {
    if (typeof r !== "number")
      return throwError.call(this, "r must be a number", cb);
    if (r < 1)
      return throwError.call(this, "r must be greater than 0", cb);
    let rsum;
    let gsum;
    let bsum;
    let asum;
    let x;
    let y;
    let i2;
    let p;
    let p1;
    let p2;
    let yp;
    let yi;
    let yw;
    let pa;
    const wm = this.bitmap.width - 1;
    const hm = this.bitmap.height - 1;
    const rad1 = r + 1;
    const mulSum = mulTable[r];
    const shgSum = shgTable[r];
    const red = [];
    const green = [];
    const blue = [];
    const alpha = [];
    const vmin = [];
    const vmax = [];
    let iterations = 2;
    while (iterations-- > 0) {
      yi = 0;
      yw = 0;
      for (y = 0;y < this.bitmap.height; y++) {
        rsum = this.bitmap.data[yw] * rad1;
        gsum = this.bitmap.data[yw + 1] * rad1;
        bsum = this.bitmap.data[yw + 2] * rad1;
        asum = this.bitmap.data[yw + 3] * rad1;
        for (i2 = 1;i2 <= r; i2++) {
          p = yw + ((i2 > wm ? wm : i2) << 2);
          rsum += this.bitmap.data[p++];
          gsum += this.bitmap.data[p++];
          bsum += this.bitmap.data[p++];
          asum += this.bitmap.data[p];
        }
        for (x = 0;x < this.bitmap.width; x++) {
          red[yi] = rsum;
          green[yi] = gsum;
          blue[yi] = bsum;
          alpha[yi] = asum;
          if (y === 0) {
            vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
            vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
          }
          p1 = yw + vmin[x];
          p2 = yw + vmax[x];
          rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
          gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
          bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
          asum += this.bitmap.data[p1] - this.bitmap.data[p2];
          yi++;
        }
        yw += this.bitmap.width << 2;
      }
      for (x = 0;x < this.bitmap.width; x++) {
        yp = x;
        rsum = red[yp] * rad1;
        gsum = green[yp] * rad1;
        bsum = blue[yp] * rad1;
        asum = alpha[yp] * rad1;
        for (i2 = 1;i2 <= r; i2++) {
          yp += i2 > hm ? 0 : this.bitmap.width;
          rsum += red[yp];
          gsum += green[yp];
          bsum += blue[yp];
          asum += alpha[yp];
        }
        yi = x << 2;
        for (y = 0;y < this.bitmap.height; y++) {
          pa = asum * mulSum >>> shgSum;
          this.bitmap.data[yi + 3] = pa;
          if (pa > 255) {
            this.bitmap.data[yi + 3] = 255;
          }
          if (pa > 0) {
            pa = 255 / pa;
            this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa;
            this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;
            this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;
          } else {
            this.bitmap.data[yi + 2] = 0;
            this.bitmap.data[yi + 1] = 0;
            this.bitmap.data[yi] = 0;
          }
          if (x === 0) {
            vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;
            vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0;
          }
          p1 = x + vmin[y];
          p2 = x + vmax[y];
          rsum += red[p1] - red[p2];
          gsum += green[p1] - green[p2];
          bsum += blue[p1] - blue[p2];
          asum += alpha[p1] - alpha[p2];
          yi += this.bitmap.width << 2;
        }
      }
    }
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-circle/es/index.js
var es_default10 = () => ({
  circle() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let cb = arguments.length > 1 ? arguments[1] : undefined;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    const radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2;
    const center = {
      x: typeof options.x === "number" ? options.x : this.bitmap.width / 2,
      y: typeof options.y === "number" ? options.y : this.bitmap.height / 2
    };
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
      if (radius - curR <= 0) {
        this.bitmap.data[idx + 3] = 0;
      } else if (radius - curR < 1) {
        this.bitmap.data[idx + 3] = 255 * (radius - curR);
      }
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-color/es/index.js
var applyKernel = function(im, kernel, x, y) {
  const value2 = [0, 0, 0];
  const size = (kernel.length - 1) / 2;
  for (let kx = 0;kx < kernel.length; kx += 1) {
    for (let ky = 0;ky < kernel[kx].length; ky += 1) {
      const idx = im.getPixelIndex(x + kx - size, y + ky - size);
      value2[0] += im.bitmap.data[idx] * kernel[kx][ky];
      value2[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];
      value2[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
    }
  }
  return value2;
};
var greyscale2 = function(cb) {
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
    const grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
    this.bitmap.data[idx] = grey;
    this.bitmap.data[idx + 1] = grey;
    this.bitmap.data[idx + 2] = grey;
  });
  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }
  return this;
};
var mix = function(clr, clr2) {
  let p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;
  return {
    r: (clr2.r - clr.r) * (p / 100) + clr.r,
    g: (clr2.g - clr.g) * (p / 100) + clr.g,
    b: (clr2.b - clr.b) * (p / 100) + clr.b
  };
};
var colorFn = function(actions, cb) {
  if (!actions || !Array.isArray(actions)) {
    return throwError.call(this, "actions must be an array", cb);
  }
  actions = actions.map((action) => {
    if (action.apply === "xor" || action.apply === "mix") {
      action.params[0] = tinycolor(action.params[0]).toRgb();
    }
    return action;
  });
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
    let clr = {
      r: this.bitmap.data[idx],
      g: this.bitmap.data[idx + 1],
      b: this.bitmap.data[idx + 2]
    };
    const colorModifier = (i2, amount) => this.constructor.limit255(clr[i2] + amount);
    actions.forEach((action) => {
      if (action.apply === "mix") {
        clr = mix(clr, action.params[0], action.params[1]);
      } else if (action.apply === "tint") {
        clr = mix(clr, {
          r: 255,
          g: 255,
          b: 255
        }, action.params[0]);
      } else if (action.apply === "shade") {
        clr = mix(clr, {
          r: 0,
          g: 0,
          b: 0
        }, action.params[0]);
      } else if (action.apply === "xor") {
        clr = {
          r: clr.r ^ action.params[0].r,
          g: clr.g ^ action.params[0].g,
          b: clr.b ^ action.params[0].b
        };
      } else if (action.apply === "red") {
        clr.r = colorModifier("r", action.params[0]);
      } else if (action.apply === "green") {
        clr.g = colorModifier("g", action.params[0]);
      } else if (action.apply === "blue") {
        clr.b = colorModifier("b", action.params[0]);
      } else {
        if (action.apply === "hue") {
          action.apply = "spin";
        }
        clr = tinycolor(clr);
        if (!clr[action.apply]) {
          return throwError.call(this, "action " + action.apply + " not supported", cb);
        }
        clr = clr[action.apply](...action.params).toRgb();
      }
    });
    this.bitmap.data[idx] = clr.r;
    this.bitmap.data[idx + 1] = clr.g;
    this.bitmap.data[idx + 2] = clr.b;
  });
  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }
  return this;
};
var isDef = (v) => typeof v !== "undefined" && v !== null;
var ColorActionName = Object.freeze({
  LIGHTEN: "lighten",
  BRIGHTEN: "brighten",
  DARKEN: "darken",
  DESATURATE: "desaturate",
  SATURATE: "saturate",
  GREYSCALE: "greyscale",
  SPIN: "spin",
  HUE: "hue",
  MIX: "mix",
  TINT: "tint",
  SHADE: "shade",
  XOR: "xor",
  RED: "red",
  GREEN: "green",
  BLUE: "blue"
});
var es_default11 = () => ({
  brightness(val, cb) {
    if (typeof val !== "number") {
      return throwError.call(this, "val must be numbers", cb);
    }
    if (val < -1 || val > 1) {
      return throwError.call(this, "val must be a number between -1 and +1", cb);
    }
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      if (val < 0) {
        this.bitmap.data[idx] *= 1 + val;
        this.bitmap.data[idx + 1] *= 1 + val;
        this.bitmap.data[idx + 2] *= 1 + val;
      } else {
        this.bitmap.data[idx] += (255 - this.bitmap.data[idx]) * val;
        this.bitmap.data[idx + 1] += (255 - this.bitmap.data[idx + 1]) * val;
        this.bitmap.data[idx + 2] += (255 - this.bitmap.data[idx + 2]) * val;
      }
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  contrast(val, cb) {
    if (typeof val !== "number") {
      return throwError.call(this, "val must be numbers", cb);
    }
    if (val < -1 || val > 1) {
      return throwError.call(this, "val must be a number between -1 and +1", cb);
    }
    const factor = (val + 1) / (1 - val);
    function adjust(value2) {
      value2 = Math.floor(factor * (value2 - 127) + 127);
      return value2 < 0 ? 0 : value2 > 255 ? 255 : value2;
    }
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);
      this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);
      this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  posterize(n, cb) {
    if (typeof n !== "number") {
      return throwError.call(this, "n must be numbers", cb);
    }
    if (n < 2) {
      n = 2;
    }
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;
      this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;
      this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  greyscale: greyscale2,
  grayscale: greyscale2,
  opacity(f, cb) {
    if (typeof f !== "number")
      return throwError.call(this, "f must be a number", cb);
    if (f < 0 || f > 1)
      return throwError.call(this, "f must be a number from 0 to 1", cb);
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      const v = this.bitmap.data[idx + 3] * f;
      this.bitmap.data[idx + 3] = v;
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  sepia(cb) {
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      let red = this.bitmap.data[idx];
      let green = this.bitmap.data[idx + 1];
      let blue = this.bitmap.data[idx + 2];
      red = red * 0.393 + green * 0.769 + blue * 0.189;
      green = red * 0.349 + green * 0.686 + blue * 0.168;
      blue = red * 0.272 + green * 0.534 + blue * 0.131;
      this.bitmap.data[idx] = red < 255 ? red : 255;
      this.bitmap.data[idx + 1] = green < 255 ? green : 255;
      this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  fade(f, cb) {
    if (typeof f !== "number") {
      return throwError.call(this, "f must be a number", cb);
    }
    if (f < 0 || f > 1) {
      return throwError.call(this, "f must be a number from 0 to 1", cb);
    }
    this.opacity(1 - f);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  convolution(kernel, edgeHandling, cb) {
    if (typeof edgeHandling === "function" && typeof cb === "undefined") {
      cb = edgeHandling;
      edgeHandling = null;
    }
    if (!edgeHandling) {
      edgeHandling = this.constructor.EDGE_EXTEND;
    }
    const newData = Buffer.from(this.bitmap.data);
    const kRows = kernel.length;
    const kCols = kernel[0].length;
    const rowEnd = Math.floor(kRows / 2);
    const colEnd = Math.floor(kCols / 2);
    const rowIni = -rowEnd;
    const colIni = -colEnd;
    let weight;
    let rSum;
    let gSum;
    let bSum;
    let ri;
    let gi;
    let bi;
    let xi;
    let yi;
    let idxi;
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      bSum = 0;
      gSum = 0;
      rSum = 0;
      for (let row = rowIni;row <= rowEnd; row++) {
        for (let col = colIni;col <= colEnd; col++) {
          xi = x + col;
          yi = y + row;
          weight = kernel[row + rowEnd][col + colEnd];
          idxi = this.getPixelIndex(xi, yi, edgeHandling);
          if (idxi === -1) {
            bi = 0;
            gi = 0;
            ri = 0;
          } else {
            ri = this.bitmap.data[idxi + 0];
            gi = this.bitmap.data[idxi + 1];
            bi = this.bitmap.data[idxi + 2];
          }
          rSum += weight * ri;
          gSum += weight * gi;
          bSum += weight * bi;
        }
      }
      if (rSum < 0) {
        rSum = 0;
      }
      if (gSum < 0) {
        gSum = 0;
      }
      if (bSum < 0) {
        bSum = 0;
      }
      if (rSum > 255) {
        rSum = 255;
      }
      if (gSum > 255) {
        gSum = 255;
      }
      if (bSum > 255) {
        bSum = 255;
      }
      newData[idx + 0] = rSum;
      newData[idx + 1] = gSum;
      newData[idx + 2] = bSum;
    });
    this.bitmap.data = newData;
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  opaque(cb) {
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      this.bitmap.data[idx + 3] = 255;
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  pixelate(size, x, y, w, h, cb) {
    if (typeof x === "function") {
      cb = x;
      h = null;
      w = null;
      y = null;
      x = null;
    } else {
      if (typeof size !== "number") {
        return throwError.call(this, "size must be a number", cb);
      }
      if (isDef(x) && typeof x !== "number") {
        return throwError.call(this, "x must be a number", cb);
      }
      if (isDef(y) && typeof y !== "number") {
        return throwError.call(this, "y must be a number", cb);
      }
      if (isDef(w) && typeof w !== "number") {
        return throwError.call(this, "w must be a number", cb);
      }
      if (isDef(h) && typeof h !== "number") {
        return throwError.call(this, "h must be a number", cb);
      }
    }
    const kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
    x = x || 0;
    y = y || 0;
    w = isDef(w) ? w : this.bitmap.width - x;
    h = isDef(h) ? h : this.bitmap.height - y;
    const source = this.cloneQuiet();
    this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
      xx = size * Math.floor(xx / size);
      yx = size * Math.floor(yx / size);
      const value2 = applyKernel(source, kernel, xx, yx);
      this.bitmap.data[idx] = value2[0];
      this.bitmap.data[idx + 1] = value2[1];
      this.bitmap.data[idx + 2] = value2[2];
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  convolute(kernel, x, y, w, h, cb) {
    if (!Array.isArray(kernel))
      return throwError.call(this, "the kernel must be an array", cb);
    if (typeof x === "function") {
      cb = x;
      x = null;
      y = null;
      w = null;
      h = null;
    } else {
      if (isDef(x) && typeof x !== "number") {
        return throwError.call(this, "x must be a number", cb);
      }
      if (isDef(y) && typeof y !== "number") {
        return throwError.call(this, "y must be a number", cb);
      }
      if (isDef(w) && typeof w !== "number") {
        return throwError.call(this, "w must be a number", cb);
      }
      if (isDef(h) && typeof h !== "number") {
        return throwError.call(this, "h must be a number", cb);
      }
    }
    x = isDef(x) ? x : 0;
    y = isDef(y) ? y : 0;
    w = isDef(w) ? w : this.bitmap.width - x;
    h = isDef(h) ? h : this.bitmap.height - y;
    const source = this.cloneQuiet();
    this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
      const value2 = applyKernel(source, kernel, xx, yx);
      this.bitmap.data[idx] = this.constructor.limit255(value2[0]);
      this.bitmap.data[idx + 1] = this.constructor.limit255(value2[1]);
      this.bitmap.data[idx + 2] = this.constructor.limit255(value2[2]);
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  color: colorFn,
  colour: colorFn
});

// node_modules/@jimp/plugin-contain/es/index.js
var es_default12 = () => ({
  contain(w, h, alignBits, mode, cb) {
    if (typeof w !== "number" || typeof h !== "number") {
      return throwError.call(this, "w and h must be numbers", cb);
    }
    if (typeof alignBits === "string") {
      if (typeof mode === "function" && typeof cb === "undefined")
        cb = mode;
      mode = alignBits;
      alignBits = null;
    }
    if (typeof alignBits === "function") {
      if (typeof cb === "undefined")
        cb = alignBits;
      mode = null;
      alignBits = null;
    }
    if (typeof mode === "function" && typeof cb === "undefined") {
      cb = mode;
      mode = null;
    }
    alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
    const hbits = alignBits & (1 << 3) - 1;
    const vbits = alignBits >> 3;
    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
      return throwError.call(this, "only use one flag per alignment direction", cb);
    }
    const alignH = hbits >> 1;
    const alignV = vbits >> 1;
    const f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
    const c2 = this.cloneQuiet().scale(f, mode);
    this.resize(w, h, mode);
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      this.bitmap.data.writeUInt32BE(this._background, idx);
    });
    this.blit(c2, (this.bitmap.width - c2.bitmap.width) / 2 * alignH, (this.bitmap.height - c2.bitmap.height) / 2 * alignV);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-cover/es/index.js
var es_default13 = () => ({
  cover(w, h, alignBits, mode, cb) {
    if (typeof w !== "number" || typeof h !== "number") {
      return throwError.call(this, "w and h must be numbers", cb);
    }
    if (alignBits && typeof alignBits === "function" && typeof cb === "undefined") {
      cb = alignBits;
      alignBits = null;
      mode = null;
    } else if (typeof mode === "function" && typeof cb === "undefined") {
      cb = mode;
      mode = null;
    }
    alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
    const hbits = alignBits & (1 << 3) - 1;
    const vbits = alignBits >> 3;
    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1)))
      return throwError.call(this, "only use one flag per alignment direction", cb);
    const alignH = hbits >> 1;
    const alignV = vbits >> 1;
    const f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
    this.scale(f, mode);
    this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-crop/es/index.js
function pluginCrop(event) {
  event("crop", function(x, y, w, h, cb) {
    if (typeof x !== "number" || typeof y !== "number")
      return throwError.call(this, "x and y must be numbers", cb);
    if (typeof w !== "number" || typeof h !== "number")
      return throwError.call(this, "w and h must be numbers", cb);
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    if (x === 0 && w === this.bitmap.width) {
      const start = w * y + x << 2;
      const end = start + (h * w << 2);
      this.bitmap.data = this.bitmap.data.slice(start, end);
    } else {
      const bitmap = Buffer.allocUnsafe(w * h * 4);
      let offset = 0;
      this.scanQuiet(x, y, w, h, function(x2, y2, idx) {
        const data2 = this.bitmap.data.readUInt32BE(idx, true);
        bitmap.writeUInt32BE(data2, offset, true);
        offset += 4;
      });
      this.bitmap.data = bitmap;
    }
    this.bitmap.width = w;
    this.bitmap.height = h;
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  });
  return {
    class: {
      autocrop() {
        const w = this.bitmap.width;
        const h = this.bitmap.height;
        const minPixelsPerSide = 1;
        let cb;
        let leaveBorder = 0;
        let tolerance = 0.0002;
        let cropOnlyFrames = true;
        let cropSymmetric = false;
        let ignoreSides = {
          north: false,
          south: false,
          east: false,
          west: false
        };
        for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        for (let a = 0, len = args.length;a < len; a++) {
          if (typeof args[a] === "number") {
            tolerance = args[a];
          }
          if (typeof args[a] === "boolean") {
            cropOnlyFrames = args[a];
          }
          if (typeof args[a] === "function") {
            cb = args[a];
          }
          if (typeof args[a] === "object") {
            const config = args[a];
            if (typeof config.tolerance !== "undefined") {
              ({
                tolerance
              } = config);
            }
            if (typeof config.cropOnlyFrames !== "undefined") {
              ({
                cropOnlyFrames
              } = config);
            }
            if (typeof config.cropSymmetric !== "undefined") {
              ({
                cropSymmetric
              } = config);
            }
            if (typeof config.leaveBorder !== "undefined") {
              ({
                leaveBorder
              } = config);
            }
            if (typeof config.ignoreSides !== "undefined") {
              ({
                ignoreSides
              } = config);
            }
          }
        }
        let colorTarget = this.getPixelColor(0, 0);
        const rgba1 = this.constructor.intToRGBA(colorTarget);
        let northPixelsToCrop = 0;
        let eastPixelsToCrop = 0;
        let southPixelsToCrop = 0;
        let westPixelsToCrop = 0;
        colorTarget = this.getPixelColor(0, 0);
        if (!ignoreSides.north) {
          north:
            for (let y = 0;y < h - minPixelsPerSide; y++) {
              for (let x = 0;x < w; x++) {
                const colorXY = this.getPixelColor(x, y);
                const rgba2 = this.constructor.intToRGBA(colorXY);
                if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                  break north;
                }
              }
              northPixelsToCrop++;
            }
        }
        colorTarget = this.getPixelColor(w, 0);
        if (!ignoreSides.west) {
          west:
            for (let x = 0;x < w - minPixelsPerSide; x++) {
              for (let y = 0 + northPixelsToCrop;y < h; y++) {
                const colorXY = this.getPixelColor(x, y);
                const rgba2 = this.constructor.intToRGBA(colorXY);
                if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                  break west;
                }
              }
              westPixelsToCrop++;
            }
        }
        colorTarget = this.getPixelColor(0, h);
        if (!ignoreSides.south) {
          south:
            for (let y = h - 1;y >= northPixelsToCrop + minPixelsPerSide; y--) {
              for (let x = w - eastPixelsToCrop - 1;x >= 0; x--) {
                const colorXY = this.getPixelColor(x, y);
                const rgba2 = this.constructor.intToRGBA(colorXY);
                if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                  break south;
                }
              }
              southPixelsToCrop++;
            }
        }
        colorTarget = this.getPixelColor(w, h);
        if (!ignoreSides.east) {
          east:
            for (let x = w - 1;x >= 0 + westPixelsToCrop + minPixelsPerSide; x--) {
              for (let y = h - 1;y >= 0 + northPixelsToCrop; y--) {
                const colorXY = this.getPixelColor(x, y);
                const rgba2 = this.constructor.intToRGBA(colorXY);
                if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                  break east;
                }
              }
              eastPixelsToCrop++;
            }
        }
        let doCrop = false;
        westPixelsToCrop -= leaveBorder;
        eastPixelsToCrop -= leaveBorder;
        northPixelsToCrop -= leaveBorder;
        southPixelsToCrop -= leaveBorder;
        if (cropSymmetric) {
          const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
          const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
          westPixelsToCrop = horizontal;
          eastPixelsToCrop = horizontal;
          northPixelsToCrop = vertical;
          southPixelsToCrop = vertical;
        }
        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
        const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
        const heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
        if (cropOnlyFrames) {
          doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
        } else {
          doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
        }
        if (doCrop) {
          this.crop(westPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);
        }
        if (isNodePattern(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    }
  };
}

// node_modules/@jimp/plugin-displace/es/index.js
var es_default14 = () => ({
  displace(map, offset, cb) {
    if (typeof map !== "object" || map.constructor !== this.constructor) {
      return throwError.call(this, "The source must be a Jimp image", cb);
    }
    if (typeof offset !== "number") {
      return throwError.call(this, "factor must be a number", cb);
    }
    const source = this.cloneQuiet();
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      let displacement = map.bitmap.data[idx] / 256 * offset;
      displacement = Math.round(displacement);
      const ids = this.getPixelIndex(x + displacement, y);
      this.bitmap.data[ids] = source.bitmap.data[idx];
      this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
      this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-dither/es/index.js
var dither = function(cb) {
  const rgb565Matrix = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
    const thresholdId = ((y & 3) << 2) + x % 4;
    const dither2 = rgb565Matrix[thresholdId];
    this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither2, 255);
    this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither2, 255);
    this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither2, 255);
  });
  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }
  return this;
};
var es_default15 = () => ({
  dither565: dither,
  dither16: dither
});

// node_modules/@jimp/plugin-fisheye/es/index.js
var es_default16 = () => ({
  fisheye() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      r: 2.5
    };
    let cb = arguments.length > 1 ? arguments[1] : undefined;
    if (typeof options === "function") {
      cb = options;
      options = {
        r: 2.5
      };
    }
    const source = this.cloneQuiet();
    const {
      width,
      height
    } = source.bitmap;
    source.scanQuiet(0, 0, width, height, (x, y) => {
      const hx = x / width;
      const hy = y / height;
      const r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
      const rn = 2 * Math.pow(r, options.r);
      const cosA = (hx - 0.5) / r;
      const sinA = (hy - 0.5) / r;
      const newX = Math.round((rn * cosA + 0.5) * width);
      const newY = Math.round((rn * sinA + 0.5) * height);
      const color = source.getPixelColor(newX, newY);
      this.setPixelColor(color, x, y);
    });
    this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-flip/es/index.js
var flipFn = function(horizontal, vertical, cb) {
  if (typeof horizontal !== "boolean" || typeof vertical !== "boolean")
    return throwError.call(this, "horizontal and vertical must be Booleans", cb);
  const bitmap = Buffer.alloc(this.bitmap.data.length);
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
    const _x = horizontal ? this.bitmap.width - 1 - x : x;
    const _y = vertical ? this.bitmap.height - 1 - y : y;
    const _idx = this.bitmap.width * _y + _x << 2;
    const data2 = this.bitmap.data.readUInt32BE(idx);
    bitmap.writeUInt32BE(data2, _idx);
  });
  this.bitmap.data = Buffer.from(bitmap);
  if (isNodePattern(cb)) {
    cb.call(this, null, this);
  }
  return this;
};
var es_default17 = () => ({
  flip: flipFn,
  mirror: flipFn
});

// node_modules/@jimp/plugin-gaussian/es/index.js
var es_default18 = () => ({
  gaussian(r, cb) {
    if (typeof r !== "number") {
      return throwError.call(this, "r must be a number", cb);
    }
    if (r < 1) {
      return throwError.call(this, "r must be greater than 0", cb);
    }
    const rs = Math.ceil(r * 2.57);
    const range = rs * 2 + 1;
    const rr2 = r * r * 2;
    const rr2pi = rr2 * Math.PI;
    const weights = [];
    for (let y = 0;y < range; y++) {
      weights[y] = [];
      for (let x = 0;x < range; x++) {
        const dsq = (x - rs) ** 2 + (y - rs) ** 2;
        weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
      }
    }
    for (let y = 0;y < this.bitmap.height; y++) {
      for (let x = 0;x < this.bitmap.width; x++) {
        let red = 0;
        let green = 0;
        let blue = 0;
        let alpha = 0;
        let wsum = 0;
        for (let iy = 0;iy < range; iy++) {
          for (let ix = 0;ix < range; ix++) {
            const x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + x - rs));
            const y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + y - rs));
            const weight = weights[iy][ix];
            const idx2 = y1 * this.bitmap.width + x1 << 2;
            red += this.bitmap.data[idx2] * weight;
            green += this.bitmap.data[idx2 + 1] * weight;
            blue += this.bitmap.data[idx2 + 2] * weight;
            alpha += this.bitmap.data[idx2 + 3] * weight;
            wsum += weight;
          }
          const idx = y * this.bitmap.width + x << 2;
          this.bitmap.data[idx] = Math.round(red / wsum);
          this.bitmap.data[idx + 1] = Math.round(green / wsum);
          this.bitmap.data[idx + 2] = Math.round(blue / wsum);
          this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
        }
      }
    }
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-invert/es/index.js
var es_default19 = () => ({
  invert(cb) {
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      this.bitmap.data[idx] = 255 - this.bitmap.data[idx];
      this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1];
      this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-mask/es/index.js
var es_default20 = () => ({
  mask(src) {
    let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let cb = arguments.length > 3 ? arguments[3] : undefined;
    if (!(src instanceof this.constructor)) {
      return throwError.call(this, "The source must be a Jimp image", cb);
    }
    if (typeof x !== "number" || typeof y !== "number") {
      return throwError.call(this, "x and y must be numbers", cb);
    }
    x = Math.round(x);
    y = Math.round(y);
    const w = this.bitmap.width;
    const h = this.bitmap.height;
    const baseImage = this;
    src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
      const destX = x + sx;
      const destY = y + sy;
      if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
        const dstIdx = baseImage.getPixelIndex(destX, destY);
        const {
          data: data2
        } = this.bitmap;
        const avg = (data2[idx + 0] + data2[idx + 1] + data2[idx + 2]) / 3;
        baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
      }
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-normalize/es/index.js
var histogram = function() {
  const histogram2 = {
    r: new Array(256).fill(0),
    g: new Array(256).fill(0),
    b: new Array(256).fill(0)
  };
  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, index) {
    histogram2.r[this.bitmap.data[index + 0]]++;
    histogram2.g[this.bitmap.data[index + 1]]++;
    histogram2.b[this.bitmap.data[index + 2]]++;
  });
  return histogram2;
};
var normalize = function(value2, min, max) {
  return (value2 - min) * 255 / (max - min);
};
var getBounds = function(histogramChannel) {
  return [histogramChannel.findIndex((value2) => value2 > 0), 255 - histogramChannel.slice().reverse().findIndex((value2) => value2 > 0)];
};
var es_default21 = () => ({
  normalize(cb) {
    const h = histogram.call(this);
    const bounds = {
      r: getBounds(h.r),
      g: getBounds(h.g),
      b: getBounds(h.b)
    };
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      const r = this.bitmap.data[idx + 0];
      const g = this.bitmap.data[idx + 1];
      const b = this.bitmap.data[idx + 2];
      this.bitmap.data[idx + 0] = normalize(r, bounds.r[0], bounds.r[1]);
      this.bitmap.data[idx + 1] = normalize(g, bounds.g[0], bounds.g[1]);
      this.bitmap.data[idx + 2] = normalize(b, bounds.b[0], bounds.b[1]);
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-print/es/index.js
var import_load_bmfont = __toESM(require_load_bmfont(), 1);
import Path2 from "path";

// node_modules/@jimp/plugin-print/es/measure-text.js
function measureText(font, text) {
  let x = 0;
  for (let i2 = 0;i2 < text.length; i2++) {
    if (font.chars[text[i2]]) {
      const kerning = font.kernings[text[i2]] && font.kernings[text[i2]][text[i2 + 1]] ? font.kernings[text[i2]][text[i2 + 1]] : 0;
      x += (font.chars[text[i2]].xadvance || 0) + kerning;
    }
  }
  return x;
}
function splitLines(font, text, maxWidth) {
  const words = text.split(" ");
  const lines = [];
  let currentLine = [];
  let longestLine = 0;
  words.forEach((word) => {
    const line = [...currentLine, word].join(" ");
    const length = measureText(font, line);
    if (length <= maxWidth) {
      if (length > longestLine) {
        longestLine = length;
      }
      currentLine.push(word);
    } else {
      lines.push(currentLine);
      currentLine = [word];
    }
  });
  lines.push(currentLine);
  return {
    lines,
    longestLine
  };
}
function measureTextHeight(font, text, maxWidth) {
  const {
    lines
  } = splitLines(font, text, maxWidth);
  return lines.length * font.common.lineHeight;
}

// node_modules/@jimp/plugin-print/es/index.js
var xOffsetBasedOnAlignment = function(constants2, font, line, maxWidth, alignment) {
  if (alignment === constants2.HORIZONTAL_ALIGN_LEFT) {
    return 0;
  }
  if (alignment === constants2.HORIZONTAL_ALIGN_CENTER) {
    return (maxWidth - measureText(font, line)) / 2;
  }
  return maxWidth - measureText(font, line);
};
var drawCharacter = function(image2, font, x, y, char) {
  if (char.width > 0 && char.height > 0) {
    const characterPage = font.pages[char.page];
    image2.blit(characterPage, x + char.xoffset, y + char.yoffset, char.x, char.y, char.width, char.height);
  }
  return image2;
};
var printText = function(font, x, y, text, defaultCharWidth) {
  for (let i2 = 0;i2 < text.length; i2++) {
    let char;
    if (font.chars[text[i2]]) {
      char = text[i2];
    } else if (/\s/.test(text[i2])) {
      char = "";
    } else {
      char = "?";
    }
    const fontChar = font.chars[char] || {};
    const fontKerning = font.kernings[char];
    drawCharacter(this, font, x, y, fontChar || {});
    const kerning = fontKerning && fontKerning[text[i2 + 1]] ? fontKerning[text[i2 + 1]] : 0;
    x += kerning + (fontChar.xadvance || defaultCharWidth);
  }
};
var loadPages = function(Jimp2, dir, pages) {
  const newPages = pages.map((page) => {
    return Jimp2.read(dir + "/" + page);
  });
  return Promise.all(newPages);
};
var __dirname = "/home/shiro/Projet/Image-Processing/steganegany/node_modules/@jimp/plugin-print/es";
var dir = process.env.DIRNAME || `${__dirname}/../`;
var es_default22 = () => ({
  constants: {
    measureText,
    measureTextHeight,
    FONT_SANS_8_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
    FONT_SANS_10_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
    FONT_SANS_12_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
    FONT_SANS_14_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
    FONT_SANS_16_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
    FONT_SANS_32_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
    FONT_SANS_64_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
    FONT_SANS_128_BLACK: Path2.join(dir, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
    FONT_SANS_8_WHITE: Path2.join(dir, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
    FONT_SANS_16_WHITE: Path2.join(dir, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
    FONT_SANS_32_WHITE: Path2.join(dir, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
    FONT_SANS_64_WHITE: Path2.join(dir, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
    FONT_SANS_128_WHITE: Path2.join(dir, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
    loadFont(file, cb) {
      if (typeof file !== "string")
        return throwError.call(this, "file must be a string", cb);
      return new Promise((resolve2, reject2) => {
        cb = cb || function(err, font) {
          if (err)
            reject2(err);
          else
            resolve2(font);
        };
        import_load_bmfont.default(file, (err, font) => {
          const chars = {};
          const kernings = {};
          if (err) {
            return throwError.call(this, err, cb);
          }
          for (let i2 = 0;i2 < font.chars.length; i2++) {
            chars[String.fromCharCode(font.chars[i2].id)] = font.chars[i2];
          }
          for (let i2 = 0;i2 < font.kernings.length; i2++) {
            const firstString = String.fromCharCode(font.kernings[i2].first);
            kernings[firstString] = kernings[firstString] || {};
            kernings[firstString][String.fromCharCode(font.kernings[i2].second)] = font.kernings[i2].amount;
          }
          loadPages(this, Path2.dirname(file), font.pages).then((pages) => {
            cb(null, {
              chars,
              kernings,
              pages,
              common: font.common,
              info: font.info
            });
          });
        });
      });
    }
  },
  class: {
    print(font, x, y, text, maxWidth, maxHeight, cb) {
      if (typeof maxWidth === "function" && typeof cb === "undefined") {
        cb = maxWidth;
        maxWidth = Infinity;
      }
      if (typeof maxWidth === "undefined") {
        maxWidth = Infinity;
      }
      if (typeof maxHeight === "function" && typeof cb === "undefined") {
        cb = maxHeight;
        maxHeight = Infinity;
      }
      if (typeof maxHeight === "undefined") {
        maxHeight = Infinity;
      }
      if (typeof font !== "object") {
        return throwError.call(this, "font must be a Jimp loadFont", cb);
      }
      if (typeof x !== "number" || typeof y !== "number" || typeof maxWidth !== "number") {
        return throwError.call(this, "x, y and maxWidth must be numbers", cb);
      }
      if (typeof maxWidth !== "number") {
        return throwError.call(this, "maxWidth must be a number", cb);
      }
      if (typeof maxHeight !== "number") {
        return throwError.call(this, "maxHeight must be a number", cb);
      }
      let alignmentX;
      let alignmentY;
      if (typeof text === "object" && text.text !== null && text.text !== undefined) {
        alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;
        alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
        ({
          text
        } = text);
      } else {
        alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;
        alignmentY = this.constructor.VERTICAL_ALIGN_TOP;
        text = text.toString();
      }
      if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {
        y += maxHeight - measureTextHeight(font, text, maxWidth);
      } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {
        y += maxHeight / 2 - measureTextHeight(font, text, maxWidth) / 2;
      }
      const defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;
      const {
        lines,
        longestLine
      } = splitLines(font, text, maxWidth);
      lines.forEach((line) => {
        const lineString = line.join(" ");
        const alignmentWidth = xOffsetBasedOnAlignment(this.constructor, font, lineString, maxWidth, alignmentX);
        printText.call(this, font, x + alignmentWidth, y, lineString, defaultCharWidth);
        y += font.common.lineHeight;
      });
      if (isNodePattern(cb)) {
        cb.call(this, null, this, {
          x: x + longestLine,
          y
        });
      }
      return this;
    }
  }
});

// node_modules/@jimp/plugin-resize/es/modules/resize.js
var Resize = function(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
  this.colorChannels = blendAlpha ? 4 : 3;
  this.interpolationPass = Boolean(interpolationPass);
  this.resizeCallback = typeof resizeCallback === "function" ? resizeCallback : function() {
  };
  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
  this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
  this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
  this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
  this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
  this.initialize();
};
Resize.prototype.initialize = function() {
  if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
    this.configurePasses();
  } else {
    throw new Error("Invalid settings specified for the resizer.");
  }
};
Resize.prototype.configurePasses = function() {
  if (this.widthOriginal === this.targetWidth) {
    this.resizeWidth = this.bypassResizer;
  } else {
    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
      this.initializeFirstPassBuffers(true);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
    } else {
      this.initializeFirstPassBuffers(false);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
    }
  }
  if (this.heightOriginal === this.targetHeight) {
    this.resizeHeight = this.bypassResizer;
  } else {
    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
      this.initializeSecondPassBuffers(true);
      this.resizeHeight = this.resizeHeightInterpolated;
    } else {
      this.initializeSecondPassBuffers(false);
      this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
    }
  }
};
Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
  const channelsNum = fourthChannel ? 4 : 3;
  const ratioWeight = this.ratioWeightWidthPass;
  const outputBuffer = this.widthBuffer;
  let weight = 0;
  let finalOffset = 0;
  let pixelOffset = 0;
  let firstWeight = 0;
  let secondWeight = 0;
  let targetPosition;
  for (targetPosition = 0;weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
    for (finalOffset = targetPosition, pixelOffset = 0;finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  }
  weight -= 1 / 3;
  let interpolationWidthSourceReadStop;
  for (interpolationWidthSourceReadStop = this.widthOriginal - 1;weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight;
    for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum;finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
    }
  }
  for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum;targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
    for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop;finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  }
  return outputBuffer;
};
Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
  const channelsNum = fourthChannel ? 4 : 3;
  const ratioWeight = this.ratioWeightWidthPass;
  const ratioWeightDivisor = 1 / ratioWeight;
  const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
  const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
  const output = this.outputWidthWorkBench;
  const outputBuffer = this.widthBuffer;
  const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
  let weight = 0;
  let amountToNext = 0;
  let actualPosition = 0;
  let currentPosition = 0;
  let line = 0;
  let pixelOffset = 0;
  let outputOffset = 0;
  let multiplier = 1;
  let r = 0;
  let g = 0;
  let b = 0;
  let a = 0;
  do {
    for (line = 0;line < this.originalHeightMultipliedByChannels; ) {
      output[line++] = 0;
      output[line++] = 0;
      output[line++] = 0;
      if (fourthChannel) {
        output[line++] = 0;
        trustworthyColorsCount[line / channelsNum - 1] = 0;
      }
    }
    weight = ratioWeight;
    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);
      for (line = 0, pixelOffset = actualPosition;line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
        r = buffer[pixelOffset];
        g = buffer[++pixelOffset];
        b = buffer[++pixelOffset];
        a = fourthChannel ? buffer[++pixelOffset] : 255;
        output[line++] += (a ? r : 0) * multiplier;
        output[line++] += (a ? g : 0) * multiplier;
        output[line++] += (a ? b : 0) * multiplier;
        if (fourthChannel) {
          output[line++] += a * multiplier;
          trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
        }
      }
      if (weight >= amountToNext) {
        actualPosition += channelsNum;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
    for (line = 0, pixelOffset = outputOffset;line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      if (fourthChannel)
        outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
    }
    outputOffset += channelsNum;
  } while (outputOffset < this.targetWidthMultipliedByChannels);
  return outputBuffer;
};
Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
  const ratioWeight = this.ratioWeightHeightPass;
  const ratioWeightDivisor = 1 / ratioWeight;
  const output = this.outputHeightWorkBench;
  const outputBuffer = this.heightBuffer;
  const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
  let weight = 0;
  let amountToNext = 0;
  let actualPosition = 0;
  let currentPosition = 0;
  let pixelOffset = 0;
  let outputOffset = 0;
  let caret = 0;
  let multiplier = 1;
  let r = 0;
  let g = 0;
  let b = 0;
  let a = 0;
  do {
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;
      if (fourthChannel) {
        output[pixelOffset++] = 0;
        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
      }
    }
    weight = ratioWeight;
    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);
      caret = actualPosition;
      for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
        r = buffer[caret++];
        g = buffer[caret++];
        b = buffer[caret++];
        a = fourthChannel ? buffer[caret++] : 255;
        output[pixelOffset++] += (a ? r : 0) * multiplier;
        output[pixelOffset++] += (a ? g : 0) * multiplier;
        output[pixelOffset++] += (a ? b : 0) * multiplier;
        if (fourthChannel) {
          output[pixelOffset++] += a * multiplier;
          trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
        }
      }
      if (weight >= amountToNext) {
        actualPosition = caret;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.widthPassResultSize);
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      if (fourthChannel) {
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
      }
    }
  } while (outputOffset < this.finalResultSize);
  return outputBuffer;
};
Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, true);
};
Resize.prototype.resizeWidthRGB = function(buffer) {
  return this._resizeWidthRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthRGBA = function(buffer) {
  return this._resizeWidthRGBChannels(buffer, true);
};
Resize.prototype.resizeHeightInterpolated = function(buffer) {
  const ratioWeight = this.ratioWeightHeightPass;
  const outputBuffer = this.heightBuffer;
  let weight = 0;
  let finalOffset = 0;
  let pixelOffset = 0;
  let pixelOffsetAccumulated = 0;
  let pixelOffsetAccumulated2 = 0;
  let firstWeight = 0;
  let secondWeight = 0;
  let interpolationHeightSourceReadStop;
  for (;weight < 1 / 3; weight += ratioWeight) {
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
    }
  }
  weight -= 1 / 3;
  for (interpolationHeightSourceReadStop = this.heightOriginal - 1;weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight;
    pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
    pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
    }
  }
  while (finalOffset < this.finalResultSize) {
    for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels;pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
    }
  }
  return outputBuffer;
};
Resize.prototype.resizeHeightRGB = function(buffer) {
  return this._resizeHeightRGBChannels(buffer, false);
};
Resize.prototype.resizeHeightRGBA = function(buffer) {
  return this._resizeHeightRGBChannels(buffer, true);
};
Resize.prototype.resize = function(buffer) {
  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
};
Resize.prototype.bypassResizer = function(buffer) {
  return buffer;
};
Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
  if (!BILINEARAlgo) {
    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
    if (this.colorChannels > 3) {
      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
    }
  }
};
Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
  if (!BILINEARAlgo) {
    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
    if (this.colorChannels > 3) {
      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
    }
  }
};
Resize.prototype.generateFloatBuffer = function(bufferLength) {
  try {
    return new Float32Array(bufferLength);
  } catch (error) {
    return [];
  }
};
Resize.prototype.generateFloat64Buffer = function(bufferLength) {
  try {
    return new Float64Array(bufferLength);
  } catch (error) {
    return [];
  }
};
Resize.prototype.generateUint8Buffer = function(bufferLength) {
  try {
    return new Uint8Array(bufferLength);
  } catch (error) {
    return [];
  }
};
var resize_default = Resize;

// node_modules/@jimp/plugin-resize/es/modules/resize2.js
var operations = {
  nearestNeighbor(src, dst) {
    const wSrc = src.width;
    const hSrc = src.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const bufSrc = src.data;
    const bufDst = dst.data;
    for (let i2 = 0;i2 < hDst; i2++) {
      for (let j = 0;j < wDst; j++) {
        let posDst = (i2 * wDst + j) * 4;
        const iSrc = Math.floor(i2 * hSrc / hDst);
        const jSrc = Math.floor(j * wSrc / wDst);
        let posSrc = (iSrc * wSrc + jSrc) * 4;
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
      }
    }
  },
  bilinearInterpolation(src, dst) {
    const wSrc = src.width;
    const hSrc = src.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const bufSrc = src.data;
    const bufDst = dst.data;
    const interpolate = function(k, kMin, vMin, kMax, vMax) {
      if (kMin === kMax) {
        return vMin;
      }
      return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
    };
    const assign = function(pos, offset, x, xMin, xMax, y, yMin, yMax) {
      let posMin = (yMin * wSrc + xMin) * 4 + offset;
      let posMax = (yMin * wSrc + xMax) * 4 + offset;
      const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
      if (yMax === yMin) {
        bufDst[pos + offset] = vMin;
      } else {
        posMin = (yMax * wSrc + xMin) * 4 + offset;
        posMax = (yMax * wSrc + xMax) * 4 + offset;
        const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
        bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
      }
    };
    for (let i2 = 0;i2 < hDst; i2++) {
      for (let j = 0;j < wDst; j++) {
        const posDst = (i2 * wDst + j) * 4;
        const x = j * wSrc / wDst;
        const xMin = Math.floor(x);
        const xMax = Math.min(Math.ceil(x), wSrc - 1);
        const y = i2 * hSrc / hDst;
        const yMin = Math.floor(y);
        const yMax = Math.min(Math.ceil(y), hSrc - 1);
        assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
      }
    }
  },
  _interpolate2D(src, dst, options, interpolate) {
    const bufSrc = src.data;
    const bufDst = dst.data;
    const wSrc = src.width;
    const hSrc = src.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const wM = Math.max(1, Math.floor(wSrc / wDst));
    const wDst2 = wDst * wM;
    const hM = Math.max(1, Math.floor(hSrc / hDst));
    const hDst2 = hDst * hM;
    const buf1 = Buffer.alloc(wDst2 * hSrc * 4);
    for (let i2 = 0;i2 < hSrc; i2++) {
      for (let j = 0;j < wDst2; j++) {
        const x = j * (wSrc - 1) / wDst2;
        const xPos = Math.floor(x);
        const t = x - xPos;
        const srcPos = (i2 * wSrc + xPos) * 4;
        const buf1Pos = (i2 * wDst2 + j) * 4;
        for (let k = 0;k < 4; k++) {
          const kPos = srcPos + k;
          const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
          const x1 = bufSrc[kPos];
          const x2 = bufSrc[kPos + 4];
          const x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
          buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
        }
      }
    }
    const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
    for (let i2 = 0;i2 < hDst2; i2++) {
      for (let j = 0;j < wDst2; j++) {
        const y = i2 * (hSrc - 1) / hDst2;
        const yPos = Math.floor(y);
        const t = y - yPos;
        const buf1Pos = (yPos * wDst2 + j) * 4;
        const buf2Pos = (i2 * wDst2 + j) * 4;
        for (let k = 0;k < 4; k++) {
          const kPos = buf1Pos + k;
          const y0 = yPos > 0 ? buf1[kPos - wDst2 * 4] : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];
          const y1 = buf1[kPos];
          const y2 = buf1[kPos + wDst2 * 4];
          const y3 = yPos < hSrc - 2 ? buf1[kPos + wDst2 * 8] : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];
          buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);
        }
      }
    }
    const m = wM * hM;
    if (m > 1) {
      for (let i2 = 0;i2 < hDst; i2++) {
        for (let j = 0;j < wDst; j++) {
          let r = 0;
          let g = 0;
          let b = 0;
          let a = 0;
          let realColors = 0;
          for (let y = 0;y < hM; y++) {
            const yPos = i2 * hM + y;
            for (let x = 0;x < wM; x++) {
              const xPos = j * wM + x;
              const xyPos = (yPos * wDst2 + xPos) * 4;
              const pixelAlpha = buf2[xyPos + 3];
              if (pixelAlpha) {
                r += buf2[xyPos];
                g += buf2[xyPos + 1];
                b += buf2[xyPos + 2];
                realColors++;
              }
              a += pixelAlpha;
            }
          }
          const pos = (i2 * wDst + j) * 4;
          bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
          bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
          bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
          bufDst[pos + 3] = Math.round(a / m);
        }
      }
    } else {
      dst.data = buf2;
    }
  },
  bicubicInterpolation(src, dst, options) {
    const interpolateCubic = function(x0, x1, x2, x3, t) {
      const a0 = x3 - x2 - x0 + x1;
      const a1 = x0 - x1 - a0;
      const a2 = x2 - x0;
      const a3 = x1;
      return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
    };
    return this._interpolate2D(src, dst, options, interpolateCubic);
  },
  hermiteInterpolation(src, dst, options) {
    const interpolateHermite = function(x0, x1, x2, x3, t) {
      const c0 = x1;
      const c1 = 0.5 * (x2 - x0);
      const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
      const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
      return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
    };
    return this._interpolate2D(src, dst, options, interpolateHermite);
  },
  bezierInterpolation(src, dst, options) {
    const interpolateBezier = function(x0, x1, x2, x3, t) {
      const cp1 = x1 + (x2 - x0) / 4;
      const cp2 = x2 - (x3 - x1) / 4;
      const nt = 1 - t;
      const c0 = x1 * nt * nt * nt;
      const c1 = 3 * cp1 * nt * nt * t;
      const c2 = 3 * cp2 * nt * t * t;
      const c3 = x2 * t * t * t;
      return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
    };
    return this._interpolate2D(src, dst, options, interpolateBezier);
  }
};
var resize2_default = operations;

// node_modules/@jimp/plugin-resize/es/index.js
var es_default23 = () => ({
  constants: {
    RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
    RESIZE_BILINEAR: "bilinearInterpolation",
    RESIZE_BICUBIC: "bicubicInterpolation",
    RESIZE_HERMITE: "hermiteInterpolation",
    RESIZE_BEZIER: "bezierInterpolation"
  },
  class: {
    resize(w, h, mode, cb) {
      if (typeof w !== "number" || typeof h !== "number") {
        return throwError.call(this, "w and h must be numbers", cb);
      }
      if (typeof mode === "function" && typeof cb === "undefined") {
        cb = mode;
        mode = null;
      }
      if (w === this.constructor.AUTO && h === this.constructor.AUTO) {
        return throwError.call(this, "w and h cannot both be set to auto", cb);
      }
      if (w === this.constructor.AUTO) {
        w = this.bitmap.width * (h / this.bitmap.height);
      }
      if (h === this.constructor.AUTO) {
        h = this.bitmap.height * (w / this.bitmap.width);
      }
      if (w < 0 || h < 0) {
        return throwError.call(this, "w and h must be positive numbers", cb);
      }
      w = Math.round(w) || 1;
      h = Math.round(h) || 1;
      if (typeof resize2_default[mode] === "function") {
        const dst = {
          data: Buffer.alloc(w * h * 4),
          width: w,
          height: h
        };
        resize2_default[mode](this.bitmap, dst);
        this.bitmap = dst;
      } else {
        const image2 = this;
        const resize3 = new resize_default(this.bitmap.width, this.bitmap.height, w, h, true, true, (buffer) => {
          image2.bitmap.data = Buffer.from(buffer);
          image2.bitmap.width = w;
          image2.bitmap.height = h;
        });
        resize3.resize(this.bitmap.data);
      }
      if (isNodePattern(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
  }
});

// node_modules/@jimp/plugin-rotate/es/index.js
var matrixRotate = function(deg) {
  if (Math.abs(deg) % 90 !== 0) {
    throw new Error("Unsupported matrix rotation degree");
  }
  deg %= 360;
  if (Math.abs(deg) === 0) {
    return;
  }
  const w = this.bitmap.width;
  const h = this.bitmap.height;
  let angle;
  switch (deg) {
    case 90:
    case -270:
      angle = 90;
      break;
    case 180:
    case -180:
      angle = 180;
      break;
    case 270:
    case -90:
      angle = -90;
      break;
    default:
      throw new Error("Unsupported matrix rotation degree");
  }
  const nW = angle === 180 ? w : h;
  const nH = angle === 180 ? h : w;
  const dstBuffer = Buffer.alloc(this.bitmap.data.length);
  function createIdxTranslationFunction(w2, h2) {
    return function(x, y) {
      return y * w2 + x << 2;
    };
  }
  const srcIdxFunction = createIdxTranslationFunction(w, h);
  const dstIdxFunction = createIdxTranslationFunction(nW, nH);
  for (let x = 0;x < w; x++) {
    for (let y = 0;y < h; y++) {
      const srcIdx = srcIdxFunction(x, y);
      const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
      let dstIdx;
      switch (angle) {
        case 90:
          dstIdx = dstIdxFunction(y, w - x - 1);
          break;
        case -90:
          dstIdx = dstIdxFunction(h - y - 1, x);
          break;
        case 180:
          dstIdx = dstIdxFunction(w - x - 1, h - y - 1);
          break;
        default:
          throw new Error("Unsupported matrix rotation angle");
      }
      dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
    }
  }
  this.bitmap.data = dstBuffer;
  this.bitmap.width = nW;
  this.bitmap.height = nH;
};
var advancedRotate = function(deg, mode) {
  deg %= 360;
  const rad = deg * Math.PI / 180;
  const cosine = Math.cos(rad);
  const sine = Math.sin(rad);
  let w = this.bitmap.width;
  let h = this.bitmap.height;
  if (mode === true || typeof mode === "string") {
    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;
    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1;
    if (w % 2 !== 0) {
      w++;
    }
    if (h % 2 !== 0) {
      h++;
    }
    const c2 = this.cloneQuiet();
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
      this.bitmap.data.writeUInt32BE(this._background, idx);
    });
    const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
    this.resize(max, max, mode);
    this.blit(c2, this.bitmap.width / 2 - c2.bitmap.width / 2, this.bitmap.height / 2 - c2.bitmap.height / 2);
  }
  const bW = this.bitmap.width;
  const bH = this.bitmap.height;
  const dstBuffer = Buffer.alloc(this.bitmap.data.length);
  function createTranslationFunction(deltaX, deltaY) {
    return function(x, y) {
      return {
        x: x + deltaX,
        y: y + deltaY
      };
    };
  }
  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
  const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
  for (let y = 1;y <= bH; y++) {
    for (let x = 1;x <= bW; x++) {
      const cartesian = translate2Cartesian(x, y);
      const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
      const dstIdx = bW * (y - 1) + x - 1 << 2;
      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
        const srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
        const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
      } else {
        dstBuffer.writeUInt32BE(this._background, dstIdx);
      }
    }
  }
  this.bitmap.data = dstBuffer;
  if (mode === true || typeof mode === "string") {
    const x = bW / 2 - w / 2;
    const y = bH / 2 - h / 2;
    this.crop(x, y, w, h);
  }
};
var es_default24 = () => ({
  rotate(deg, mode, cb) {
    if (typeof mode === "undefined" || mode === null) {
      mode = true;
    }
    if (typeof mode === "function" && typeof cb === "undefined") {
      cb = mode;
      mode = true;
    }
    if (typeof deg !== "number") {
      return throwError.call(this, "deg must be a number", cb);
    }
    if (typeof mode !== "boolean" && typeof mode !== "string") {
      return throwError.call(this, "mode must be a boolean or a string", cb);
    }
    const matrixRotateAllowed = deg % 90 === 0 && (mode || this.bitmap.width === this.bitmap.height || deg % 180 === 0);
    if (matrixRotateAllowed) {
      matrixRotate.call(this, deg);
    } else {
      advancedRotate.call(this, deg, mode, cb);
    }
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-scale/es/index.js
var es_default25 = () => ({
  scale(f, mode, cb) {
    if (typeof f !== "number") {
      return throwError.call(this, "f must be a number", cb);
    }
    if (f < 0) {
      return throwError.call(this, "f must be a positive number", cb);
    }
    if (typeof mode === "function" && typeof cb === "undefined") {
      cb = mode;
      mode = null;
    }
    const w = this.bitmap.width * f;
    const h = this.bitmap.height * f;
    this.resize(w, h, mode);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  },
  scaleToFit(w, h, mode, cb) {
    if (typeof w !== "number" || typeof h !== "number") {
      return throwError.call(this, "w and h must be numbers", cb);
    }
    if (typeof mode === "function" && typeof cb === "undefined") {
      cb = mode;
      mode = null;
    }
    const f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
    this.scale(f, mode);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-shadow/es/index.js
var es_default26 = () => ({
  shadow() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let cb = arguments.length > 1 ? arguments[1] : undefined;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    const {
      opacity = 0.7,
      size = 1.1,
      x = -25,
      y = 25,
      blur = 5
    } = options;
    const orig = this.clone();
    const shadow = this.clone();
    shadow.scan(0, 0, shadow.bitmap.width, shadow.bitmap.height, (x2, y2, idx) => {
      shadow.bitmap.data[idx] = 0;
      shadow.bitmap.data[idx + 1] = 0;
      shadow.bitmap.data[idx + 2] = 0;
      shadow.bitmap.data[idx + 3] = shadow.constructor.limit255(shadow.bitmap.data[idx + 3] * opacity);
      this.bitmap.data[idx] = 0;
      this.bitmap.data[idx + 1] = 0;
      this.bitmap.data[idx + 2] = 0;
      this.bitmap.data[idx + 3] = 0;
    });
    shadow.resize(shadow.bitmap.width * size, shadow.bitmap.height * size).blur(blur);
    this.composite(shadow, x, y);
    this.composite(orig, 0, 0);
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugin-threshold/es/index.js
var es_default27 = () => ({
  threshold(_ref, cb) {
    let {
      max,
      replace = 255,
      autoGreyscale = true
    } = _ref;
    if (typeof max !== "number") {
      return throwError.call(this, "max must be a number", cb);
    }
    if (typeof replace !== "number") {
      return throwError.call(this, "replace must be a number", cb);
    }
    if (typeof autoGreyscale !== "boolean") {
      return throwError.call(this, "autoGreyscale must be a boolean", cb);
    }
    max = this.constructor.limit255(max);
    replace = this.constructor.limit255(replace);
    if (autoGreyscale) {
      this.greyscale();
    }
    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
      const grey = this.bitmap.data[idx] < max ? this.bitmap.data[idx] : replace;
      this.bitmap.data[idx] = grey;
      this.bitmap.data[idx + 1] = grey;
      this.bitmap.data[idx + 2] = grey;
    });
    if (isNodePattern(cb)) {
      cb.call(this, null, this);
    }
    return this;
  }
});

// node_modules/@jimp/plugins/es/index.js
var plugins = [es_default8, es_default9, es_default10, es_default11, es_default12, es_default13, pluginCrop, es_default14, es_default15, es_default16, es_default17, es_default18, es_default19, es_default20, es_default21, es_default22, es_default23, es_default24, es_default25, es_default26, es_default27];
var es_default28 = (jimpEvChange2) => {
  const initializedPlugins = plugins.map((pluginModule) => {
    let plugin = pluginModule(jimpEvChange2) || {};
    if (!plugin.class && !plugin.constants) {
      plugin = {
        class: plugin
      };
    }
    return plugin;
  });
  return import_timm2.mergeDeep(...initializedPlugins);
};

// node_modules/jimp/es/index.js
var es_default29 = configure({
  types: [es_default7],
  plugins: [es_default28]
});

// services/ImageProcessor.ts
class ImageInputProcessor {
  inputImagePath;
  constructor(inputImagePath) {
    this.inputImagePath = inputImagePath;
  }
  async toBinary() {
    try {
      const image2 = await undefined(this.inputImagePath);
      return this.imageReadResolver(image2);
    } catch (error) {
      this.imageReadRejector(error);
      return [];
    }
  }
  parseBinary(bitStrings) {
    const binaryStringToNumber = (binaryString) => parseInt(binaryString, 2);
    const numbers = bitStrings.map(binaryStringToNumber);
    const buffer = Buffer.from(numbers);
    return buffer;
  }
  async saveImage(output, cover, dataImage) {
    try {
      console.log(cover);
      const image2 = await undefined(cover);
      image2.bitmap.data = dataImage;
      await image2.writeAsync(output);
    } catch (error) {
      console.error("Error:", error);
    }
  }
  imageReadResolver(image2) {
    let binaryArray = [];
    image2.bitmap.data.forEach(function(value2) {
      const binary = value2.toString(2).padStart(8, "0");
      binaryArray.push(binary);
    });
    return binaryArray;
  }
  imageReadRejector(error) {
  }
}

// services/LSBSteganography.ts
class LSBSteganography {
  processor;
  constructor(processor) {
    this.processor = processor;
  }
  async hide(cover, message) {
    const joinedMessage = message.join("");
    const messageSize = joinedMessage.length;
    let coverClone = cover;
    this.scan(coverClone, function(value2, index) {
      if (messageSize > index) {
        const bit = parseInt(joinedMessage[index]);
        const newValue = LSBSteganography.replaceLSB(value2, bit);
        coverClone[index] = newValue;
      }
    });
    return coverClone;
  }
  reveal(stegaBinary, binaryLength) {
    const messageSize = binaryLength;
    const stegaCLone = stegaBinary;
    let revealMessage = "";
    this.scan(stegaCLone, function(value2, index) {
      if (messageSize > index) {
        const binaryLastIndex = value2.length - 1;
        const bit = value2[binaryLastIndex];
        revealMessage += bit;
      }
    });
    return revealMessage;
  }
  scan(cover, callback) {
    cover.forEach(function(value2, index) {
      callback(value2, index);
    });
  }
  static replaceLSB(binaryString, replaceWith) {
    if (replaceWith !== 0 && replaceWith !== 1) {
      throw new Error("replaceWith must be either 0 or 1");
    }
    let modifiedString = binaryString.split("");
    for (const char of binaryString) {
      if (!/^0|1$/.test(char)) {
        throw new Error(`Invalid binary string character: ${char}`);
      }
      const bit = replaceWith.toString();
      modifiedString.pop();
      modifiedString.push(bit);
      return modifiedString.join("");
    }
    return modifiedString.join("");
  }
}

// services/TextProcessor.ts
class TextProcessor {
  textInput;
  constructor(textInput) {
    this.textInput = textInput;
  }
  toBinary() {
    const binary = this.textInput.split("").map(function(value2, index, array) {
      return value2.charCodeAt(0).toString(2).padStart(8, "0");
    });
    return binary;
  }
  parseBinary(binary) {
    return binary.match(/.{8}/g)?.map((byte) => String.fromCharCode(parseInt(byte, 2))).join("");
  }
}

// facade/Stega.ts
class Stega {
  static async hide(input, output, message, password) {
    const imageProcessor = new ImageInputProcessor(input);
    const imageBinary = await imageProcessor.toBinary();
    const textProcessor = new TextProcessor(message);
    const textBinary = textProcessor.toBinary();
    const stega = new LSBSteganography;
    const stegaBinary = await stega.hide(imageBinary, textBinary);
    const stegaBinaryBuffer = imageProcessor.parseBinary(stegaBinary);
    await imageProcessor.saveImage(output, input, stegaBinaryBuffer);
    const textBinarySize = textBinary.join("").length;
    const newData = new DataService;
    newData.save({ password, size: textBinarySize });
  }
  static async reveal(input, password) {
    const dataService = new DataService;
    const messageSize = dataService.verify(password);
    if (messageSize === -1 || messageSize === 0) {
      throw new Error("Steganogany indentity not found");
    }
    const imageProcessor = new ImageInputProcessor(input);
    const imageBinary = await imageProcessor.toBinary();
    const stega = new LSBSteganography;
    const revealMessage = stega.reveal(imageBinary, messageSize);
    const textProcessor = new TextProcessor("");
    return textProcessor.parseBinary(revealMessage);
  }
}

// actions/Hide.ts
class Hide {
  async execute(input, message, output) {
    try {
      import_prompt.default.message = "$";
      let promptInputs;
      let prompts = [default_];
      if (!output) {
        prompts.push({ name: "outputImage", description: "Enter the output name", require: true });
      }
      if (!message) {
        prompts.push({ name: "messageToHide", description: "Enter message", require: true });
      }
      import_prompt.start();
      promptInputs = await import_prompt.get(prompts);
      import_prompt.stop();
      const outputImage = output || promptInputs.outputImage;
      const messageHide = message || promptInputs.messageToHide.toString();
      await Stega.hide(input, outputImage, messageHide, promptInputs.password);
      console.log("Message hide:\n\t", messageHide);
      console.log("Saved on:\n\t", outputImage);
    } catch (error) {
      console.error("Steganegany hide failed!!!");
    }
  }
}

// facade/Data.ts
class Data {
  static async reset() {
    const dataService = new DataService;
    await dataService.reset();
  }
}

// actions/Reset.ts
class Reset {
  async execute() {
    try {
      await Data.reset();
      console.log("Reset data succesfully");
    } catch (error) {
      console.error("Failed to reset saved data");
    }
  }
}

// actions/Reveal.ts
var import_prompt2 = __toESM(require_prompt(), 1);
class Reveal {
  async execute(input) {
    try {
      import_prompt2.default.message = "$";
      let prompts = [default_];
      const { password: password3 } = await import_prompt2.get(prompts);
      const message = await Stega.reveal(input, password3);
      console.log("Hidden message:\n\t\t", message);
    } catch (error) {
      console.error("Steganogany reveal failed!!!");
    }
  }
}

// steganegany.ts
program.name("steganegany").description("This hide message into an image (only png supported)");
program.command("hide").argument("<input-file>", "This is the image to hide the message").argument("[message]", "This is the message to hide").argument("[output-file]", "This is the image that hide a message").action(new Hide().execute);
program.command("reveal").argument("<input-file>", "This is the image that hide a message").action(new Reveal().execute);
program.command("reset").description("This reset the saved recognized password in the system").action(new Reset().execute);
program.parse();
